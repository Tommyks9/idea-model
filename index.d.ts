
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model province
 * 
 */
export type province = $Result.DefaultSelection<Prisma.$provincePayload>
/**
 * Model district
 * 
 */
export type district = $Result.DefaultSelection<Prisma.$districtPayload>
/**
 * Model village
 * 
 */
export type village = $Result.DefaultSelection<Prisma.$villagePayload>
/**
 * Model address
 * 
 */
export type address = $Result.DefaultSelection<Prisma.$addressPayload>
/**
 * Model branches
 * 
 */
export type branches = $Result.DefaultSelection<Prisma.$branchesPayload>
/**
 * Model branchesKey
 * 
 */
export type branchesKey = $Result.DefaultSelection<Prisma.$branchesKeyPayload>
/**
 * Model branchesSettings
 * 
 */
export type branchesSettings = $Result.DefaultSelection<Prisma.$branchesSettingsPayload>
/**
 * Model wallet
 * 
 */
export type wallet = $Result.DefaultSelection<Prisma.$walletPayload>
/**
 * Model transaction
 * 
 */
export type transaction = $Result.DefaultSelection<Prisma.$transactionPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model profile
 * 
 */
export type profile = $Result.DefaultSelection<Prisma.$profilePayload>
/**
 * Model otp
 * 
 */
export type otp = $Result.DefaultSelection<Prisma.$otpPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>
/**
 * Model forgotPassword
 * 
 */
export type forgotPassword = $Result.DefaultSelection<Prisma.$forgotPasswordPayload>
/**
 * Model usersRoles
 * 
 */
export type usersRoles = $Result.DefaultSelection<Prisma.$usersRolesPayload>
/**
 * Model usersActivities
 * 
 */
export type usersActivities = $Result.DefaultSelection<Prisma.$usersActivitiesPayload>
/**
 * Model orderType
 * 
 */
export type orderType = $Result.DefaultSelection<Prisma.$orderTypePayload>
/**
 * Model orderCategory
 * 
 */
export type orderCategory = $Result.DefaultSelection<Prisma.$orderCategoryPayload>
/**
 * Model order
 * 
 */
export type order = $Result.DefaultSelection<Prisma.$orderPayload>
/**
 * Model orderThreading
 * 
 */
export type orderThreading = $Result.DefaultSelection<Prisma.$orderThreadingPayload>
/**
 * Model orderPersonal
 * 
 */
export type orderPersonal = $Result.DefaultSelection<Prisma.$orderPersonalPayload>
/**
 * Model orderPayment
 * 
 */
export type orderPayment = $Result.DefaultSelection<Prisma.$orderPaymentPayload>
/**
 * Model orderDetails
 * 
 */
export type orderDetails = $Result.DefaultSelection<Prisma.$orderDetailsPayload>
/**
 * Model tackingStatus
 * 
 */
export type tackingStatus = $Result.DefaultSelection<Prisma.$tackingStatusPayload>
/**
 * Model orderTacking
 * 
 */
export type orderTacking = $Result.DefaultSelection<Prisma.$orderTackingPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Provinces
 * const provinces = await prisma.province.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Provinces
   * const provinces = await prisma.province.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.province`: Exposes CRUD operations for the **province** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provinces
    * const provinces = await prisma.province.findMany()
    * ```
    */
  get province(): Prisma.provinceDelegate<ExtArgs>;

  /**
   * `prisma.district`: Exposes CRUD operations for the **district** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Districts
    * const districts = await prisma.district.findMany()
    * ```
    */
  get district(): Prisma.districtDelegate<ExtArgs>;

  /**
   * `prisma.village`: Exposes CRUD operations for the **village** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Villages
    * const villages = await prisma.village.findMany()
    * ```
    */
  get village(): Prisma.villageDelegate<ExtArgs>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.addressDelegate<ExtArgs>;

  /**
   * `prisma.branches`: Exposes CRUD operations for the **branches** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branches.findMany()
    * ```
    */
  get branches(): Prisma.branchesDelegate<ExtArgs>;

  /**
   * `prisma.branchesKey`: Exposes CRUD operations for the **branchesKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BranchesKeys
    * const branchesKeys = await prisma.branchesKey.findMany()
    * ```
    */
  get branchesKey(): Prisma.branchesKeyDelegate<ExtArgs>;

  /**
   * `prisma.branchesSettings`: Exposes CRUD operations for the **branchesSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BranchesSettings
    * const branchesSettings = await prisma.branchesSettings.findMany()
    * ```
    */
  get branchesSettings(): Prisma.branchesSettingsDelegate<ExtArgs>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.walletDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.transactionDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.profileDelegate<ExtArgs>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.otpDelegate<ExtArgs>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs>;

  /**
   * `prisma.forgotPassword`: Exposes CRUD operations for the **forgotPassword** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForgotPasswords
    * const forgotPasswords = await prisma.forgotPassword.findMany()
    * ```
    */
  get forgotPassword(): Prisma.forgotPasswordDelegate<ExtArgs>;

  /**
   * `prisma.usersRoles`: Exposes CRUD operations for the **usersRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsersRoles
    * const usersRoles = await prisma.usersRoles.findMany()
    * ```
    */
  get usersRoles(): Prisma.usersRolesDelegate<ExtArgs>;

  /**
   * `prisma.usersActivities`: Exposes CRUD operations for the **usersActivities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsersActivities
    * const usersActivities = await prisma.usersActivities.findMany()
    * ```
    */
  get usersActivities(): Prisma.usersActivitiesDelegate<ExtArgs>;

  /**
   * `prisma.orderType`: Exposes CRUD operations for the **orderType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderTypes
    * const orderTypes = await prisma.orderType.findMany()
    * ```
    */
  get orderType(): Prisma.orderTypeDelegate<ExtArgs>;

  /**
   * `prisma.orderCategory`: Exposes CRUD operations for the **orderCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderCategories
    * const orderCategories = await prisma.orderCategory.findMany()
    * ```
    */
  get orderCategory(): Prisma.orderCategoryDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.orderDelegate<ExtArgs>;

  /**
   * `prisma.orderThreading`: Exposes CRUD operations for the **orderThreading** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderThreadings
    * const orderThreadings = await prisma.orderThreading.findMany()
    * ```
    */
  get orderThreading(): Prisma.orderThreadingDelegate<ExtArgs>;

  /**
   * `prisma.orderPersonal`: Exposes CRUD operations for the **orderPersonal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderPersonals
    * const orderPersonals = await prisma.orderPersonal.findMany()
    * ```
    */
  get orderPersonal(): Prisma.orderPersonalDelegate<ExtArgs>;

  /**
   * `prisma.orderPayment`: Exposes CRUD operations for the **orderPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderPayments
    * const orderPayments = await prisma.orderPayment.findMany()
    * ```
    */
  get orderPayment(): Prisma.orderPaymentDelegate<ExtArgs>;

  /**
   * `prisma.orderDetails`: Exposes CRUD operations for the **orderDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderDetails
    * const orderDetails = await prisma.orderDetails.findMany()
    * ```
    */
  get orderDetails(): Prisma.orderDetailsDelegate<ExtArgs>;

  /**
   * `prisma.tackingStatus`: Exposes CRUD operations for the **tackingStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TackingStatuses
    * const tackingStatuses = await prisma.tackingStatus.findMany()
    * ```
    */
  get tackingStatus(): Prisma.tackingStatusDelegate<ExtArgs>;

  /**
   * `prisma.orderTacking`: Exposes CRUD operations for the **orderTacking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderTackings
    * const orderTackings = await prisma.orderTacking.findMany()
    * ```
    */
  get orderTacking(): Prisma.orderTackingDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.14.0
   * Query Engine version: e9771e62de70f79a5e1c604a2d7c8e2a0a874b48
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    province: 'province',
    district: 'district',
    village: 'village',
    address: 'address',
    branches: 'branches',
    branchesKey: 'branchesKey',
    branchesSettings: 'branchesSettings',
    wallet: 'wallet',
    transaction: 'transaction',
    users: 'users',
    profile: 'profile',
    otp: 'otp',
    notifications: 'notifications',
    forgotPassword: 'forgotPassword',
    usersRoles: 'usersRoles',
    usersActivities: 'usersActivities',
    orderType: 'orderType',
    orderCategory: 'orderCategory',
    order: 'order',
    orderThreading: 'orderThreading',
    orderPersonal: 'orderPersonal',
    orderPayment: 'orderPayment',
    orderDetails: 'orderDetails',
    tackingStatus: 'tackingStatus',
    orderTacking: 'orderTacking'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'province' | 'district' | 'village' | 'address' | 'branches' | 'branchesKey' | 'branchesSettings' | 'wallet' | 'transaction' | 'users' | 'profile' | 'otp' | 'notifications' | 'forgotPassword' | 'usersRoles' | 'usersActivities' | 'orderType' | 'orderCategory' | 'order' | 'orderThreading' | 'orderPersonal' | 'orderPayment' | 'orderDetails' | 'tackingStatus' | 'orderTacking'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      province: {
        payload: Prisma.$provincePayload<ExtArgs>
        fields: Prisma.provinceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.provinceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$provincePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.provinceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$provincePayload>
          }
          findFirst: {
            args: Prisma.provinceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$provincePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.provinceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$provincePayload>
          }
          findMany: {
            args: Prisma.provinceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$provincePayload>[]
          }
          create: {
            args: Prisma.provinceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$provincePayload>
          }
          createMany: {
            args: Prisma.provinceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.provinceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$provincePayload>
          }
          update: {
            args: Prisma.provinceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$provincePayload>
          }
          deleteMany: {
            args: Prisma.provinceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.provinceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.provinceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$provincePayload>
          }
          aggregate: {
            args: Prisma.ProvinceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProvince>
          }
          groupBy: {
            args: Prisma.provinceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProvinceGroupByOutputType>[]
          }
          count: {
            args: Prisma.provinceCountArgs<ExtArgs>,
            result: $Utils.Optional<ProvinceCountAggregateOutputType> | number
          }
        }
      }
      district: {
        payload: Prisma.$districtPayload<ExtArgs>
        fields: Prisma.districtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.districtFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.districtFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtPayload>
          }
          findFirst: {
            args: Prisma.districtFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.districtFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtPayload>
          }
          findMany: {
            args: Prisma.districtFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtPayload>[]
          }
          create: {
            args: Prisma.districtCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtPayload>
          }
          createMany: {
            args: Prisma.districtCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.districtDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtPayload>
          }
          update: {
            args: Prisma.districtUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtPayload>
          }
          deleteMany: {
            args: Prisma.districtDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.districtUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.districtUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtPayload>
          }
          aggregate: {
            args: Prisma.DistrictAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDistrict>
          }
          groupBy: {
            args: Prisma.districtGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DistrictGroupByOutputType>[]
          }
          count: {
            args: Prisma.districtCountArgs<ExtArgs>,
            result: $Utils.Optional<DistrictCountAggregateOutputType> | number
          }
        }
      }
      village: {
        payload: Prisma.$villagePayload<ExtArgs>
        fields: Prisma.villageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.villageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$villagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.villageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$villagePayload>
          }
          findFirst: {
            args: Prisma.villageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$villagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.villageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$villagePayload>
          }
          findMany: {
            args: Prisma.villageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$villagePayload>[]
          }
          create: {
            args: Prisma.villageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$villagePayload>
          }
          createMany: {
            args: Prisma.villageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.villageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$villagePayload>
          }
          update: {
            args: Prisma.villageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$villagePayload>
          }
          deleteMany: {
            args: Prisma.villageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.villageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.villageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$villagePayload>
          }
          aggregate: {
            args: Prisma.VillageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVillage>
          }
          groupBy: {
            args: Prisma.villageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VillageGroupByOutputType>[]
          }
          count: {
            args: Prisma.villageCountArgs<ExtArgs>,
            result: $Utils.Optional<VillageCountAggregateOutputType> | number
          }
        }
      }
      address: {
        payload: Prisma.$addressPayload<ExtArgs>
        fields: Prisma.addressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.addressFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.addressFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          findFirst: {
            args: Prisma.addressFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.addressFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          findMany: {
            args: Prisma.addressFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>[]
          }
          create: {
            args: Prisma.addressCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          createMany: {
            args: Prisma.addressCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.addressDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          update: {
            args: Prisma.addressUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          deleteMany: {
            args: Prisma.addressDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.addressUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.addressUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.addressGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.addressCountArgs<ExtArgs>,
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      branches: {
        payload: Prisma.$branchesPayload<ExtArgs>
        fields: Prisma.branchesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.branchesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.branchesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          findFirst: {
            args: Prisma.branchesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.branchesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          findMany: {
            args: Prisma.branchesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>[]
          }
          create: {
            args: Prisma.branchesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          createMany: {
            args: Prisma.branchesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.branchesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          update: {
            args: Prisma.branchesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          deleteMany: {
            args: Prisma.branchesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.branchesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.branchesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          aggregate: {
            args: Prisma.BranchesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBranches>
          }
          groupBy: {
            args: Prisma.branchesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BranchesGroupByOutputType>[]
          }
          count: {
            args: Prisma.branchesCountArgs<ExtArgs>,
            result: $Utils.Optional<BranchesCountAggregateOutputType> | number
          }
        }
      }
      branchesKey: {
        payload: Prisma.$branchesKeyPayload<ExtArgs>
        fields: Prisma.branchesKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.branchesKeyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.branchesKeyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesKeyPayload>
          }
          findFirst: {
            args: Prisma.branchesKeyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.branchesKeyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesKeyPayload>
          }
          findMany: {
            args: Prisma.branchesKeyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesKeyPayload>[]
          }
          create: {
            args: Prisma.branchesKeyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesKeyPayload>
          }
          createMany: {
            args: Prisma.branchesKeyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.branchesKeyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesKeyPayload>
          }
          update: {
            args: Prisma.branchesKeyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesKeyPayload>
          }
          deleteMany: {
            args: Prisma.branchesKeyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.branchesKeyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.branchesKeyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesKeyPayload>
          }
          aggregate: {
            args: Prisma.BranchesKeyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBranchesKey>
          }
          groupBy: {
            args: Prisma.branchesKeyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BranchesKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.branchesKeyCountArgs<ExtArgs>,
            result: $Utils.Optional<BranchesKeyCountAggregateOutputType> | number
          }
        }
      }
      branchesSettings: {
        payload: Prisma.$branchesSettingsPayload<ExtArgs>
        fields: Prisma.branchesSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.branchesSettingsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.branchesSettingsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesSettingsPayload>
          }
          findFirst: {
            args: Prisma.branchesSettingsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.branchesSettingsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesSettingsPayload>
          }
          findMany: {
            args: Prisma.branchesSettingsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesSettingsPayload>[]
          }
          create: {
            args: Prisma.branchesSettingsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesSettingsPayload>
          }
          createMany: {
            args: Prisma.branchesSettingsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.branchesSettingsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesSettingsPayload>
          }
          update: {
            args: Prisma.branchesSettingsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesSettingsPayload>
          }
          deleteMany: {
            args: Prisma.branchesSettingsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.branchesSettingsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.branchesSettingsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$branchesSettingsPayload>
          }
          aggregate: {
            args: Prisma.BranchesSettingsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBranchesSettings>
          }
          groupBy: {
            args: Prisma.branchesSettingsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BranchesSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.branchesSettingsCountArgs<ExtArgs>,
            result: $Utils.Optional<BranchesSettingsCountAggregateOutputType> | number
          }
        }
      }
      wallet: {
        payload: Prisma.$walletPayload<ExtArgs>
        fields: Prisma.walletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.walletFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$walletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.walletFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          findFirst: {
            args: Prisma.walletFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$walletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.walletFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          findMany: {
            args: Prisma.walletFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$walletPayload>[]
          }
          create: {
            args: Prisma.walletCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          createMany: {
            args: Prisma.walletCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.walletDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          update: {
            args: Prisma.walletUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          deleteMany: {
            args: Prisma.walletDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.walletUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.walletUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.walletGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.walletCountArgs<ExtArgs>,
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      transaction: {
        payload: Prisma.$transactionPayload<ExtArgs>
        fields: Prisma.transactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          findFirst: {
            args: Prisma.transactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          findMany: {
            args: Prisma.transactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>[]
          }
          create: {
            args: Prisma.transactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          createMany: {
            args: Prisma.transactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.transactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          update: {
            args: Prisma.transactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          deleteMany: {
            args: Prisma.transactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.transactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.transactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.transactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.transactionCountArgs<ExtArgs>,
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      profile: {
        payload: Prisma.$profilePayload<ExtArgs>
        fields: Prisma.profileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.profileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.profileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          findFirst: {
            args: Prisma.profileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.profileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          findMany: {
            args: Prisma.profileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload>[]
          }
          create: {
            args: Prisma.profileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          createMany: {
            args: Prisma.profileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.profileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          update: {
            args: Prisma.profileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          deleteMany: {
            args: Prisma.profileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.profileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.profileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.profileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.profileCountArgs<ExtArgs>,
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      otp: {
        payload: Prisma.$otpPayload<ExtArgs>
        fields: Prisma.otpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.otpFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.otpFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          findFirst: {
            args: Prisma.otpFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.otpFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          findMany: {
            args: Prisma.otpFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload>[]
          }
          create: {
            args: Prisma.otpCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          createMany: {
            args: Prisma.otpCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.otpDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          update: {
            args: Prisma.otpUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          deleteMany: {
            args: Prisma.otpDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.otpUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.otpUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.otpGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.otpCountArgs<ExtArgs>,
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      forgotPassword: {
        payload: Prisma.$forgotPasswordPayload<ExtArgs>
        fields: Prisma.forgotPasswordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.forgotPasswordFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$forgotPasswordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.forgotPasswordFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$forgotPasswordPayload>
          }
          findFirst: {
            args: Prisma.forgotPasswordFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$forgotPasswordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.forgotPasswordFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$forgotPasswordPayload>
          }
          findMany: {
            args: Prisma.forgotPasswordFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$forgotPasswordPayload>[]
          }
          create: {
            args: Prisma.forgotPasswordCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$forgotPasswordPayload>
          }
          createMany: {
            args: Prisma.forgotPasswordCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.forgotPasswordDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$forgotPasswordPayload>
          }
          update: {
            args: Prisma.forgotPasswordUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$forgotPasswordPayload>
          }
          deleteMany: {
            args: Prisma.forgotPasswordDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.forgotPasswordUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.forgotPasswordUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$forgotPasswordPayload>
          }
          aggregate: {
            args: Prisma.ForgotPasswordAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateForgotPassword>
          }
          groupBy: {
            args: Prisma.forgotPasswordGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ForgotPasswordGroupByOutputType>[]
          }
          count: {
            args: Prisma.forgotPasswordCountArgs<ExtArgs>,
            result: $Utils.Optional<ForgotPasswordCountAggregateOutputType> | number
          }
        }
      }
      usersRoles: {
        payload: Prisma.$usersRolesPayload<ExtArgs>
        fields: Prisma.usersRolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersRolesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersRolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersRolesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersRolesPayload>
          }
          findFirst: {
            args: Prisma.usersRolesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersRolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersRolesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersRolesPayload>
          }
          findMany: {
            args: Prisma.usersRolesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersRolesPayload>[]
          }
          create: {
            args: Prisma.usersRolesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersRolesPayload>
          }
          createMany: {
            args: Prisma.usersRolesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.usersRolesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersRolesPayload>
          }
          update: {
            args: Prisma.usersRolesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersRolesPayload>
          }
          deleteMany: {
            args: Prisma.usersRolesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.usersRolesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.usersRolesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersRolesPayload>
          }
          aggregate: {
            args: Prisma.UsersRolesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsersRoles>
          }
          groupBy: {
            args: Prisma.usersRolesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersRolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersRolesCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersRolesCountAggregateOutputType> | number
          }
        }
      }
      usersActivities: {
        payload: Prisma.$usersActivitiesPayload<ExtArgs>
        fields: Prisma.usersActivitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersActivitiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersActivitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersActivitiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersActivitiesPayload>
          }
          findFirst: {
            args: Prisma.usersActivitiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersActivitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersActivitiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersActivitiesPayload>
          }
          findMany: {
            args: Prisma.usersActivitiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersActivitiesPayload>[]
          }
          create: {
            args: Prisma.usersActivitiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersActivitiesPayload>
          }
          createMany: {
            args: Prisma.usersActivitiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.usersActivitiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersActivitiesPayload>
          }
          update: {
            args: Prisma.usersActivitiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersActivitiesPayload>
          }
          deleteMany: {
            args: Prisma.usersActivitiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.usersActivitiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.usersActivitiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersActivitiesPayload>
          }
          aggregate: {
            args: Prisma.UsersActivitiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsersActivities>
          }
          groupBy: {
            args: Prisma.usersActivitiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersActivitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersActivitiesCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersActivitiesCountAggregateOutputType> | number
          }
        }
      }
      orderType: {
        payload: Prisma.$orderTypePayload<ExtArgs>
        fields: Prisma.orderTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.orderTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.orderTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTypePayload>
          }
          findFirst: {
            args: Prisma.orderTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.orderTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTypePayload>
          }
          findMany: {
            args: Prisma.orderTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTypePayload>[]
          }
          create: {
            args: Prisma.orderTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTypePayload>
          }
          createMany: {
            args: Prisma.orderTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.orderTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTypePayload>
          }
          update: {
            args: Prisma.orderTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTypePayload>
          }
          deleteMany: {
            args: Prisma.orderTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.orderTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.orderTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTypePayload>
          }
          aggregate: {
            args: Prisma.OrderTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrderType>
          }
          groupBy: {
            args: Prisma.orderTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.orderTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderTypeCountAggregateOutputType> | number
          }
        }
      }
      orderCategory: {
        payload: Prisma.$orderCategoryPayload<ExtArgs>
        fields: Prisma.orderCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.orderCategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.orderCategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderCategoryPayload>
          }
          findFirst: {
            args: Prisma.orderCategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.orderCategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderCategoryPayload>
          }
          findMany: {
            args: Prisma.orderCategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderCategoryPayload>[]
          }
          create: {
            args: Prisma.orderCategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderCategoryPayload>
          }
          createMany: {
            args: Prisma.orderCategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.orderCategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderCategoryPayload>
          }
          update: {
            args: Prisma.orderCategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderCategoryPayload>
          }
          deleteMany: {
            args: Prisma.orderCategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.orderCategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.orderCategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderCategoryPayload>
          }
          aggregate: {
            args: Prisma.OrderCategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrderCategory>
          }
          groupBy: {
            args: Prisma.orderCategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.orderCategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderCategoryCountAggregateOutputType> | number
          }
        }
      }
      order: {
        payload: Prisma.$orderPayload<ExtArgs>
        fields: Prisma.orderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.orderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.orderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          findFirst: {
            args: Prisma.orderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.orderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          findMany: {
            args: Prisma.orderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>[]
          }
          create: {
            args: Prisma.orderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          createMany: {
            args: Prisma.orderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.orderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          update: {
            args: Prisma.orderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          deleteMany: {
            args: Prisma.orderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.orderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.orderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.orderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.orderCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      orderThreading: {
        payload: Prisma.$orderThreadingPayload<ExtArgs>
        fields: Prisma.orderThreadingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.orderThreadingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderThreadingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.orderThreadingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderThreadingPayload>
          }
          findFirst: {
            args: Prisma.orderThreadingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderThreadingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.orderThreadingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderThreadingPayload>
          }
          findMany: {
            args: Prisma.orderThreadingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderThreadingPayload>[]
          }
          create: {
            args: Prisma.orderThreadingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderThreadingPayload>
          }
          createMany: {
            args: Prisma.orderThreadingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.orderThreadingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderThreadingPayload>
          }
          update: {
            args: Prisma.orderThreadingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderThreadingPayload>
          }
          deleteMany: {
            args: Prisma.orderThreadingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.orderThreadingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.orderThreadingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderThreadingPayload>
          }
          aggregate: {
            args: Prisma.OrderThreadingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrderThreading>
          }
          groupBy: {
            args: Prisma.orderThreadingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderThreadingGroupByOutputType>[]
          }
          count: {
            args: Prisma.orderThreadingCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderThreadingCountAggregateOutputType> | number
          }
        }
      }
      orderPersonal: {
        payload: Prisma.$orderPersonalPayload<ExtArgs>
        fields: Prisma.orderPersonalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.orderPersonalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPersonalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.orderPersonalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPersonalPayload>
          }
          findFirst: {
            args: Prisma.orderPersonalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPersonalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.orderPersonalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPersonalPayload>
          }
          findMany: {
            args: Prisma.orderPersonalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPersonalPayload>[]
          }
          create: {
            args: Prisma.orderPersonalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPersonalPayload>
          }
          createMany: {
            args: Prisma.orderPersonalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.orderPersonalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPersonalPayload>
          }
          update: {
            args: Prisma.orderPersonalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPersonalPayload>
          }
          deleteMany: {
            args: Prisma.orderPersonalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.orderPersonalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.orderPersonalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPersonalPayload>
          }
          aggregate: {
            args: Prisma.OrderPersonalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrderPersonal>
          }
          groupBy: {
            args: Prisma.orderPersonalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderPersonalGroupByOutputType>[]
          }
          count: {
            args: Prisma.orderPersonalCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderPersonalCountAggregateOutputType> | number
          }
        }
      }
      orderPayment: {
        payload: Prisma.$orderPaymentPayload<ExtArgs>
        fields: Prisma.orderPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.orderPaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.orderPaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPaymentPayload>
          }
          findFirst: {
            args: Prisma.orderPaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.orderPaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPaymentPayload>
          }
          findMany: {
            args: Prisma.orderPaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPaymentPayload>[]
          }
          create: {
            args: Prisma.orderPaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPaymentPayload>
          }
          createMany: {
            args: Prisma.orderPaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.orderPaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPaymentPayload>
          }
          update: {
            args: Prisma.orderPaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPaymentPayload>
          }
          deleteMany: {
            args: Prisma.orderPaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.orderPaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.orderPaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPaymentPayload>
          }
          aggregate: {
            args: Prisma.OrderPaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrderPayment>
          }
          groupBy: {
            args: Prisma.orderPaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.orderPaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderPaymentCountAggregateOutputType> | number
          }
        }
      }
      orderDetails: {
        payload: Prisma.$orderDetailsPayload<ExtArgs>
        fields: Prisma.orderDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.orderDetailsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.orderDetailsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderDetailsPayload>
          }
          findFirst: {
            args: Prisma.orderDetailsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.orderDetailsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderDetailsPayload>
          }
          findMany: {
            args: Prisma.orderDetailsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderDetailsPayload>[]
          }
          create: {
            args: Prisma.orderDetailsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderDetailsPayload>
          }
          createMany: {
            args: Prisma.orderDetailsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.orderDetailsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderDetailsPayload>
          }
          update: {
            args: Prisma.orderDetailsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderDetailsPayload>
          }
          deleteMany: {
            args: Prisma.orderDetailsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.orderDetailsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.orderDetailsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderDetailsPayload>
          }
          aggregate: {
            args: Prisma.OrderDetailsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrderDetails>
          }
          groupBy: {
            args: Prisma.orderDetailsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.orderDetailsCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderDetailsCountAggregateOutputType> | number
          }
        }
      }
      tackingStatus: {
        payload: Prisma.$tackingStatusPayload<ExtArgs>
        fields: Prisma.tackingStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tackingStatusFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tackingStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tackingStatusFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tackingStatusPayload>
          }
          findFirst: {
            args: Prisma.tackingStatusFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tackingStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tackingStatusFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tackingStatusPayload>
          }
          findMany: {
            args: Prisma.tackingStatusFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tackingStatusPayload>[]
          }
          create: {
            args: Prisma.tackingStatusCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tackingStatusPayload>
          }
          createMany: {
            args: Prisma.tackingStatusCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tackingStatusDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tackingStatusPayload>
          }
          update: {
            args: Prisma.tackingStatusUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tackingStatusPayload>
          }
          deleteMany: {
            args: Prisma.tackingStatusDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tackingStatusUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tackingStatusUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tackingStatusPayload>
          }
          aggregate: {
            args: Prisma.TackingStatusAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTackingStatus>
          }
          groupBy: {
            args: Prisma.tackingStatusGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TackingStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.tackingStatusCountArgs<ExtArgs>,
            result: $Utils.Optional<TackingStatusCountAggregateOutputType> | number
          }
        }
      }
      orderTacking: {
        payload: Prisma.$orderTackingPayload<ExtArgs>
        fields: Prisma.orderTackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.orderTackingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.orderTackingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTackingPayload>
          }
          findFirst: {
            args: Prisma.orderTackingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.orderTackingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTackingPayload>
          }
          findMany: {
            args: Prisma.orderTackingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTackingPayload>[]
          }
          create: {
            args: Prisma.orderTackingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTackingPayload>
          }
          createMany: {
            args: Prisma.orderTackingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.orderTackingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTackingPayload>
          }
          update: {
            args: Prisma.orderTackingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTackingPayload>
          }
          deleteMany: {
            args: Prisma.orderTackingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.orderTackingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.orderTackingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderTackingPayload>
          }
          aggregate: {
            args: Prisma.OrderTackingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrderTacking>
          }
          groupBy: {
            args: Prisma.orderTackingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderTackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.orderTackingCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderTackingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProvinceCountOutputType
   */

  export type ProvinceCountOutputType = {
    District: number
    Village: number
    Address: number
  }

  export type ProvinceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    District?: boolean | ProvinceCountOutputTypeCountDistrictArgs
    Village?: boolean | ProvinceCountOutputTypeCountVillageArgs
    Address?: boolean | ProvinceCountOutputTypeCountAddressArgs
  }

  // Custom InputTypes
  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvinceCountOutputType
     */
    select?: ProvinceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountDistrictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: districtWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountVillageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: villageWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: addressWhereInput
  }


  /**
   * Count Type DistrictCountOutputType
   */

  export type DistrictCountOutputType = {
    Address: number
    Village: number
  }

  export type DistrictCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Address?: boolean | DistrictCountOutputTypeCountAddressArgs
    Village?: boolean | DistrictCountOutputTypeCountVillageArgs
  }

  // Custom InputTypes
  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistrictCountOutputType
     */
    select?: DistrictCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeCountAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: addressWhereInput
  }

  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeCountVillageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: villageWhereInput
  }


  /**
   * Count Type BranchesCountOutputType
   */

  export type BranchesCountOutputType = {
    BranchesKey: number
    BranchesSettings: number
    Otp: number
    Notifications: number
    OrderCategory: number
    Order: number
    Tracking: number
  }

  export type BranchesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BranchesKey?: boolean | BranchesCountOutputTypeCountBranchesKeyArgs
    BranchesSettings?: boolean | BranchesCountOutputTypeCountBranchesSettingsArgs
    Otp?: boolean | BranchesCountOutputTypeCountOtpArgs
    Notifications?: boolean | BranchesCountOutputTypeCountNotificationsArgs
    OrderCategory?: boolean | BranchesCountOutputTypeCountOrderCategoryArgs
    Order?: boolean | BranchesCountOutputTypeCountOrderArgs
    Tracking?: boolean | BranchesCountOutputTypeCountTrackingArgs
  }

  // Custom InputTypes
  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchesCountOutputType
     */
    select?: BranchesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountBranchesKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: branchesKeyWhereInput
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountBranchesSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: branchesSettingsWhereInput
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountOtpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: otpWhereInput
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountOrderCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderCategoryWhereInput
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderTackingWhereInput
  }


  /**
   * Count Type WalletCountOutputType
   */

  export type WalletCountOutputType = {
    Receive: number
    Payment: number
  }

  export type WalletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Receive?: boolean | WalletCountOutputTypeCountReceiveArgs
    Payment?: boolean | WalletCountOutputTypeCountPaymentArgs
  }

  // Custom InputTypes
  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletCountOutputType
     */
    select?: WalletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeCountReceiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionWhereInput
  }

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    Wallet: number
    RecipientPayment: number
    AdminProfile: number
    OTP: number
    Roles: number
    Forgot: number
    Notifications: number
    Activities: number
    Order: number
    SenderOrder: number
    RecipientOrder: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Wallet?: boolean | UsersCountOutputTypeCountWalletArgs
    RecipientPayment?: boolean | UsersCountOutputTypeCountRecipientPaymentArgs
    AdminProfile?: boolean | UsersCountOutputTypeCountAdminProfileArgs
    OTP?: boolean | UsersCountOutputTypeCountOTPArgs
    Roles?: boolean | UsersCountOutputTypeCountRolesArgs
    Forgot?: boolean | UsersCountOutputTypeCountForgotArgs
    Notifications?: boolean | UsersCountOutputTypeCountNotificationsArgs
    Activities?: boolean | UsersCountOutputTypeCountActivitiesArgs
    Order?: boolean | UsersCountOutputTypeCountOrderArgs
    SenderOrder?: boolean | UsersCountOutputTypeCountSenderOrderArgs
    RecipientOrder?: boolean | UsersCountOutputTypeCountRecipientOrderArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountWalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: walletWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRecipientPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderPaymentWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAdminProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profileWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountOTPArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: otpWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersRolesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountForgotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: forgotPasswordWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersActivitiesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSenderOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderPersonalWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRecipientOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderPersonalWhereInput
  }


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    Address: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Address?: boolean | ProfileCountOutputTypeCountAddressArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: addressWhereInput
  }


  /**
   * Count Type OrderCategoryCountOutputType
   */

  export type OrderCategoryCountOutputType = {
    Order: number
  }

  export type OrderCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Order?: boolean | OrderCategoryCountOutputTypeCountOrderArgs
  }

  // Custom InputTypes
  /**
   * OrderCategoryCountOutputType without action
   */
  export type OrderCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCategoryCountOutputType
     */
    select?: OrderCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCategoryCountOutputType without action
   */
  export type OrderCategoryCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    Tacking: number
    Threading: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tacking?: boolean | OrderCountOutputTypeCountTackingArgs
    Threading?: boolean | OrderCountOutputTypeCountThreadingArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountTackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderTackingWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountThreadingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderThreadingWhereInput
  }


  /**
   * Count Type TackingStatusCountOutputType
   */

  export type TackingStatusCountOutputType = {
    Tracking: number
  }

  export type TackingStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tracking?: boolean | TackingStatusCountOutputTypeCountTrackingArgs
  }

  // Custom InputTypes
  /**
   * TackingStatusCountOutputType without action
   */
  export type TackingStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TackingStatusCountOutputType
     */
    select?: TackingStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TackingStatusCountOutputType without action
   */
  export type TackingStatusCountOutputTypeCountTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderTackingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model province
   */

  export type AggregateProvince = {
    _count: ProvinceCountAggregateOutputType | null
    _min: ProvinceMinAggregateOutputType | null
    _max: ProvinceMaxAggregateOutputType | null
  }

  export type ProvinceMinAggregateOutputType = {
    ID: string | null
    Name: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type ProvinceMaxAggregateOutputType = {
    ID: string | null
    Name: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type ProvinceCountAggregateOutputType = {
    ID: number
    Name: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type ProvinceMinAggregateInputType = {
    ID?: true
    Name?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type ProvinceMaxAggregateInputType = {
    ID?: true
    Name?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type ProvinceCountAggregateInputType = {
    ID?: true
    Name?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type ProvinceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which province to aggregate.
     */
    where?: provinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provinces to fetch.
     */
    orderBy?: provinceOrderByWithRelationInput | provinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: provinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned provinces
    **/
    _count?: true | ProvinceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvinceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvinceMaxAggregateInputType
  }

  export type GetProvinceAggregateType<T extends ProvinceAggregateArgs> = {
        [P in keyof T & keyof AggregateProvince]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvince[P]>
      : GetScalarType<T[P], AggregateProvince[P]>
  }




  export type provinceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provinceWhereInput
    orderBy?: provinceOrderByWithAggregationInput | provinceOrderByWithAggregationInput[]
    by: ProvinceScalarFieldEnum[] | ProvinceScalarFieldEnum
    having?: provinceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvinceCountAggregateInputType | true
    _min?: ProvinceMinAggregateInputType
    _max?: ProvinceMaxAggregateInputType
  }

  export type ProvinceGroupByOutputType = {
    ID: string
    Name: string
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date
    _count: ProvinceCountAggregateOutputType | null
    _min: ProvinceMinAggregateOutputType | null
    _max: ProvinceMaxAggregateOutputType | null
  }

  type GetProvinceGroupByPayload<T extends provinceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvinceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvinceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvinceGroupByOutputType[P]>
            : GetScalarType<T[P], ProvinceGroupByOutputType[P]>
        }
      >
    >


  export type provinceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Name?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    District?: boolean | province$DistrictArgs<ExtArgs>
    Village?: boolean | province$VillageArgs<ExtArgs>
    Address?: boolean | province$AddressArgs<ExtArgs>
    _count?: boolean | ProvinceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["province"]>

  export type provinceSelectScalar = {
    ID?: boolean
    Name?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type provinceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    District?: boolean | province$DistrictArgs<ExtArgs>
    Village?: boolean | province$VillageArgs<ExtArgs>
    Address?: boolean | province$AddressArgs<ExtArgs>
    _count?: boolean | ProvinceCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $provincePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "province"
    objects: {
      District: Prisma.$districtPayload<ExtArgs>[]
      Village: Prisma.$villagePayload<ExtArgs>[]
      Address: Prisma.$addressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Name: string
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date
    }, ExtArgs["result"]["province"]>
    composites: {}
  }


  type provinceGetPayload<S extends boolean | null | undefined | provinceDefaultArgs> = $Result.GetResult<Prisma.$provincePayload, S>

  type provinceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<provinceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProvinceCountAggregateInputType | true
    }

  export interface provinceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['province'], meta: { name: 'province' } }
    /**
     * Find zero or one Province that matches the filter.
     * @param {provinceFindUniqueArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends provinceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, provinceFindUniqueArgs<ExtArgs>>
    ): Prisma__provinceClient<$Result.GetResult<Prisma.$provincePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Province that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {provinceFindUniqueOrThrowArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends provinceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, provinceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__provinceClient<$Result.GetResult<Prisma.$provincePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Province that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provinceFindFirstArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends provinceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, provinceFindFirstArgs<ExtArgs>>
    ): Prisma__provinceClient<$Result.GetResult<Prisma.$provincePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Province that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provinceFindFirstOrThrowArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends provinceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, provinceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__provinceClient<$Result.GetResult<Prisma.$provincePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Provinces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provinceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provinces
     * const provinces = await prisma.province.findMany()
     * 
     * // Get first 10 Provinces
     * const provinces = await prisma.province.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const provinceWithIDOnly = await prisma.province.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends provinceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, provinceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provincePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Province.
     * @param {provinceCreateArgs} args - Arguments to create a Province.
     * @example
     * // Create one Province
     * const Province = await prisma.province.create({
     *   data: {
     *     // ... data to create a Province
     *   }
     * })
     * 
    **/
    create<T extends provinceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, provinceCreateArgs<ExtArgs>>
    ): Prisma__provinceClient<$Result.GetResult<Prisma.$provincePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Provinces.
     * @param {provinceCreateManyArgs} args - Arguments to create many Provinces.
     * @example
     * // Create many Provinces
     * const province = await prisma.province.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends provinceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, provinceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Province.
     * @param {provinceDeleteArgs} args - Arguments to delete one Province.
     * @example
     * // Delete one Province
     * const Province = await prisma.province.delete({
     *   where: {
     *     // ... filter to delete one Province
     *   }
     * })
     * 
    **/
    delete<T extends provinceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, provinceDeleteArgs<ExtArgs>>
    ): Prisma__provinceClient<$Result.GetResult<Prisma.$provincePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Province.
     * @param {provinceUpdateArgs} args - Arguments to update one Province.
     * @example
     * // Update one Province
     * const province = await prisma.province.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends provinceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, provinceUpdateArgs<ExtArgs>>
    ): Prisma__provinceClient<$Result.GetResult<Prisma.$provincePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Provinces.
     * @param {provinceDeleteManyArgs} args - Arguments to filter Provinces to delete.
     * @example
     * // Delete a few Provinces
     * const { count } = await prisma.province.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends provinceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, provinceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provinces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provinceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provinces
     * const province = await prisma.province.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends provinceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, provinceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Province.
     * @param {provinceUpsertArgs} args - Arguments to update or create a Province.
     * @example
     * // Update or create a Province
     * const province = await prisma.province.upsert({
     *   create: {
     *     // ... data to create a Province
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Province we want to update
     *   }
     * })
    **/
    upsert<T extends provinceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, provinceUpsertArgs<ExtArgs>>
    ): Prisma__provinceClient<$Result.GetResult<Prisma.$provincePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Provinces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provinceCountArgs} args - Arguments to filter Provinces to count.
     * @example
     * // Count the number of Provinces
     * const count = await prisma.province.count({
     *   where: {
     *     // ... the filter for the Provinces we want to count
     *   }
     * })
    **/
    count<T extends provinceCountArgs>(
      args?: Subset<T, provinceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvinceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Province.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvinceAggregateArgs>(args: Subset<T, ProvinceAggregateArgs>): Prisma.PrismaPromise<GetProvinceAggregateType<T>>

    /**
     * Group by Province.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provinceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends provinceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: provinceGroupByArgs['orderBy'] }
        : { orderBy?: provinceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, provinceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvinceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the province model
   */
  readonly fields: provinceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for province.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__provinceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    District<T extends province$DistrictArgs<ExtArgs> = {}>(args?: Subset<T, province$DistrictArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$districtPayload<ExtArgs>, T, 'findMany'> | Null>;

    Village<T extends province$VillageArgs<ExtArgs> = {}>(args?: Subset<T, province$VillageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$villagePayload<ExtArgs>, T, 'findMany'> | Null>;

    Address<T extends province$AddressArgs<ExtArgs> = {}>(args?: Subset<T, province$AddressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the province model
   */ 
  interface provinceFieldRefs {
    readonly ID: FieldRef<"province", 'String'>
    readonly Name: FieldRef<"province", 'String'>
    readonly Status: FieldRef<"province", 'String'>
    readonly IsActive: FieldRef<"province", 'Boolean'>
    readonly CreatedAt: FieldRef<"province", 'DateTime'>
    readonly UpdatedAt: FieldRef<"province", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * province findUnique
   */
  export type provinceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the province
     */
    select?: provinceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinceInclude<ExtArgs> | null
    /**
     * Filter, which province to fetch.
     */
    where: provinceWhereUniqueInput
  }

  /**
   * province findUniqueOrThrow
   */
  export type provinceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the province
     */
    select?: provinceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinceInclude<ExtArgs> | null
    /**
     * Filter, which province to fetch.
     */
    where: provinceWhereUniqueInput
  }

  /**
   * province findFirst
   */
  export type provinceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the province
     */
    select?: provinceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinceInclude<ExtArgs> | null
    /**
     * Filter, which province to fetch.
     */
    where?: provinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provinces to fetch.
     */
    orderBy?: provinceOrderByWithRelationInput | provinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provinces.
     */
    cursor?: provinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provinces.
     */
    distinct?: ProvinceScalarFieldEnum | ProvinceScalarFieldEnum[]
  }

  /**
   * province findFirstOrThrow
   */
  export type provinceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the province
     */
    select?: provinceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinceInclude<ExtArgs> | null
    /**
     * Filter, which province to fetch.
     */
    where?: provinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provinces to fetch.
     */
    orderBy?: provinceOrderByWithRelationInput | provinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provinces.
     */
    cursor?: provinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provinces.
     */
    distinct?: ProvinceScalarFieldEnum | ProvinceScalarFieldEnum[]
  }

  /**
   * province findMany
   */
  export type provinceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the province
     */
    select?: provinceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinceInclude<ExtArgs> | null
    /**
     * Filter, which provinces to fetch.
     */
    where?: provinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provinces to fetch.
     */
    orderBy?: provinceOrderByWithRelationInput | provinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing provinces.
     */
    cursor?: provinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provinces.
     */
    skip?: number
    distinct?: ProvinceScalarFieldEnum | ProvinceScalarFieldEnum[]
  }

  /**
   * province create
   */
  export type provinceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the province
     */
    select?: provinceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinceInclude<ExtArgs> | null
    /**
     * The data needed to create a province.
     */
    data: XOR<provinceCreateInput, provinceUncheckedCreateInput>
  }

  /**
   * province createMany
   */
  export type provinceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many provinces.
     */
    data: provinceCreateManyInput | provinceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * province update
   */
  export type provinceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the province
     */
    select?: provinceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinceInclude<ExtArgs> | null
    /**
     * The data needed to update a province.
     */
    data: XOR<provinceUpdateInput, provinceUncheckedUpdateInput>
    /**
     * Choose, which province to update.
     */
    where: provinceWhereUniqueInput
  }

  /**
   * province updateMany
   */
  export type provinceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update provinces.
     */
    data: XOR<provinceUpdateManyMutationInput, provinceUncheckedUpdateManyInput>
    /**
     * Filter which provinces to update
     */
    where?: provinceWhereInput
  }

  /**
   * province upsert
   */
  export type provinceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the province
     */
    select?: provinceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinceInclude<ExtArgs> | null
    /**
     * The filter to search for the province to update in case it exists.
     */
    where: provinceWhereUniqueInput
    /**
     * In case the province found by the `where` argument doesn't exist, create a new province with this data.
     */
    create: XOR<provinceCreateInput, provinceUncheckedCreateInput>
    /**
     * In case the province was found with the provided `where` argument, update it with this data.
     */
    update: XOR<provinceUpdateInput, provinceUncheckedUpdateInput>
  }

  /**
   * province delete
   */
  export type provinceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the province
     */
    select?: provinceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinceInclude<ExtArgs> | null
    /**
     * Filter which province to delete.
     */
    where: provinceWhereUniqueInput
  }

  /**
   * province deleteMany
   */
  export type provinceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which provinces to delete
     */
    where?: provinceWhereInput
  }

  /**
   * province.District
   */
  export type province$DistrictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the district
     */
    select?: districtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtInclude<ExtArgs> | null
    where?: districtWhereInput
    orderBy?: districtOrderByWithRelationInput | districtOrderByWithRelationInput[]
    cursor?: districtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * province.Village
   */
  export type province$VillageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the village
     */
    select?: villageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: villageInclude<ExtArgs> | null
    where?: villageWhereInput
    orderBy?: villageOrderByWithRelationInput | villageOrderByWithRelationInput[]
    cursor?: villageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VillageScalarFieldEnum | VillageScalarFieldEnum[]
  }

  /**
   * province.Address
   */
  export type province$AddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: addressInclude<ExtArgs> | null
    where?: addressWhereInput
    orderBy?: addressOrderByWithRelationInput | addressOrderByWithRelationInput[]
    cursor?: addressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * province without action
   */
  export type provinceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the province
     */
    select?: provinceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinceInclude<ExtArgs> | null
  }


  /**
   * Model district
   */

  export type AggregateDistrict = {
    _count: DistrictCountAggregateOutputType | null
    _min: DistrictMinAggregateOutputType | null
    _max: DistrictMaxAggregateOutputType | null
  }

  export type DistrictMinAggregateOutputType = {
    ID: string | null
    Name: string | null
    ProvinceID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type DistrictMaxAggregateOutputType = {
    ID: string | null
    Name: string | null
    ProvinceID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type DistrictCountAggregateOutputType = {
    ID: number
    Name: number
    ProvinceID: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type DistrictMinAggregateInputType = {
    ID?: true
    Name?: true
    ProvinceID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type DistrictMaxAggregateInputType = {
    ID?: true
    Name?: true
    ProvinceID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type DistrictCountAggregateInputType = {
    ID?: true
    Name?: true
    ProvinceID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type DistrictAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which district to aggregate.
     */
    where?: districtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of districts to fetch.
     */
    orderBy?: districtOrderByWithRelationInput | districtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: districtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned districts
    **/
    _count?: true | DistrictCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistrictMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistrictMaxAggregateInputType
  }

  export type GetDistrictAggregateType<T extends DistrictAggregateArgs> = {
        [P in keyof T & keyof AggregateDistrict]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistrict[P]>
      : GetScalarType<T[P], AggregateDistrict[P]>
  }




  export type districtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: districtWhereInput
    orderBy?: districtOrderByWithAggregationInput | districtOrderByWithAggregationInput[]
    by: DistrictScalarFieldEnum[] | DistrictScalarFieldEnum
    having?: districtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistrictCountAggregateInputType | true
    _min?: DistrictMinAggregateInputType
    _max?: DistrictMaxAggregateInputType
  }

  export type DistrictGroupByOutputType = {
    ID: string
    Name: string
    ProvinceID: string | null
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: DistrictCountAggregateOutputType | null
    _min: DistrictMinAggregateOutputType | null
    _max: DistrictMaxAggregateOutputType | null
  }

  type GetDistrictGroupByPayload<T extends districtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistrictGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistrictGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistrictGroupByOutputType[P]>
            : GetScalarType<T[P], DistrictGroupByOutputType[P]>
        }
      >
    >


  export type districtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Name?: boolean
    ProvinceID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Province?: boolean | district$ProvinceArgs<ExtArgs>
    Address?: boolean | district$AddressArgs<ExtArgs>
    Village?: boolean | district$VillageArgs<ExtArgs>
    _count?: boolean | DistrictCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["district"]>

  export type districtSelectScalar = {
    ID?: boolean
    Name?: boolean
    ProvinceID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type districtInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Province?: boolean | district$ProvinceArgs<ExtArgs>
    Address?: boolean | district$AddressArgs<ExtArgs>
    Village?: boolean | district$VillageArgs<ExtArgs>
    _count?: boolean | DistrictCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $districtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "district"
    objects: {
      Province: Prisma.$provincePayload<ExtArgs> | null
      Address: Prisma.$addressPayload<ExtArgs>[]
      Village: Prisma.$villagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Name: string
      ProvinceID: string | null
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["district"]>
    composites: {}
  }


  type districtGetPayload<S extends boolean | null | undefined | districtDefaultArgs> = $Result.GetResult<Prisma.$districtPayload, S>

  type districtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<districtFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DistrictCountAggregateInputType | true
    }

  export interface districtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['district'], meta: { name: 'district' } }
    /**
     * Find zero or one District that matches the filter.
     * @param {districtFindUniqueArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends districtFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, districtFindUniqueArgs<ExtArgs>>
    ): Prisma__districtClient<$Result.GetResult<Prisma.$districtPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one District that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {districtFindUniqueOrThrowArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends districtFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, districtFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__districtClient<$Result.GetResult<Prisma.$districtPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first District that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtFindFirstArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends districtFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, districtFindFirstArgs<ExtArgs>>
    ): Prisma__districtClient<$Result.GetResult<Prisma.$districtPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first District that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtFindFirstOrThrowArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends districtFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, districtFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__districtClient<$Result.GetResult<Prisma.$districtPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Districts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Districts
     * const districts = await prisma.district.findMany()
     * 
     * // Get first 10 Districts
     * const districts = await prisma.district.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const districtWithIDOnly = await prisma.district.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends districtFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, districtFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$districtPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a District.
     * @param {districtCreateArgs} args - Arguments to create a District.
     * @example
     * // Create one District
     * const District = await prisma.district.create({
     *   data: {
     *     // ... data to create a District
     *   }
     * })
     * 
    **/
    create<T extends districtCreateArgs<ExtArgs>>(
      args: SelectSubset<T, districtCreateArgs<ExtArgs>>
    ): Prisma__districtClient<$Result.GetResult<Prisma.$districtPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Districts.
     * @param {districtCreateManyArgs} args - Arguments to create many Districts.
     * @example
     * // Create many Districts
     * const district = await prisma.district.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends districtCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, districtCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a District.
     * @param {districtDeleteArgs} args - Arguments to delete one District.
     * @example
     * // Delete one District
     * const District = await prisma.district.delete({
     *   where: {
     *     // ... filter to delete one District
     *   }
     * })
     * 
    **/
    delete<T extends districtDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, districtDeleteArgs<ExtArgs>>
    ): Prisma__districtClient<$Result.GetResult<Prisma.$districtPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one District.
     * @param {districtUpdateArgs} args - Arguments to update one District.
     * @example
     * // Update one District
     * const district = await prisma.district.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends districtUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, districtUpdateArgs<ExtArgs>>
    ): Prisma__districtClient<$Result.GetResult<Prisma.$districtPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Districts.
     * @param {districtDeleteManyArgs} args - Arguments to filter Districts to delete.
     * @example
     * // Delete a few Districts
     * const { count } = await prisma.district.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends districtDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, districtDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Districts
     * const district = await prisma.district.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends districtUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, districtUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one District.
     * @param {districtUpsertArgs} args - Arguments to update or create a District.
     * @example
     * // Update or create a District
     * const district = await prisma.district.upsert({
     *   create: {
     *     // ... data to create a District
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the District we want to update
     *   }
     * })
    **/
    upsert<T extends districtUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, districtUpsertArgs<ExtArgs>>
    ): Prisma__districtClient<$Result.GetResult<Prisma.$districtPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtCountArgs} args - Arguments to filter Districts to count.
     * @example
     * // Count the number of Districts
     * const count = await prisma.district.count({
     *   where: {
     *     // ... the filter for the Districts we want to count
     *   }
     * })
    **/
    count<T extends districtCountArgs>(
      args?: Subset<T, districtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistrictCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a District.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistrictAggregateArgs>(args: Subset<T, DistrictAggregateArgs>): Prisma.PrismaPromise<GetDistrictAggregateType<T>>

    /**
     * Group by District.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends districtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: districtGroupByArgs['orderBy'] }
        : { orderBy?: districtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, districtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistrictGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the district model
   */
  readonly fields: districtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for district.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__districtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Province<T extends district$ProvinceArgs<ExtArgs> = {}>(args?: Subset<T, district$ProvinceArgs<ExtArgs>>): Prisma__provinceClient<$Result.GetResult<Prisma.$provincePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Address<T extends district$AddressArgs<ExtArgs> = {}>(args?: Subset<T, district$AddressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findMany'> | Null>;

    Village<T extends district$VillageArgs<ExtArgs> = {}>(args?: Subset<T, district$VillageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$villagePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the district model
   */ 
  interface districtFieldRefs {
    readonly ID: FieldRef<"district", 'String'>
    readonly Name: FieldRef<"district", 'String'>
    readonly ProvinceID: FieldRef<"district", 'String'>
    readonly Status: FieldRef<"district", 'String'>
    readonly IsActive: FieldRef<"district", 'Boolean'>
    readonly CreatedAt: FieldRef<"district", 'DateTime'>
    readonly UpdatedAt: FieldRef<"district", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * district findUnique
   */
  export type districtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the district
     */
    select?: districtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtInclude<ExtArgs> | null
    /**
     * Filter, which district to fetch.
     */
    where: districtWhereUniqueInput
  }

  /**
   * district findUniqueOrThrow
   */
  export type districtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the district
     */
    select?: districtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtInclude<ExtArgs> | null
    /**
     * Filter, which district to fetch.
     */
    where: districtWhereUniqueInput
  }

  /**
   * district findFirst
   */
  export type districtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the district
     */
    select?: districtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtInclude<ExtArgs> | null
    /**
     * Filter, which district to fetch.
     */
    where?: districtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of districts to fetch.
     */
    orderBy?: districtOrderByWithRelationInput | districtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for districts.
     */
    cursor?: districtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of districts.
     */
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * district findFirstOrThrow
   */
  export type districtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the district
     */
    select?: districtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtInclude<ExtArgs> | null
    /**
     * Filter, which district to fetch.
     */
    where?: districtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of districts to fetch.
     */
    orderBy?: districtOrderByWithRelationInput | districtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for districts.
     */
    cursor?: districtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of districts.
     */
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * district findMany
   */
  export type districtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the district
     */
    select?: districtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtInclude<ExtArgs> | null
    /**
     * Filter, which districts to fetch.
     */
    where?: districtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of districts to fetch.
     */
    orderBy?: districtOrderByWithRelationInput | districtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing districts.
     */
    cursor?: districtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` districts.
     */
    skip?: number
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * district create
   */
  export type districtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the district
     */
    select?: districtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtInclude<ExtArgs> | null
    /**
     * The data needed to create a district.
     */
    data: XOR<districtCreateInput, districtUncheckedCreateInput>
  }

  /**
   * district createMany
   */
  export type districtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many districts.
     */
    data: districtCreateManyInput | districtCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * district update
   */
  export type districtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the district
     */
    select?: districtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtInclude<ExtArgs> | null
    /**
     * The data needed to update a district.
     */
    data: XOR<districtUpdateInput, districtUncheckedUpdateInput>
    /**
     * Choose, which district to update.
     */
    where: districtWhereUniqueInput
  }

  /**
   * district updateMany
   */
  export type districtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update districts.
     */
    data: XOR<districtUpdateManyMutationInput, districtUncheckedUpdateManyInput>
    /**
     * Filter which districts to update
     */
    where?: districtWhereInput
  }

  /**
   * district upsert
   */
  export type districtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the district
     */
    select?: districtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtInclude<ExtArgs> | null
    /**
     * The filter to search for the district to update in case it exists.
     */
    where: districtWhereUniqueInput
    /**
     * In case the district found by the `where` argument doesn't exist, create a new district with this data.
     */
    create: XOR<districtCreateInput, districtUncheckedCreateInput>
    /**
     * In case the district was found with the provided `where` argument, update it with this data.
     */
    update: XOR<districtUpdateInput, districtUncheckedUpdateInput>
  }

  /**
   * district delete
   */
  export type districtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the district
     */
    select?: districtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtInclude<ExtArgs> | null
    /**
     * Filter which district to delete.
     */
    where: districtWhereUniqueInput
  }

  /**
   * district deleteMany
   */
  export type districtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which districts to delete
     */
    where?: districtWhereInput
  }

  /**
   * district.Province
   */
  export type district$ProvinceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the province
     */
    select?: provinceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinceInclude<ExtArgs> | null
    where?: provinceWhereInput
  }

  /**
   * district.Address
   */
  export type district$AddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: addressInclude<ExtArgs> | null
    where?: addressWhereInput
    orderBy?: addressOrderByWithRelationInput | addressOrderByWithRelationInput[]
    cursor?: addressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * district.Village
   */
  export type district$VillageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the village
     */
    select?: villageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: villageInclude<ExtArgs> | null
    where?: villageWhereInput
    orderBy?: villageOrderByWithRelationInput | villageOrderByWithRelationInput[]
    cursor?: villageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VillageScalarFieldEnum | VillageScalarFieldEnum[]
  }

  /**
   * district without action
   */
  export type districtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the district
     */
    select?: districtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtInclude<ExtArgs> | null
  }


  /**
   * Model village
   */

  export type AggregateVillage = {
    _count: VillageCountAggregateOutputType | null
    _min: VillageMinAggregateOutputType | null
    _max: VillageMaxAggregateOutputType | null
  }

  export type VillageMinAggregateOutputType = {
    ID: string | null
    Name: string | null
    ProvinceID: string | null
    DistrictID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type VillageMaxAggregateOutputType = {
    ID: string | null
    Name: string | null
    ProvinceID: string | null
    DistrictID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type VillageCountAggregateOutputType = {
    ID: number
    Name: number
    ProvinceID: number
    DistrictID: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type VillageMinAggregateInputType = {
    ID?: true
    Name?: true
    ProvinceID?: true
    DistrictID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type VillageMaxAggregateInputType = {
    ID?: true
    Name?: true
    ProvinceID?: true
    DistrictID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type VillageCountAggregateInputType = {
    ID?: true
    Name?: true
    ProvinceID?: true
    DistrictID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type VillageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which village to aggregate.
     */
    where?: villageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of villages to fetch.
     */
    orderBy?: villageOrderByWithRelationInput | villageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: villageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` villages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` villages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned villages
    **/
    _count?: true | VillageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VillageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VillageMaxAggregateInputType
  }

  export type GetVillageAggregateType<T extends VillageAggregateArgs> = {
        [P in keyof T & keyof AggregateVillage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVillage[P]>
      : GetScalarType<T[P], AggregateVillage[P]>
  }




  export type villageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: villageWhereInput
    orderBy?: villageOrderByWithAggregationInput | villageOrderByWithAggregationInput[]
    by: VillageScalarFieldEnum[] | VillageScalarFieldEnum
    having?: villageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VillageCountAggregateInputType | true
    _min?: VillageMinAggregateInputType
    _max?: VillageMaxAggregateInputType
  }

  export type VillageGroupByOutputType = {
    ID: string
    Name: string
    ProvinceID: string | null
    DistrictID: string | null
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: VillageCountAggregateOutputType | null
    _min: VillageMinAggregateOutputType | null
    _max: VillageMaxAggregateOutputType | null
  }

  type GetVillageGroupByPayload<T extends villageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VillageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VillageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VillageGroupByOutputType[P]>
            : GetScalarType<T[P], VillageGroupByOutputType[P]>
        }
      >
    >


  export type villageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Name?: boolean
    ProvinceID?: boolean
    DistrictID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Province?: boolean | village$ProvinceArgs<ExtArgs>
    District?: boolean | village$DistrictArgs<ExtArgs>
  }, ExtArgs["result"]["village"]>

  export type villageSelectScalar = {
    ID?: boolean
    Name?: boolean
    ProvinceID?: boolean
    DistrictID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type villageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Province?: boolean | village$ProvinceArgs<ExtArgs>
    District?: boolean | village$DistrictArgs<ExtArgs>
  }


  export type $villagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "village"
    objects: {
      Province: Prisma.$provincePayload<ExtArgs> | null
      District: Prisma.$districtPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Name: string
      ProvinceID: string | null
      DistrictID: string | null
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["village"]>
    composites: {}
  }


  type villageGetPayload<S extends boolean | null | undefined | villageDefaultArgs> = $Result.GetResult<Prisma.$villagePayload, S>

  type villageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<villageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VillageCountAggregateInputType | true
    }

  export interface villageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['village'], meta: { name: 'village' } }
    /**
     * Find zero or one Village that matches the filter.
     * @param {villageFindUniqueArgs} args - Arguments to find a Village
     * @example
     * // Get one Village
     * const village = await prisma.village.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends villageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, villageFindUniqueArgs<ExtArgs>>
    ): Prisma__villageClient<$Result.GetResult<Prisma.$villagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Village that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {villageFindUniqueOrThrowArgs} args - Arguments to find a Village
     * @example
     * // Get one Village
     * const village = await prisma.village.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends villageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, villageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__villageClient<$Result.GetResult<Prisma.$villagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Village that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {villageFindFirstArgs} args - Arguments to find a Village
     * @example
     * // Get one Village
     * const village = await prisma.village.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends villageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, villageFindFirstArgs<ExtArgs>>
    ): Prisma__villageClient<$Result.GetResult<Prisma.$villagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Village that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {villageFindFirstOrThrowArgs} args - Arguments to find a Village
     * @example
     * // Get one Village
     * const village = await prisma.village.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends villageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, villageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__villageClient<$Result.GetResult<Prisma.$villagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Villages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {villageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Villages
     * const villages = await prisma.village.findMany()
     * 
     * // Get first 10 Villages
     * const villages = await prisma.village.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const villageWithIDOnly = await prisma.village.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends villageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, villageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$villagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Village.
     * @param {villageCreateArgs} args - Arguments to create a Village.
     * @example
     * // Create one Village
     * const Village = await prisma.village.create({
     *   data: {
     *     // ... data to create a Village
     *   }
     * })
     * 
    **/
    create<T extends villageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, villageCreateArgs<ExtArgs>>
    ): Prisma__villageClient<$Result.GetResult<Prisma.$villagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Villages.
     * @param {villageCreateManyArgs} args - Arguments to create many Villages.
     * @example
     * // Create many Villages
     * const village = await prisma.village.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends villageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, villageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Village.
     * @param {villageDeleteArgs} args - Arguments to delete one Village.
     * @example
     * // Delete one Village
     * const Village = await prisma.village.delete({
     *   where: {
     *     // ... filter to delete one Village
     *   }
     * })
     * 
    **/
    delete<T extends villageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, villageDeleteArgs<ExtArgs>>
    ): Prisma__villageClient<$Result.GetResult<Prisma.$villagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Village.
     * @param {villageUpdateArgs} args - Arguments to update one Village.
     * @example
     * // Update one Village
     * const village = await prisma.village.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends villageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, villageUpdateArgs<ExtArgs>>
    ): Prisma__villageClient<$Result.GetResult<Prisma.$villagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Villages.
     * @param {villageDeleteManyArgs} args - Arguments to filter Villages to delete.
     * @example
     * // Delete a few Villages
     * const { count } = await prisma.village.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends villageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, villageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Villages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {villageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Villages
     * const village = await prisma.village.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends villageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, villageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Village.
     * @param {villageUpsertArgs} args - Arguments to update or create a Village.
     * @example
     * // Update or create a Village
     * const village = await prisma.village.upsert({
     *   create: {
     *     // ... data to create a Village
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Village we want to update
     *   }
     * })
    **/
    upsert<T extends villageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, villageUpsertArgs<ExtArgs>>
    ): Prisma__villageClient<$Result.GetResult<Prisma.$villagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Villages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {villageCountArgs} args - Arguments to filter Villages to count.
     * @example
     * // Count the number of Villages
     * const count = await prisma.village.count({
     *   where: {
     *     // ... the filter for the Villages we want to count
     *   }
     * })
    **/
    count<T extends villageCountArgs>(
      args?: Subset<T, villageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VillageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Village.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VillageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VillageAggregateArgs>(args: Subset<T, VillageAggregateArgs>): Prisma.PrismaPromise<GetVillageAggregateType<T>>

    /**
     * Group by Village.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {villageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends villageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: villageGroupByArgs['orderBy'] }
        : { orderBy?: villageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, villageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVillageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the village model
   */
  readonly fields: villageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for village.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__villageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Province<T extends village$ProvinceArgs<ExtArgs> = {}>(args?: Subset<T, village$ProvinceArgs<ExtArgs>>): Prisma__provinceClient<$Result.GetResult<Prisma.$provincePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    District<T extends village$DistrictArgs<ExtArgs> = {}>(args?: Subset<T, village$DistrictArgs<ExtArgs>>): Prisma__districtClient<$Result.GetResult<Prisma.$districtPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the village model
   */ 
  interface villageFieldRefs {
    readonly ID: FieldRef<"village", 'String'>
    readonly Name: FieldRef<"village", 'String'>
    readonly ProvinceID: FieldRef<"village", 'String'>
    readonly DistrictID: FieldRef<"village", 'String'>
    readonly Status: FieldRef<"village", 'String'>
    readonly IsActive: FieldRef<"village", 'Boolean'>
    readonly CreatedAt: FieldRef<"village", 'DateTime'>
    readonly UpdatedAt: FieldRef<"village", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * village findUnique
   */
  export type villageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the village
     */
    select?: villageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: villageInclude<ExtArgs> | null
    /**
     * Filter, which village to fetch.
     */
    where: villageWhereUniqueInput
  }

  /**
   * village findUniqueOrThrow
   */
  export type villageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the village
     */
    select?: villageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: villageInclude<ExtArgs> | null
    /**
     * Filter, which village to fetch.
     */
    where: villageWhereUniqueInput
  }

  /**
   * village findFirst
   */
  export type villageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the village
     */
    select?: villageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: villageInclude<ExtArgs> | null
    /**
     * Filter, which village to fetch.
     */
    where?: villageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of villages to fetch.
     */
    orderBy?: villageOrderByWithRelationInput | villageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for villages.
     */
    cursor?: villageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` villages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` villages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of villages.
     */
    distinct?: VillageScalarFieldEnum | VillageScalarFieldEnum[]
  }

  /**
   * village findFirstOrThrow
   */
  export type villageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the village
     */
    select?: villageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: villageInclude<ExtArgs> | null
    /**
     * Filter, which village to fetch.
     */
    where?: villageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of villages to fetch.
     */
    orderBy?: villageOrderByWithRelationInput | villageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for villages.
     */
    cursor?: villageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` villages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` villages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of villages.
     */
    distinct?: VillageScalarFieldEnum | VillageScalarFieldEnum[]
  }

  /**
   * village findMany
   */
  export type villageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the village
     */
    select?: villageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: villageInclude<ExtArgs> | null
    /**
     * Filter, which villages to fetch.
     */
    where?: villageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of villages to fetch.
     */
    orderBy?: villageOrderByWithRelationInput | villageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing villages.
     */
    cursor?: villageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` villages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` villages.
     */
    skip?: number
    distinct?: VillageScalarFieldEnum | VillageScalarFieldEnum[]
  }

  /**
   * village create
   */
  export type villageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the village
     */
    select?: villageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: villageInclude<ExtArgs> | null
    /**
     * The data needed to create a village.
     */
    data: XOR<villageCreateInput, villageUncheckedCreateInput>
  }

  /**
   * village createMany
   */
  export type villageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many villages.
     */
    data: villageCreateManyInput | villageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * village update
   */
  export type villageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the village
     */
    select?: villageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: villageInclude<ExtArgs> | null
    /**
     * The data needed to update a village.
     */
    data: XOR<villageUpdateInput, villageUncheckedUpdateInput>
    /**
     * Choose, which village to update.
     */
    where: villageWhereUniqueInput
  }

  /**
   * village updateMany
   */
  export type villageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update villages.
     */
    data: XOR<villageUpdateManyMutationInput, villageUncheckedUpdateManyInput>
    /**
     * Filter which villages to update
     */
    where?: villageWhereInput
  }

  /**
   * village upsert
   */
  export type villageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the village
     */
    select?: villageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: villageInclude<ExtArgs> | null
    /**
     * The filter to search for the village to update in case it exists.
     */
    where: villageWhereUniqueInput
    /**
     * In case the village found by the `where` argument doesn't exist, create a new village with this data.
     */
    create: XOR<villageCreateInput, villageUncheckedCreateInput>
    /**
     * In case the village was found with the provided `where` argument, update it with this data.
     */
    update: XOR<villageUpdateInput, villageUncheckedUpdateInput>
  }

  /**
   * village delete
   */
  export type villageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the village
     */
    select?: villageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: villageInclude<ExtArgs> | null
    /**
     * Filter which village to delete.
     */
    where: villageWhereUniqueInput
  }

  /**
   * village deleteMany
   */
  export type villageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which villages to delete
     */
    where?: villageWhereInput
  }

  /**
   * village.Province
   */
  export type village$ProvinceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the province
     */
    select?: provinceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinceInclude<ExtArgs> | null
    where?: provinceWhereInput
  }

  /**
   * village.District
   */
  export type village$DistrictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the district
     */
    select?: districtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtInclude<ExtArgs> | null
    where?: districtWhereInput
  }

  /**
   * village without action
   */
  export type villageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the village
     */
    select?: villageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: villageInclude<ExtArgs> | null
  }


  /**
   * Model address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    ID: string | null
    Address: string | null
    ProvinceID: string | null
    DistrictID: string | null
    ProfileID: string | null
    BranchesID: string | null
    IsDefault: boolean | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    ID: string | null
    Address: string | null
    ProvinceID: string | null
    DistrictID: string | null
    ProfileID: string | null
    BranchesID: string | null
    IsDefault: boolean | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    ID: number
    Address: number
    ProvinceID: number
    DistrictID: number
    ProfileID: number
    BranchesID: number
    IsDefault: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    ID?: true
    Address?: true
    ProvinceID?: true
    DistrictID?: true
    ProfileID?: true
    BranchesID?: true
    IsDefault?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    ID?: true
    Address?: true
    ProvinceID?: true
    DistrictID?: true
    ProfileID?: true
    BranchesID?: true
    IsDefault?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    ID?: true
    Address?: true
    ProvinceID?: true
    DistrictID?: true
    ProfileID?: true
    BranchesID?: true
    IsDefault?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which address to aggregate.
     */
    where?: addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: addressOrderByWithRelationInput | addressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type addressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: addressWhereInput
    orderBy?: addressOrderByWithAggregationInput | addressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: addressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    ID: string
    Address: string
    ProvinceID: string | null
    DistrictID: string | null
    ProfileID: string | null
    BranchesID: string | null
    IsDefault: boolean | null
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends addressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type addressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Address?: boolean
    ProvinceID?: boolean
    DistrictID?: boolean
    ProfileID?: boolean
    BranchesID?: boolean
    IsDefault?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Province?: boolean | address$ProvinceArgs<ExtArgs>
    District?: boolean | address$DistrictArgs<ExtArgs>
    Profile?: boolean | address$ProfileArgs<ExtArgs>
    Branches?: boolean | address$BranchesArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type addressSelectScalar = {
    ID?: boolean
    Address?: boolean
    ProvinceID?: boolean
    DistrictID?: boolean
    ProfileID?: boolean
    BranchesID?: boolean
    IsDefault?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type addressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Province?: boolean | address$ProvinceArgs<ExtArgs>
    District?: boolean | address$DistrictArgs<ExtArgs>
    Profile?: boolean | address$ProfileArgs<ExtArgs>
    Branches?: boolean | address$BranchesArgs<ExtArgs>
  }


  export type $addressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "address"
    objects: {
      Province: Prisma.$provincePayload<ExtArgs> | null
      District: Prisma.$districtPayload<ExtArgs> | null
      Profile: Prisma.$profilePayload<ExtArgs> | null
      Branches: Prisma.$branchesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Address: string
      ProvinceID: string | null
      DistrictID: string | null
      ProfileID: string | null
      BranchesID: string | null
      IsDefault: boolean | null
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["address"]>
    composites: {}
  }


  type addressGetPayload<S extends boolean | null | undefined | addressDefaultArgs> = $Result.GetResult<Prisma.$addressPayload, S>

  type addressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<addressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface addressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['address'], meta: { name: 'address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {addressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends addressFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, addressFindUniqueArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {addressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends addressFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, addressFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends addressFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, addressFindFirstArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends addressFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, addressFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const addressWithIDOnly = await prisma.address.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends addressFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, addressFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Address.
     * @param {addressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends addressCreateArgs<ExtArgs>>(
      args: SelectSubset<T, addressCreateArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Addresses.
     * @param {addressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends addressCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, addressCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {addressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends addressDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, addressDeleteArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Address.
     * @param {addressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends addressUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, addressUpdateArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Addresses.
     * @param {addressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends addressDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, addressDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends addressUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, addressUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {addressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends addressUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, addressUpsertArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends addressCountArgs>(
      args?: Subset<T, addressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends addressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: addressGroupByArgs['orderBy'] }
        : { orderBy?: addressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, addressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the address model
   */
  readonly fields: addressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__addressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Province<T extends address$ProvinceArgs<ExtArgs> = {}>(args?: Subset<T, address$ProvinceArgs<ExtArgs>>): Prisma__provinceClient<$Result.GetResult<Prisma.$provincePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    District<T extends address$DistrictArgs<ExtArgs> = {}>(args?: Subset<T, address$DistrictArgs<ExtArgs>>): Prisma__districtClient<$Result.GetResult<Prisma.$districtPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Profile<T extends address$ProfileArgs<ExtArgs> = {}>(args?: Subset<T, address$ProfileArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Branches<T extends address$BranchesArgs<ExtArgs> = {}>(args?: Subset<T, address$BranchesArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the address model
   */ 
  interface addressFieldRefs {
    readonly ID: FieldRef<"address", 'String'>
    readonly Address: FieldRef<"address", 'String'>
    readonly ProvinceID: FieldRef<"address", 'String'>
    readonly DistrictID: FieldRef<"address", 'String'>
    readonly ProfileID: FieldRef<"address", 'String'>
    readonly BranchesID: FieldRef<"address", 'String'>
    readonly IsDefault: FieldRef<"address", 'Boolean'>
    readonly Status: FieldRef<"address", 'String'>
    readonly IsActive: FieldRef<"address", 'Boolean'>
    readonly CreatedAt: FieldRef<"address", 'DateTime'>
    readonly UpdatedAt: FieldRef<"address", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * address findUnique
   */
  export type addressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter, which address to fetch.
     */
    where: addressWhereUniqueInput
  }

  /**
   * address findUniqueOrThrow
   */
  export type addressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter, which address to fetch.
     */
    where: addressWhereUniqueInput
  }

  /**
   * address findFirst
   */
  export type addressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter, which address to fetch.
     */
    where?: addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: addressOrderByWithRelationInput | addressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for addresses.
     */
    cursor?: addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * address findFirstOrThrow
   */
  export type addressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter, which address to fetch.
     */
    where?: addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: addressOrderByWithRelationInput | addressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for addresses.
     */
    cursor?: addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * address findMany
   */
  export type addressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter, which addresses to fetch.
     */
    where?: addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: addressOrderByWithRelationInput | addressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing addresses.
     */
    cursor?: addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * address create
   */
  export type addressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * The data needed to create a address.
     */
    data: XOR<addressCreateInput, addressUncheckedCreateInput>
  }

  /**
   * address createMany
   */
  export type addressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many addresses.
     */
    data: addressCreateManyInput | addressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * address update
   */
  export type addressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * The data needed to update a address.
     */
    data: XOR<addressUpdateInput, addressUncheckedUpdateInput>
    /**
     * Choose, which address to update.
     */
    where: addressWhereUniqueInput
  }

  /**
   * address updateMany
   */
  export type addressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update addresses.
     */
    data: XOR<addressUpdateManyMutationInput, addressUncheckedUpdateManyInput>
    /**
     * Filter which addresses to update
     */
    where?: addressWhereInput
  }

  /**
   * address upsert
   */
  export type addressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * The filter to search for the address to update in case it exists.
     */
    where: addressWhereUniqueInput
    /**
     * In case the address found by the `where` argument doesn't exist, create a new address with this data.
     */
    create: XOR<addressCreateInput, addressUncheckedCreateInput>
    /**
     * In case the address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<addressUpdateInput, addressUncheckedUpdateInput>
  }

  /**
   * address delete
   */
  export type addressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter which address to delete.
     */
    where: addressWhereUniqueInput
  }

  /**
   * address deleteMany
   */
  export type addressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which addresses to delete
     */
    where?: addressWhereInput
  }

  /**
   * address.Province
   */
  export type address$ProvinceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the province
     */
    select?: provinceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinceInclude<ExtArgs> | null
    where?: provinceWhereInput
  }

  /**
   * address.District
   */
  export type address$DistrictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the district
     */
    select?: districtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtInclude<ExtArgs> | null
    where?: districtWhereInput
  }

  /**
   * address.Profile
   */
  export type address$ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    where?: profileWhereInput
  }

  /**
   * address.Branches
   */
  export type address$BranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * address without action
   */
  export type addressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: addressInclude<ExtArgs> | null
  }


  /**
   * Model branches
   */

  export type AggregateBranches = {
    _count: BranchesCountAggregateOutputType | null
    _avg: BranchesAvgAggregateOutputType | null
    _sum: BranchesSumAggregateOutputType | null
    _min: BranchesMinAggregateOutputType | null
    _max: BranchesMaxAggregateOutputType | null
  }

  export type BranchesAvgAggregateOutputType = {
    Lat: number | null
    Long: number | null
  }

  export type BranchesSumAggregateOutputType = {
    Lat: number | null
    Long: number | null
  }

  export type BranchesMinAggregateOutputType = {
    ID: string | null
    CompanyId: string | null
    Name: string | null
    Address1: string | null
    Address2: string | null
    Address3: string | null
    Status: string | null
    Lat: number | null
    Long: number | null
    Zone: string | null
    IsMain: boolean | null
    UploadURL: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type BranchesMaxAggregateOutputType = {
    ID: string | null
    CompanyId: string | null
    Name: string | null
    Address1: string | null
    Address2: string | null
    Address3: string | null
    Status: string | null
    Lat: number | null
    Long: number | null
    Zone: string | null
    IsMain: boolean | null
    UploadURL: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type BranchesCountAggregateOutputType = {
    ID: number
    CompanyId: number
    Name: number
    Address1: number
    Address2: number
    Address3: number
    Status: number
    Lat: number
    Long: number
    Zone: number
    IsMain: number
    UploadURL: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type BranchesAvgAggregateInputType = {
    Lat?: true
    Long?: true
  }

  export type BranchesSumAggregateInputType = {
    Lat?: true
    Long?: true
  }

  export type BranchesMinAggregateInputType = {
    ID?: true
    CompanyId?: true
    Name?: true
    Address1?: true
    Address2?: true
    Address3?: true
    Status?: true
    Lat?: true
    Long?: true
    Zone?: true
    IsMain?: true
    UploadURL?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type BranchesMaxAggregateInputType = {
    ID?: true
    CompanyId?: true
    Name?: true
    Address1?: true
    Address2?: true
    Address3?: true
    Status?: true
    Lat?: true
    Long?: true
    Zone?: true
    IsMain?: true
    UploadURL?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type BranchesCountAggregateInputType = {
    ID?: true
    CompanyId?: true
    Name?: true
    Address1?: true
    Address2?: true
    Address3?: true
    Status?: true
    Lat?: true
    Long?: true
    Zone?: true
    IsMain?: true
    UploadURL?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type BranchesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which branches to aggregate.
     */
    where?: branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branches to fetch.
     */
    orderBy?: branchesOrderByWithRelationInput | branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned branches
    **/
    _count?: true | BranchesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchesMaxAggregateInputType
  }

  export type GetBranchesAggregateType<T extends BranchesAggregateArgs> = {
        [P in keyof T & keyof AggregateBranches]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranches[P]>
      : GetScalarType<T[P], AggregateBranches[P]>
  }




  export type branchesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: branchesWhereInput
    orderBy?: branchesOrderByWithAggregationInput | branchesOrderByWithAggregationInput[]
    by: BranchesScalarFieldEnum[] | BranchesScalarFieldEnum
    having?: branchesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchesCountAggregateInputType | true
    _avg?: BranchesAvgAggregateInputType
    _sum?: BranchesSumAggregateInputType
    _min?: BranchesMinAggregateInputType
    _max?: BranchesMaxAggregateInputType
  }

  export type BranchesGroupByOutputType = {
    ID: string
    CompanyId: string
    Name: string
    Address1: string | null
    Address2: string | null
    Address3: string | null
    Status: string | null
    Lat: number | null
    Long: number | null
    Zone: string | null
    IsMain: boolean | null
    UploadURL: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: BranchesCountAggregateOutputType | null
    _avg: BranchesAvgAggregateOutputType | null
    _sum: BranchesSumAggregateOutputType | null
    _min: BranchesMinAggregateOutputType | null
    _max: BranchesMaxAggregateOutputType | null
  }

  type GetBranchesGroupByPayload<T extends branchesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchesGroupByOutputType[P]>
            : GetScalarType<T[P], BranchesGroupByOutputType[P]>
        }
      >
    >


  export type branchesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    CompanyId?: boolean
    Name?: boolean
    Address1?: boolean
    Address2?: boolean
    Address3?: boolean
    Status?: boolean
    Lat?: boolean
    Long?: boolean
    Zone?: boolean
    IsMain?: boolean
    UploadURL?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Address?: boolean | branches$AddressArgs<ExtArgs>
    User?: boolean | branches$UserArgs<ExtArgs>
    BranchesKey?: boolean | branches$BranchesKeyArgs<ExtArgs>
    BranchesSettings?: boolean | branches$BranchesSettingsArgs<ExtArgs>
    Otp?: boolean | branches$OtpArgs<ExtArgs>
    Notifications?: boolean | branches$NotificationsArgs<ExtArgs>
    OrderCategory?: boolean | branches$OrderCategoryArgs<ExtArgs>
    Order?: boolean | branches$OrderArgs<ExtArgs>
    Tracking?: boolean | branches$TrackingArgs<ExtArgs>
    _count?: boolean | BranchesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branches"]>

  export type branchesSelectScalar = {
    ID?: boolean
    CompanyId?: boolean
    Name?: boolean
    Address1?: boolean
    Address2?: boolean
    Address3?: boolean
    Status?: boolean
    Lat?: boolean
    Long?: boolean
    Zone?: boolean
    IsMain?: boolean
    UploadURL?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type branchesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Address?: boolean | branches$AddressArgs<ExtArgs>
    User?: boolean | branches$UserArgs<ExtArgs>
    BranchesKey?: boolean | branches$BranchesKeyArgs<ExtArgs>
    BranchesSettings?: boolean | branches$BranchesSettingsArgs<ExtArgs>
    Otp?: boolean | branches$OtpArgs<ExtArgs>
    Notifications?: boolean | branches$NotificationsArgs<ExtArgs>
    OrderCategory?: boolean | branches$OrderCategoryArgs<ExtArgs>
    Order?: boolean | branches$OrderArgs<ExtArgs>
    Tracking?: boolean | branches$TrackingArgs<ExtArgs>
    _count?: boolean | BranchesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $branchesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "branches"
    objects: {
      Address: Prisma.$addressPayload<ExtArgs> | null
      User: Prisma.$usersPayload<ExtArgs> | null
      BranchesKey: Prisma.$branchesKeyPayload<ExtArgs>[]
      BranchesSettings: Prisma.$branchesSettingsPayload<ExtArgs>[]
      Otp: Prisma.$otpPayload<ExtArgs>[]
      Notifications: Prisma.$notificationsPayload<ExtArgs>[]
      OrderCategory: Prisma.$orderCategoryPayload<ExtArgs>[]
      Order: Prisma.$orderPayload<ExtArgs>[]
      Tracking: Prisma.$orderTackingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      CompanyId: string
      Name: string
      Address1: string | null
      Address2: string | null
      Address3: string | null
      Status: string | null
      Lat: number | null
      Long: number | null
      Zone: string | null
      IsMain: boolean | null
      UploadURL: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["branches"]>
    composites: {}
  }


  type branchesGetPayload<S extends boolean | null | undefined | branchesDefaultArgs> = $Result.GetResult<Prisma.$branchesPayload, S>

  type branchesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<branchesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchesCountAggregateInputType | true
    }

  export interface branchesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['branches'], meta: { name: 'branches' } }
    /**
     * Find zero or one Branches that matches the filter.
     * @param {branchesFindUniqueArgs} args - Arguments to find a Branches
     * @example
     * // Get one Branches
     * const branches = await prisma.branches.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends branchesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, branchesFindUniqueArgs<ExtArgs>>
    ): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Branches that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {branchesFindUniqueOrThrowArgs} args - Arguments to find a Branches
     * @example
     * // Get one Branches
     * const branches = await prisma.branches.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends branchesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesFindFirstArgs} args - Arguments to find a Branches
     * @example
     * // Get one Branches
     * const branches = await prisma.branches.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends branchesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesFindFirstArgs<ExtArgs>>
    ): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Branches that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesFindFirstOrThrowArgs} args - Arguments to find a Branches
     * @example
     * // Get one Branches
     * const branches = await prisma.branches.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends branchesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branches.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branches.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const branchesWithIDOnly = await prisma.branches.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends branchesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Branches.
     * @param {branchesCreateArgs} args - Arguments to create a Branches.
     * @example
     * // Create one Branches
     * const Branches = await prisma.branches.create({
     *   data: {
     *     // ... data to create a Branches
     *   }
     * })
     * 
    **/
    create<T extends branchesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, branchesCreateArgs<ExtArgs>>
    ): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Branches.
     * @param {branchesCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branches = await prisma.branches.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends branchesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Branches.
     * @param {branchesDeleteArgs} args - Arguments to delete one Branches.
     * @example
     * // Delete one Branches
     * const Branches = await prisma.branches.delete({
     *   where: {
     *     // ... filter to delete one Branches
     *   }
     * })
     * 
    **/
    delete<T extends branchesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, branchesDeleteArgs<ExtArgs>>
    ): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Branches.
     * @param {branchesUpdateArgs} args - Arguments to update one Branches.
     * @example
     * // Update one Branches
     * const branches = await prisma.branches.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends branchesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, branchesUpdateArgs<ExtArgs>>
    ): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Branches.
     * @param {branchesDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branches.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends branchesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branches = await prisma.branches.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends branchesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, branchesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branches.
     * @param {branchesUpsertArgs} args - Arguments to update or create a Branches.
     * @example
     * // Update or create a Branches
     * const branches = await prisma.branches.upsert({
     *   create: {
     *     // ... data to create a Branches
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branches we want to update
     *   }
     * })
    **/
    upsert<T extends branchesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, branchesUpsertArgs<ExtArgs>>
    ): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branches.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends branchesCountArgs>(
      args?: Subset<T, branchesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchesAggregateArgs>(args: Subset<T, BranchesAggregateArgs>): Prisma.PrismaPromise<GetBranchesAggregateType<T>>

    /**
     * Group by Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends branchesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: branchesGroupByArgs['orderBy'] }
        : { orderBy?: branchesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, branchesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the branches model
   */
  readonly fields: branchesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for branches.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__branchesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Address<T extends branches$AddressArgs<ExtArgs> = {}>(args?: Subset<T, branches$AddressArgs<ExtArgs>>): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    User<T extends branches$UserArgs<ExtArgs> = {}>(args?: Subset<T, branches$UserArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    BranchesKey<T extends branches$BranchesKeyArgs<ExtArgs> = {}>(args?: Subset<T, branches$BranchesKeyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$branchesKeyPayload<ExtArgs>, T, 'findMany'> | Null>;

    BranchesSettings<T extends branches$BranchesSettingsArgs<ExtArgs> = {}>(args?: Subset<T, branches$BranchesSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$branchesSettingsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Otp<T extends branches$OtpArgs<ExtArgs> = {}>(args?: Subset<T, branches$OtpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'findMany'> | Null>;

    Notifications<T extends branches$NotificationsArgs<ExtArgs> = {}>(args?: Subset<T, branches$NotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, 'findMany'> | Null>;

    OrderCategory<T extends branches$OrderCategoryArgs<ExtArgs> = {}>(args?: Subset<T, branches$OrderCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderCategoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    Order<T extends branches$OrderArgs<ExtArgs> = {}>(args?: Subset<T, branches$OrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findMany'> | Null>;

    Tracking<T extends branches$TrackingArgs<ExtArgs> = {}>(args?: Subset<T, branches$TrackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderTackingPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the branches model
   */ 
  interface branchesFieldRefs {
    readonly ID: FieldRef<"branches", 'String'>
    readonly CompanyId: FieldRef<"branches", 'String'>
    readonly Name: FieldRef<"branches", 'String'>
    readonly Address1: FieldRef<"branches", 'String'>
    readonly Address2: FieldRef<"branches", 'String'>
    readonly Address3: FieldRef<"branches", 'String'>
    readonly Status: FieldRef<"branches", 'String'>
    readonly Lat: FieldRef<"branches", 'Float'>
    readonly Long: FieldRef<"branches", 'Float'>
    readonly Zone: FieldRef<"branches", 'String'>
    readonly IsMain: FieldRef<"branches", 'Boolean'>
    readonly UploadURL: FieldRef<"branches", 'String'>
    readonly IsActive: FieldRef<"branches", 'Boolean'>
    readonly CreatedAt: FieldRef<"branches", 'DateTime'>
    readonly UpdatedAt: FieldRef<"branches", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * branches findUnique
   */
  export type branchesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter, which branches to fetch.
     */
    where: branchesWhereUniqueInput
  }

  /**
   * branches findUniqueOrThrow
   */
  export type branchesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter, which branches to fetch.
     */
    where: branchesWhereUniqueInput
  }

  /**
   * branches findFirst
   */
  export type branchesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter, which branches to fetch.
     */
    where?: branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branches to fetch.
     */
    orderBy?: branchesOrderByWithRelationInput | branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for branches.
     */
    cursor?: branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of branches.
     */
    distinct?: BranchesScalarFieldEnum | BranchesScalarFieldEnum[]
  }

  /**
   * branches findFirstOrThrow
   */
  export type branchesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter, which branches to fetch.
     */
    where?: branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branches to fetch.
     */
    orderBy?: branchesOrderByWithRelationInput | branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for branches.
     */
    cursor?: branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of branches.
     */
    distinct?: BranchesScalarFieldEnum | BranchesScalarFieldEnum[]
  }

  /**
   * branches findMany
   */
  export type branchesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter, which branches to fetch.
     */
    where?: branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branches to fetch.
     */
    orderBy?: branchesOrderByWithRelationInput | branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing branches.
     */
    cursor?: branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branches.
     */
    skip?: number
    distinct?: BranchesScalarFieldEnum | BranchesScalarFieldEnum[]
  }

  /**
   * branches create
   */
  export type branchesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * The data needed to create a branches.
     */
    data: XOR<branchesCreateInput, branchesUncheckedCreateInput>
  }

  /**
   * branches createMany
   */
  export type branchesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many branches.
     */
    data: branchesCreateManyInput | branchesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * branches update
   */
  export type branchesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * The data needed to update a branches.
     */
    data: XOR<branchesUpdateInput, branchesUncheckedUpdateInput>
    /**
     * Choose, which branches to update.
     */
    where: branchesWhereUniqueInput
  }

  /**
   * branches updateMany
   */
  export type branchesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update branches.
     */
    data: XOR<branchesUpdateManyMutationInput, branchesUncheckedUpdateManyInput>
    /**
     * Filter which branches to update
     */
    where?: branchesWhereInput
  }

  /**
   * branches upsert
   */
  export type branchesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * The filter to search for the branches to update in case it exists.
     */
    where: branchesWhereUniqueInput
    /**
     * In case the branches found by the `where` argument doesn't exist, create a new branches with this data.
     */
    create: XOR<branchesCreateInput, branchesUncheckedCreateInput>
    /**
     * In case the branches was found with the provided `where` argument, update it with this data.
     */
    update: XOR<branchesUpdateInput, branchesUncheckedUpdateInput>
  }

  /**
   * branches delete
   */
  export type branchesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter which branches to delete.
     */
    where: branchesWhereUniqueInput
  }

  /**
   * branches deleteMany
   */
  export type branchesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which branches to delete
     */
    where?: branchesWhereInput
  }

  /**
   * branches.Address
   */
  export type branches$AddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: addressInclude<ExtArgs> | null
    where?: addressWhereInput
  }

  /**
   * branches.User
   */
  export type branches$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * branches.BranchesKey
   */
  export type branches$BranchesKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesKey
     */
    select?: branchesKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesKeyInclude<ExtArgs> | null
    where?: branchesKeyWhereInput
    orderBy?: branchesKeyOrderByWithRelationInput | branchesKeyOrderByWithRelationInput[]
    cursor?: branchesKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchesKeyScalarFieldEnum | BranchesKeyScalarFieldEnum[]
  }

  /**
   * branches.BranchesSettings
   */
  export type branches$BranchesSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesSettings
     */
    select?: branchesSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesSettingsInclude<ExtArgs> | null
    where?: branchesSettingsWhereInput
    orderBy?: branchesSettingsOrderByWithRelationInput | branchesSettingsOrderByWithRelationInput[]
    cursor?: branchesSettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchesSettingsScalarFieldEnum | BranchesSettingsScalarFieldEnum[]
  }

  /**
   * branches.Otp
   */
  export type branches$OtpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    where?: otpWhereInput
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    cursor?: otpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * branches.Notifications
   */
  export type branches$NotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * branches.OrderCategory
   */
  export type branches$OrderCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderCategory
     */
    select?: orderCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderCategoryInclude<ExtArgs> | null
    where?: orderCategoryWhereInput
    orderBy?: orderCategoryOrderByWithRelationInput | orderCategoryOrderByWithRelationInput[]
    cursor?: orderCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderCategoryScalarFieldEnum | OrderCategoryScalarFieldEnum[]
  }

  /**
   * branches.Order
   */
  export type branches$OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    cursor?: orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * branches.Tracking
   */
  export type branches$TrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderTacking
     */
    select?: orderTackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderTackingInclude<ExtArgs> | null
    where?: orderTackingWhereInput
    orderBy?: orderTackingOrderByWithRelationInput | orderTackingOrderByWithRelationInput[]
    cursor?: orderTackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderTackingScalarFieldEnum | OrderTackingScalarFieldEnum[]
  }

  /**
   * branches without action
   */
  export type branchesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
  }


  /**
   * Model branchesKey
   */

  export type AggregateBranchesKey = {
    _count: BranchesKeyCountAggregateOutputType | null
    _min: BranchesKeyMinAggregateOutputType | null
    _max: BranchesKeyMaxAggregateOutputType | null
  }

  export type BranchesKeyMinAggregateOutputType = {
    ID: string | null
    Key: string | null
    Secret: string | null
    Remask: string | null
    BranchesID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type BranchesKeyMaxAggregateOutputType = {
    ID: string | null
    Key: string | null
    Secret: string | null
    Remask: string | null
    BranchesID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type BranchesKeyCountAggregateOutputType = {
    ID: number
    Key: number
    Secret: number
    Remask: number
    BranchesID: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type BranchesKeyMinAggregateInputType = {
    ID?: true
    Key?: true
    Secret?: true
    Remask?: true
    BranchesID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type BranchesKeyMaxAggregateInputType = {
    ID?: true
    Key?: true
    Secret?: true
    Remask?: true
    BranchesID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type BranchesKeyCountAggregateInputType = {
    ID?: true
    Key?: true
    Secret?: true
    Remask?: true
    BranchesID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type BranchesKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which branchesKey to aggregate.
     */
    where?: branchesKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branchesKeys to fetch.
     */
    orderBy?: branchesKeyOrderByWithRelationInput | branchesKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: branchesKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branchesKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branchesKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned branchesKeys
    **/
    _count?: true | BranchesKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchesKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchesKeyMaxAggregateInputType
  }

  export type GetBranchesKeyAggregateType<T extends BranchesKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateBranchesKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranchesKey[P]>
      : GetScalarType<T[P], AggregateBranchesKey[P]>
  }




  export type branchesKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: branchesKeyWhereInput
    orderBy?: branchesKeyOrderByWithAggregationInput | branchesKeyOrderByWithAggregationInput[]
    by: BranchesKeyScalarFieldEnum[] | BranchesKeyScalarFieldEnum
    having?: branchesKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchesKeyCountAggregateInputType | true
    _min?: BranchesKeyMinAggregateInputType
    _max?: BranchesKeyMaxAggregateInputType
  }

  export type BranchesKeyGroupByOutputType = {
    ID: string
    Key: string
    Secret: string
    Remask: string | null
    BranchesID: string | null
    Status: string
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: BranchesKeyCountAggregateOutputType | null
    _min: BranchesKeyMinAggregateOutputType | null
    _max: BranchesKeyMaxAggregateOutputType | null
  }

  type GetBranchesKeyGroupByPayload<T extends branchesKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchesKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchesKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchesKeyGroupByOutputType[P]>
            : GetScalarType<T[P], BranchesKeyGroupByOutputType[P]>
        }
      >
    >


  export type branchesKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Key?: boolean
    Secret?: boolean
    Remask?: boolean
    BranchesID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Branches?: boolean | branchesKey$BranchesArgs<ExtArgs>
  }, ExtArgs["result"]["branchesKey"]>

  export type branchesKeySelectScalar = {
    ID?: boolean
    Key?: boolean
    Secret?: boolean
    Remask?: boolean
    BranchesID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type branchesKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Branches?: boolean | branchesKey$BranchesArgs<ExtArgs>
  }


  export type $branchesKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "branchesKey"
    objects: {
      Branches: Prisma.$branchesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Key: string
      Secret: string
      Remask: string | null
      BranchesID: string | null
      Status: string
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["branchesKey"]>
    composites: {}
  }


  type branchesKeyGetPayload<S extends boolean | null | undefined | branchesKeyDefaultArgs> = $Result.GetResult<Prisma.$branchesKeyPayload, S>

  type branchesKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<branchesKeyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchesKeyCountAggregateInputType | true
    }

  export interface branchesKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['branchesKey'], meta: { name: 'branchesKey' } }
    /**
     * Find zero or one BranchesKey that matches the filter.
     * @param {branchesKeyFindUniqueArgs} args - Arguments to find a BranchesKey
     * @example
     * // Get one BranchesKey
     * const branchesKey = await prisma.branchesKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends branchesKeyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, branchesKeyFindUniqueArgs<ExtArgs>>
    ): Prisma__branchesKeyClient<$Result.GetResult<Prisma.$branchesKeyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BranchesKey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {branchesKeyFindUniqueOrThrowArgs} args - Arguments to find a BranchesKey
     * @example
     * // Get one BranchesKey
     * const branchesKey = await prisma.branchesKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends branchesKeyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesKeyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__branchesKeyClient<$Result.GetResult<Prisma.$branchesKeyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BranchesKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesKeyFindFirstArgs} args - Arguments to find a BranchesKey
     * @example
     * // Get one BranchesKey
     * const branchesKey = await prisma.branchesKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends branchesKeyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesKeyFindFirstArgs<ExtArgs>>
    ): Prisma__branchesKeyClient<$Result.GetResult<Prisma.$branchesKeyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BranchesKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesKeyFindFirstOrThrowArgs} args - Arguments to find a BranchesKey
     * @example
     * // Get one BranchesKey
     * const branchesKey = await prisma.branchesKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends branchesKeyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesKeyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__branchesKeyClient<$Result.GetResult<Prisma.$branchesKeyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BranchesKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BranchesKeys
     * const branchesKeys = await prisma.branchesKey.findMany()
     * 
     * // Get first 10 BranchesKeys
     * const branchesKeys = await prisma.branchesKey.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const branchesKeyWithIDOnly = await prisma.branchesKey.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends branchesKeyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesKeyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$branchesKeyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BranchesKey.
     * @param {branchesKeyCreateArgs} args - Arguments to create a BranchesKey.
     * @example
     * // Create one BranchesKey
     * const BranchesKey = await prisma.branchesKey.create({
     *   data: {
     *     // ... data to create a BranchesKey
     *   }
     * })
     * 
    **/
    create<T extends branchesKeyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, branchesKeyCreateArgs<ExtArgs>>
    ): Prisma__branchesKeyClient<$Result.GetResult<Prisma.$branchesKeyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BranchesKeys.
     * @param {branchesKeyCreateManyArgs} args - Arguments to create many BranchesKeys.
     * @example
     * // Create many BranchesKeys
     * const branchesKey = await prisma.branchesKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends branchesKeyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesKeyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BranchesKey.
     * @param {branchesKeyDeleteArgs} args - Arguments to delete one BranchesKey.
     * @example
     * // Delete one BranchesKey
     * const BranchesKey = await prisma.branchesKey.delete({
     *   where: {
     *     // ... filter to delete one BranchesKey
     *   }
     * })
     * 
    **/
    delete<T extends branchesKeyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, branchesKeyDeleteArgs<ExtArgs>>
    ): Prisma__branchesKeyClient<$Result.GetResult<Prisma.$branchesKeyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BranchesKey.
     * @param {branchesKeyUpdateArgs} args - Arguments to update one BranchesKey.
     * @example
     * // Update one BranchesKey
     * const branchesKey = await prisma.branchesKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends branchesKeyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, branchesKeyUpdateArgs<ExtArgs>>
    ): Prisma__branchesKeyClient<$Result.GetResult<Prisma.$branchesKeyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BranchesKeys.
     * @param {branchesKeyDeleteManyArgs} args - Arguments to filter BranchesKeys to delete.
     * @example
     * // Delete a few BranchesKeys
     * const { count } = await prisma.branchesKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends branchesKeyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesKeyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BranchesKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BranchesKeys
     * const branchesKey = await prisma.branchesKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends branchesKeyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, branchesKeyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BranchesKey.
     * @param {branchesKeyUpsertArgs} args - Arguments to update or create a BranchesKey.
     * @example
     * // Update or create a BranchesKey
     * const branchesKey = await prisma.branchesKey.upsert({
     *   create: {
     *     // ... data to create a BranchesKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BranchesKey we want to update
     *   }
     * })
    **/
    upsert<T extends branchesKeyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, branchesKeyUpsertArgs<ExtArgs>>
    ): Prisma__branchesKeyClient<$Result.GetResult<Prisma.$branchesKeyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BranchesKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesKeyCountArgs} args - Arguments to filter BranchesKeys to count.
     * @example
     * // Count the number of BranchesKeys
     * const count = await prisma.branchesKey.count({
     *   where: {
     *     // ... the filter for the BranchesKeys we want to count
     *   }
     * })
    **/
    count<T extends branchesKeyCountArgs>(
      args?: Subset<T, branchesKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchesKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BranchesKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchesKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchesKeyAggregateArgs>(args: Subset<T, BranchesKeyAggregateArgs>): Prisma.PrismaPromise<GetBranchesKeyAggregateType<T>>

    /**
     * Group by BranchesKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends branchesKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: branchesKeyGroupByArgs['orderBy'] }
        : { orderBy?: branchesKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, branchesKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchesKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the branchesKey model
   */
  readonly fields: branchesKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for branchesKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__branchesKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Branches<T extends branchesKey$BranchesArgs<ExtArgs> = {}>(args?: Subset<T, branchesKey$BranchesArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the branchesKey model
   */ 
  interface branchesKeyFieldRefs {
    readonly ID: FieldRef<"branchesKey", 'String'>
    readonly Key: FieldRef<"branchesKey", 'String'>
    readonly Secret: FieldRef<"branchesKey", 'String'>
    readonly Remask: FieldRef<"branchesKey", 'String'>
    readonly BranchesID: FieldRef<"branchesKey", 'String'>
    readonly Status: FieldRef<"branchesKey", 'String'>
    readonly IsActive: FieldRef<"branchesKey", 'Boolean'>
    readonly CreatedAt: FieldRef<"branchesKey", 'DateTime'>
    readonly UpdatedAt: FieldRef<"branchesKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * branchesKey findUnique
   */
  export type branchesKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesKey
     */
    select?: branchesKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesKeyInclude<ExtArgs> | null
    /**
     * Filter, which branchesKey to fetch.
     */
    where: branchesKeyWhereUniqueInput
  }

  /**
   * branchesKey findUniqueOrThrow
   */
  export type branchesKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesKey
     */
    select?: branchesKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesKeyInclude<ExtArgs> | null
    /**
     * Filter, which branchesKey to fetch.
     */
    where: branchesKeyWhereUniqueInput
  }

  /**
   * branchesKey findFirst
   */
  export type branchesKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesKey
     */
    select?: branchesKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesKeyInclude<ExtArgs> | null
    /**
     * Filter, which branchesKey to fetch.
     */
    where?: branchesKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branchesKeys to fetch.
     */
    orderBy?: branchesKeyOrderByWithRelationInput | branchesKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for branchesKeys.
     */
    cursor?: branchesKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branchesKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branchesKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of branchesKeys.
     */
    distinct?: BranchesKeyScalarFieldEnum | BranchesKeyScalarFieldEnum[]
  }

  /**
   * branchesKey findFirstOrThrow
   */
  export type branchesKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesKey
     */
    select?: branchesKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesKeyInclude<ExtArgs> | null
    /**
     * Filter, which branchesKey to fetch.
     */
    where?: branchesKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branchesKeys to fetch.
     */
    orderBy?: branchesKeyOrderByWithRelationInput | branchesKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for branchesKeys.
     */
    cursor?: branchesKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branchesKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branchesKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of branchesKeys.
     */
    distinct?: BranchesKeyScalarFieldEnum | BranchesKeyScalarFieldEnum[]
  }

  /**
   * branchesKey findMany
   */
  export type branchesKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesKey
     */
    select?: branchesKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesKeyInclude<ExtArgs> | null
    /**
     * Filter, which branchesKeys to fetch.
     */
    where?: branchesKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branchesKeys to fetch.
     */
    orderBy?: branchesKeyOrderByWithRelationInput | branchesKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing branchesKeys.
     */
    cursor?: branchesKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branchesKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branchesKeys.
     */
    skip?: number
    distinct?: BranchesKeyScalarFieldEnum | BranchesKeyScalarFieldEnum[]
  }

  /**
   * branchesKey create
   */
  export type branchesKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesKey
     */
    select?: branchesKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a branchesKey.
     */
    data: XOR<branchesKeyCreateInput, branchesKeyUncheckedCreateInput>
  }

  /**
   * branchesKey createMany
   */
  export type branchesKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many branchesKeys.
     */
    data: branchesKeyCreateManyInput | branchesKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * branchesKey update
   */
  export type branchesKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesKey
     */
    select?: branchesKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a branchesKey.
     */
    data: XOR<branchesKeyUpdateInput, branchesKeyUncheckedUpdateInput>
    /**
     * Choose, which branchesKey to update.
     */
    where: branchesKeyWhereUniqueInput
  }

  /**
   * branchesKey updateMany
   */
  export type branchesKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update branchesKeys.
     */
    data: XOR<branchesKeyUpdateManyMutationInput, branchesKeyUncheckedUpdateManyInput>
    /**
     * Filter which branchesKeys to update
     */
    where?: branchesKeyWhereInput
  }

  /**
   * branchesKey upsert
   */
  export type branchesKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesKey
     */
    select?: branchesKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the branchesKey to update in case it exists.
     */
    where: branchesKeyWhereUniqueInput
    /**
     * In case the branchesKey found by the `where` argument doesn't exist, create a new branchesKey with this data.
     */
    create: XOR<branchesKeyCreateInput, branchesKeyUncheckedCreateInput>
    /**
     * In case the branchesKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<branchesKeyUpdateInput, branchesKeyUncheckedUpdateInput>
  }

  /**
   * branchesKey delete
   */
  export type branchesKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesKey
     */
    select?: branchesKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesKeyInclude<ExtArgs> | null
    /**
     * Filter which branchesKey to delete.
     */
    where: branchesKeyWhereUniqueInput
  }

  /**
   * branchesKey deleteMany
   */
  export type branchesKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which branchesKeys to delete
     */
    where?: branchesKeyWhereInput
  }

  /**
   * branchesKey.Branches
   */
  export type branchesKey$BranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * branchesKey without action
   */
  export type branchesKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesKey
     */
    select?: branchesKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesKeyInclude<ExtArgs> | null
  }


  /**
   * Model branchesSettings
   */

  export type AggregateBranchesSettings = {
    _count: BranchesSettingsCountAggregateOutputType | null
    _min: BranchesSettingsMinAggregateOutputType | null
    _max: BranchesSettingsMaxAggregateOutputType | null
  }

  export type BranchesSettingsMinAggregateOutputType = {
    ID: string | null
    Titel: string | null
    Setting: string | null
    Remask: string | null
    BranchesID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type BranchesSettingsMaxAggregateOutputType = {
    ID: string | null
    Titel: string | null
    Setting: string | null
    Remask: string | null
    BranchesID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type BranchesSettingsCountAggregateOutputType = {
    ID: number
    Titel: number
    Setting: number
    Remask: number
    BranchesID: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type BranchesSettingsMinAggregateInputType = {
    ID?: true
    Titel?: true
    Setting?: true
    Remask?: true
    BranchesID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type BranchesSettingsMaxAggregateInputType = {
    ID?: true
    Titel?: true
    Setting?: true
    Remask?: true
    BranchesID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type BranchesSettingsCountAggregateInputType = {
    ID?: true
    Titel?: true
    Setting?: true
    Remask?: true
    BranchesID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type BranchesSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which branchesSettings to aggregate.
     */
    where?: branchesSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branchesSettings to fetch.
     */
    orderBy?: branchesSettingsOrderByWithRelationInput | branchesSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: branchesSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branchesSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branchesSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned branchesSettings
    **/
    _count?: true | BranchesSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchesSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchesSettingsMaxAggregateInputType
  }

  export type GetBranchesSettingsAggregateType<T extends BranchesSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateBranchesSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranchesSettings[P]>
      : GetScalarType<T[P], AggregateBranchesSettings[P]>
  }




  export type branchesSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: branchesSettingsWhereInput
    orderBy?: branchesSettingsOrderByWithAggregationInput | branchesSettingsOrderByWithAggregationInput[]
    by: BranchesSettingsScalarFieldEnum[] | BranchesSettingsScalarFieldEnum
    having?: branchesSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchesSettingsCountAggregateInputType | true
    _min?: BranchesSettingsMinAggregateInputType
    _max?: BranchesSettingsMaxAggregateInputType
  }

  export type BranchesSettingsGroupByOutputType = {
    ID: string
    Titel: string
    Setting: string
    Remask: string | null
    BranchesID: string | null
    Status: string
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: BranchesSettingsCountAggregateOutputType | null
    _min: BranchesSettingsMinAggregateOutputType | null
    _max: BranchesSettingsMaxAggregateOutputType | null
  }

  type GetBranchesSettingsGroupByPayload<T extends branchesSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchesSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchesSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchesSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], BranchesSettingsGroupByOutputType[P]>
        }
      >
    >


  export type branchesSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Titel?: boolean
    Setting?: boolean
    Remask?: boolean
    BranchesID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Branches?: boolean | branchesSettings$BranchesArgs<ExtArgs>
  }, ExtArgs["result"]["branchesSettings"]>

  export type branchesSettingsSelectScalar = {
    ID?: boolean
    Titel?: boolean
    Setting?: boolean
    Remask?: boolean
    BranchesID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type branchesSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Branches?: boolean | branchesSettings$BranchesArgs<ExtArgs>
  }


  export type $branchesSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "branchesSettings"
    objects: {
      Branches: Prisma.$branchesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Titel: string
      Setting: string
      Remask: string | null
      BranchesID: string | null
      Status: string
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["branchesSettings"]>
    composites: {}
  }


  type branchesSettingsGetPayload<S extends boolean | null | undefined | branchesSettingsDefaultArgs> = $Result.GetResult<Prisma.$branchesSettingsPayload, S>

  type branchesSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<branchesSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchesSettingsCountAggregateInputType | true
    }

  export interface branchesSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['branchesSettings'], meta: { name: 'branchesSettings' } }
    /**
     * Find zero or one BranchesSettings that matches the filter.
     * @param {branchesSettingsFindUniqueArgs} args - Arguments to find a BranchesSettings
     * @example
     * // Get one BranchesSettings
     * const branchesSettings = await prisma.branchesSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends branchesSettingsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, branchesSettingsFindUniqueArgs<ExtArgs>>
    ): Prisma__branchesSettingsClient<$Result.GetResult<Prisma.$branchesSettingsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BranchesSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {branchesSettingsFindUniqueOrThrowArgs} args - Arguments to find a BranchesSettings
     * @example
     * // Get one BranchesSettings
     * const branchesSettings = await prisma.branchesSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends branchesSettingsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesSettingsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__branchesSettingsClient<$Result.GetResult<Prisma.$branchesSettingsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BranchesSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesSettingsFindFirstArgs} args - Arguments to find a BranchesSettings
     * @example
     * // Get one BranchesSettings
     * const branchesSettings = await prisma.branchesSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends branchesSettingsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesSettingsFindFirstArgs<ExtArgs>>
    ): Prisma__branchesSettingsClient<$Result.GetResult<Prisma.$branchesSettingsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BranchesSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesSettingsFindFirstOrThrowArgs} args - Arguments to find a BranchesSettings
     * @example
     * // Get one BranchesSettings
     * const branchesSettings = await prisma.branchesSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends branchesSettingsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesSettingsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__branchesSettingsClient<$Result.GetResult<Prisma.$branchesSettingsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BranchesSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BranchesSettings
     * const branchesSettings = await prisma.branchesSettings.findMany()
     * 
     * // Get first 10 BranchesSettings
     * const branchesSettings = await prisma.branchesSettings.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const branchesSettingsWithIDOnly = await prisma.branchesSettings.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends branchesSettingsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesSettingsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$branchesSettingsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BranchesSettings.
     * @param {branchesSettingsCreateArgs} args - Arguments to create a BranchesSettings.
     * @example
     * // Create one BranchesSettings
     * const BranchesSettings = await prisma.branchesSettings.create({
     *   data: {
     *     // ... data to create a BranchesSettings
     *   }
     * })
     * 
    **/
    create<T extends branchesSettingsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, branchesSettingsCreateArgs<ExtArgs>>
    ): Prisma__branchesSettingsClient<$Result.GetResult<Prisma.$branchesSettingsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BranchesSettings.
     * @param {branchesSettingsCreateManyArgs} args - Arguments to create many BranchesSettings.
     * @example
     * // Create many BranchesSettings
     * const branchesSettings = await prisma.branchesSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends branchesSettingsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesSettingsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BranchesSettings.
     * @param {branchesSettingsDeleteArgs} args - Arguments to delete one BranchesSettings.
     * @example
     * // Delete one BranchesSettings
     * const BranchesSettings = await prisma.branchesSettings.delete({
     *   where: {
     *     // ... filter to delete one BranchesSettings
     *   }
     * })
     * 
    **/
    delete<T extends branchesSettingsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, branchesSettingsDeleteArgs<ExtArgs>>
    ): Prisma__branchesSettingsClient<$Result.GetResult<Prisma.$branchesSettingsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BranchesSettings.
     * @param {branchesSettingsUpdateArgs} args - Arguments to update one BranchesSettings.
     * @example
     * // Update one BranchesSettings
     * const branchesSettings = await prisma.branchesSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends branchesSettingsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, branchesSettingsUpdateArgs<ExtArgs>>
    ): Prisma__branchesSettingsClient<$Result.GetResult<Prisma.$branchesSettingsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BranchesSettings.
     * @param {branchesSettingsDeleteManyArgs} args - Arguments to filter BranchesSettings to delete.
     * @example
     * // Delete a few BranchesSettings
     * const { count } = await prisma.branchesSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends branchesSettingsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, branchesSettingsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BranchesSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BranchesSettings
     * const branchesSettings = await prisma.branchesSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends branchesSettingsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, branchesSettingsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BranchesSettings.
     * @param {branchesSettingsUpsertArgs} args - Arguments to update or create a BranchesSettings.
     * @example
     * // Update or create a BranchesSettings
     * const branchesSettings = await prisma.branchesSettings.upsert({
     *   create: {
     *     // ... data to create a BranchesSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BranchesSettings we want to update
     *   }
     * })
    **/
    upsert<T extends branchesSettingsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, branchesSettingsUpsertArgs<ExtArgs>>
    ): Prisma__branchesSettingsClient<$Result.GetResult<Prisma.$branchesSettingsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BranchesSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesSettingsCountArgs} args - Arguments to filter BranchesSettings to count.
     * @example
     * // Count the number of BranchesSettings
     * const count = await prisma.branchesSettings.count({
     *   where: {
     *     // ... the filter for the BranchesSettings we want to count
     *   }
     * })
    **/
    count<T extends branchesSettingsCountArgs>(
      args?: Subset<T, branchesSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchesSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BranchesSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchesSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchesSettingsAggregateArgs>(args: Subset<T, BranchesSettingsAggregateArgs>): Prisma.PrismaPromise<GetBranchesSettingsAggregateType<T>>

    /**
     * Group by BranchesSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends branchesSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: branchesSettingsGroupByArgs['orderBy'] }
        : { orderBy?: branchesSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, branchesSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchesSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the branchesSettings model
   */
  readonly fields: branchesSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for branchesSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__branchesSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Branches<T extends branchesSettings$BranchesArgs<ExtArgs> = {}>(args?: Subset<T, branchesSettings$BranchesArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the branchesSettings model
   */ 
  interface branchesSettingsFieldRefs {
    readonly ID: FieldRef<"branchesSettings", 'String'>
    readonly Titel: FieldRef<"branchesSettings", 'String'>
    readonly Setting: FieldRef<"branchesSettings", 'String'>
    readonly Remask: FieldRef<"branchesSettings", 'String'>
    readonly BranchesID: FieldRef<"branchesSettings", 'String'>
    readonly Status: FieldRef<"branchesSettings", 'String'>
    readonly IsActive: FieldRef<"branchesSettings", 'Boolean'>
    readonly CreatedAt: FieldRef<"branchesSettings", 'DateTime'>
    readonly UpdatedAt: FieldRef<"branchesSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * branchesSettings findUnique
   */
  export type branchesSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesSettings
     */
    select?: branchesSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesSettingsInclude<ExtArgs> | null
    /**
     * Filter, which branchesSettings to fetch.
     */
    where: branchesSettingsWhereUniqueInput
  }

  /**
   * branchesSettings findUniqueOrThrow
   */
  export type branchesSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesSettings
     */
    select?: branchesSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesSettingsInclude<ExtArgs> | null
    /**
     * Filter, which branchesSettings to fetch.
     */
    where: branchesSettingsWhereUniqueInput
  }

  /**
   * branchesSettings findFirst
   */
  export type branchesSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesSettings
     */
    select?: branchesSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesSettingsInclude<ExtArgs> | null
    /**
     * Filter, which branchesSettings to fetch.
     */
    where?: branchesSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branchesSettings to fetch.
     */
    orderBy?: branchesSettingsOrderByWithRelationInput | branchesSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for branchesSettings.
     */
    cursor?: branchesSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branchesSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branchesSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of branchesSettings.
     */
    distinct?: BranchesSettingsScalarFieldEnum | BranchesSettingsScalarFieldEnum[]
  }

  /**
   * branchesSettings findFirstOrThrow
   */
  export type branchesSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesSettings
     */
    select?: branchesSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesSettingsInclude<ExtArgs> | null
    /**
     * Filter, which branchesSettings to fetch.
     */
    where?: branchesSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branchesSettings to fetch.
     */
    orderBy?: branchesSettingsOrderByWithRelationInput | branchesSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for branchesSettings.
     */
    cursor?: branchesSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branchesSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branchesSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of branchesSettings.
     */
    distinct?: BranchesSettingsScalarFieldEnum | BranchesSettingsScalarFieldEnum[]
  }

  /**
   * branchesSettings findMany
   */
  export type branchesSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesSettings
     */
    select?: branchesSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesSettingsInclude<ExtArgs> | null
    /**
     * Filter, which branchesSettings to fetch.
     */
    where?: branchesSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branchesSettings to fetch.
     */
    orderBy?: branchesSettingsOrderByWithRelationInput | branchesSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing branchesSettings.
     */
    cursor?: branchesSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branchesSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branchesSettings.
     */
    skip?: number
    distinct?: BranchesSettingsScalarFieldEnum | BranchesSettingsScalarFieldEnum[]
  }

  /**
   * branchesSettings create
   */
  export type branchesSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesSettings
     */
    select?: branchesSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a branchesSettings.
     */
    data: XOR<branchesSettingsCreateInput, branchesSettingsUncheckedCreateInput>
  }

  /**
   * branchesSettings createMany
   */
  export type branchesSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many branchesSettings.
     */
    data: branchesSettingsCreateManyInput | branchesSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * branchesSettings update
   */
  export type branchesSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesSettings
     */
    select?: branchesSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a branchesSettings.
     */
    data: XOR<branchesSettingsUpdateInput, branchesSettingsUncheckedUpdateInput>
    /**
     * Choose, which branchesSettings to update.
     */
    where: branchesSettingsWhereUniqueInput
  }

  /**
   * branchesSettings updateMany
   */
  export type branchesSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update branchesSettings.
     */
    data: XOR<branchesSettingsUpdateManyMutationInput, branchesSettingsUncheckedUpdateManyInput>
    /**
     * Filter which branchesSettings to update
     */
    where?: branchesSettingsWhereInput
  }

  /**
   * branchesSettings upsert
   */
  export type branchesSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesSettings
     */
    select?: branchesSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the branchesSettings to update in case it exists.
     */
    where: branchesSettingsWhereUniqueInput
    /**
     * In case the branchesSettings found by the `where` argument doesn't exist, create a new branchesSettings with this data.
     */
    create: XOR<branchesSettingsCreateInput, branchesSettingsUncheckedCreateInput>
    /**
     * In case the branchesSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<branchesSettingsUpdateInput, branchesSettingsUncheckedUpdateInput>
  }

  /**
   * branchesSettings delete
   */
  export type branchesSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesSettings
     */
    select?: branchesSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesSettingsInclude<ExtArgs> | null
    /**
     * Filter which branchesSettings to delete.
     */
    where: branchesSettingsWhereUniqueInput
  }

  /**
   * branchesSettings deleteMany
   */
  export type branchesSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which branchesSettings to delete
     */
    where?: branchesSettingsWhereInput
  }

  /**
   * branchesSettings.Branches
   */
  export type branchesSettings$BranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * branchesSettings without action
   */
  export type branchesSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchesSettings
     */
    select?: branchesSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesSettingsInclude<ExtArgs> | null
  }


  /**
   * Model wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    Balance: number | null
  }

  export type WalletSumAggregateOutputType = {
    Balance: number | null
  }

  export type WalletMinAggregateOutputType = {
    ID: string | null
    Balance: number | null
    Title: string | null
    Description: string | null
    IsReal: boolean | null
    UserID: string | null
    Status: string | null
    Remask: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    ID: string | null
    Balance: number | null
    Title: string | null
    Description: string | null
    IsReal: boolean | null
    UserID: string | null
    Status: string | null
    Remask: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    ID: number
    Balance: number
    Title: number
    Description: number
    IsReal: number
    UserID: number
    Status: number
    Remask: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    Balance?: true
  }

  export type WalletSumAggregateInputType = {
    Balance?: true
  }

  export type WalletMinAggregateInputType = {
    ID?: true
    Balance?: true
    Title?: true
    Description?: true
    IsReal?: true
    UserID?: true
    Status?: true
    Remask?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type WalletMaxAggregateInputType = {
    ID?: true
    Balance?: true
    Title?: true
    Description?: true
    IsReal?: true
    UserID?: true
    Status?: true
    Remask?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type WalletCountAggregateInputType = {
    ID?: true
    Balance?: true
    Title?: true
    Description?: true
    IsReal?: true
    UserID?: true
    Status?: true
    Remask?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet to aggregate.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type walletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: walletWhereInput
    orderBy?: walletOrderByWithAggregationInput | walletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: walletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    ID: string
    Balance: number | null
    Title: string | null
    Description: string | null
    IsReal: boolean | null
    UserID: string | null
    Status: string | null
    Remask: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends walletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type walletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Balance?: boolean
    Title?: boolean
    Description?: boolean
    IsReal?: boolean
    UserID?: boolean
    Status?: boolean
    Remask?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    User?: boolean | wallet$UserArgs<ExtArgs>
    Receive?: boolean | wallet$ReceiveArgs<ExtArgs>
    Payment?: boolean | wallet$PaymentArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type walletSelectScalar = {
    ID?: boolean
    Balance?: boolean
    Title?: boolean
    Description?: boolean
    IsReal?: boolean
    UserID?: boolean
    Status?: boolean
    Remask?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type walletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | wallet$UserArgs<ExtArgs>
    Receive?: boolean | wallet$ReceiveArgs<ExtArgs>
    Payment?: boolean | wallet$PaymentArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $walletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wallet"
    objects: {
      User: Prisma.$usersPayload<ExtArgs> | null
      Receive: Prisma.$transactionPayload<ExtArgs>[]
      Payment: Prisma.$transactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Balance: number | null
      Title: string | null
      Description: string | null
      IsReal: boolean | null
      UserID: string | null
      Status: string | null
      Remask: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }


  type walletGetPayload<S extends boolean | null | undefined | walletDefaultArgs> = $Result.GetResult<Prisma.$walletPayload, S>

  type walletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<walletFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface walletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wallet'], meta: { name: 'wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {walletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends walletFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, walletFindUniqueArgs<ExtArgs>>
    ): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {walletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends walletFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, walletFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends walletFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, walletFindFirstArgs<ExtArgs>>
    ): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends walletFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, walletFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const walletWithIDOnly = await prisma.wallet.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends walletFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, walletFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Wallet.
     * @param {walletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
    **/
    create<T extends walletCreateArgs<ExtArgs>>(
      args: SelectSubset<T, walletCreateArgs<ExtArgs>>
    ): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Wallets.
     * @param {walletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends walletCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, walletCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet.
     * @param {walletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
    **/
    delete<T extends walletDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, walletDeleteArgs<ExtArgs>>
    ): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Wallet.
     * @param {walletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends walletUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, walletUpdateArgs<ExtArgs>>
    ): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Wallets.
     * @param {walletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends walletDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, walletDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends walletUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, walletUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet.
     * @param {walletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
    **/
    upsert<T extends walletUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, walletUpsertArgs<ExtArgs>>
    ): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends walletCountArgs>(
      args?: Subset<T, walletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends walletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: walletGroupByArgs['orderBy'] }
        : { orderBy?: walletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, walletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wallet model
   */
  readonly fields: walletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__walletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    User<T extends wallet$UserArgs<ExtArgs> = {}>(args?: Subset<T, wallet$UserArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Receive<T extends wallet$ReceiveArgs<ExtArgs> = {}>(args?: Subset<T, wallet$ReceiveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    Payment<T extends wallet$PaymentArgs<ExtArgs> = {}>(args?: Subset<T, wallet$PaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the wallet model
   */ 
  interface walletFieldRefs {
    readonly ID: FieldRef<"wallet", 'String'>
    readonly Balance: FieldRef<"wallet", 'Float'>
    readonly Title: FieldRef<"wallet", 'String'>
    readonly Description: FieldRef<"wallet", 'String'>
    readonly IsReal: FieldRef<"wallet", 'Boolean'>
    readonly UserID: FieldRef<"wallet", 'String'>
    readonly Status: FieldRef<"wallet", 'String'>
    readonly Remask: FieldRef<"wallet", 'String'>
    readonly IsActive: FieldRef<"wallet", 'Boolean'>
    readonly CreatedAt: FieldRef<"wallet", 'DateTime'>
    readonly UpdatedAt: FieldRef<"wallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * wallet findUnique
   */
  export type walletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where: walletWhereUniqueInput
  }

  /**
   * wallet findUniqueOrThrow
   */
  export type walletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where: walletWhereUniqueInput
  }

  /**
   * wallet findFirst
   */
  export type walletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * wallet findFirstOrThrow
   */
  export type walletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * wallet findMany
   */
  export type walletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallets to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * wallet create
   */
  export type walletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * The data needed to create a wallet.
     */
    data?: XOR<walletCreateInput, walletUncheckedCreateInput>
  }

  /**
   * wallet createMany
   */
  export type walletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wallets.
     */
    data: walletCreateManyInput | walletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wallet update
   */
  export type walletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * The data needed to update a wallet.
     */
    data: XOR<walletUpdateInput, walletUncheckedUpdateInput>
    /**
     * Choose, which wallet to update.
     */
    where: walletWhereUniqueInput
  }

  /**
   * wallet updateMany
   */
  export type walletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wallets.
     */
    data: XOR<walletUpdateManyMutationInput, walletUncheckedUpdateManyInput>
    /**
     * Filter which wallets to update
     */
    where?: walletWhereInput
  }

  /**
   * wallet upsert
   */
  export type walletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * The filter to search for the wallet to update in case it exists.
     */
    where: walletWhereUniqueInput
    /**
     * In case the wallet found by the `where` argument doesn't exist, create a new wallet with this data.
     */
    create: XOR<walletCreateInput, walletUncheckedCreateInput>
    /**
     * In case the wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<walletUpdateInput, walletUncheckedUpdateInput>
  }

  /**
   * wallet delete
   */
  export type walletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter which wallet to delete.
     */
    where: walletWhereUniqueInput
  }

  /**
   * wallet deleteMany
   */
  export type walletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallets to delete
     */
    where?: walletWhereInput
  }

  /**
   * wallet.User
   */
  export type wallet$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * wallet.Receive
   */
  export type wallet$ReceiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    where?: transactionWhereInput
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    cursor?: transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * wallet.Payment
   */
  export type wallet$PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    where?: transactionWhereInput
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    cursor?: transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * wallet without action
   */
  export type walletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
  }


  /**
   * Model transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    Result: number | null
    Balance: number | null
  }

  export type TransactionSumAggregateOutputType = {
    Result: number | null
    Balance: number | null
  }

  export type TransactionMinAggregateOutputType = {
    ID: string | null
    Type: string | null
    Info: string | null
    Status: string | null
    Result: number | null
    Balance: number | null
    IsPayment: boolean | null
    IsReceived: boolean | null
    OrderPaymentID: string | null
    PaidByID: string | null
    PaidToID: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    ID: string | null
    Type: string | null
    Info: string | null
    Status: string | null
    Result: number | null
    Balance: number | null
    IsPayment: boolean | null
    IsReceived: boolean | null
    OrderPaymentID: string | null
    PaidByID: string | null
    PaidToID: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    ID: number
    Type: number
    Info: number
    Status: number
    Result: number
    Balance: number
    IsPayment: number
    IsReceived: number
    OrderPaymentID: number
    PaidByID: number
    PaidToID: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    Result?: true
    Balance?: true
  }

  export type TransactionSumAggregateInputType = {
    Result?: true
    Balance?: true
  }

  export type TransactionMinAggregateInputType = {
    ID?: true
    Type?: true
    Info?: true
    Status?: true
    Result?: true
    Balance?: true
    IsPayment?: true
    IsReceived?: true
    OrderPaymentID?: true
    PaidByID?: true
    PaidToID?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    ID?: true
    Type?: true
    Info?: true
    Status?: true
    Result?: true
    Balance?: true
    IsPayment?: true
    IsReceived?: true
    OrderPaymentID?: true
    PaidByID?: true
    PaidToID?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    ID?: true
    Type?: true
    Info?: true
    Status?: true
    Result?: true
    Balance?: true
    IsPayment?: true
    IsReceived?: true
    OrderPaymentID?: true
    PaidByID?: true
    PaidToID?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaction to aggregate.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type transactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionWhereInput
    orderBy?: transactionOrderByWithAggregationInput | transactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: transactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    ID: string
    Type: string | null
    Info: string | null
    Status: string | null
    Result: number | null
    Balance: number | null
    IsPayment: boolean | null
    IsReceived: boolean | null
    OrderPaymentID: string | null
    PaidByID: string | null
    PaidToID: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends transactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type transactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Type?: boolean
    Info?: boolean
    Status?: boolean
    Result?: boolean
    Balance?: boolean
    IsPayment?: boolean
    IsReceived?: boolean
    OrderPaymentID?: boolean
    PaidByID?: boolean
    PaidToID?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    OrderPayment?: boolean | transaction$OrderPaymentArgs<ExtArgs>
    PaidBy?: boolean | transaction$PaidByArgs<ExtArgs>
    PaidTo?: boolean | transaction$PaidToArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type transactionSelectScalar = {
    ID?: boolean
    Type?: boolean
    Info?: boolean
    Status?: boolean
    Result?: boolean
    Balance?: boolean
    IsPayment?: boolean
    IsReceived?: boolean
    OrderPaymentID?: boolean
    PaidByID?: boolean
    PaidToID?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type transactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderPayment?: boolean | transaction$OrderPaymentArgs<ExtArgs>
    PaidBy?: boolean | transaction$PaidByArgs<ExtArgs>
    PaidTo?: boolean | transaction$PaidToArgs<ExtArgs>
  }


  export type $transactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transaction"
    objects: {
      OrderPayment: Prisma.$orderPaymentPayload<ExtArgs> | null
      PaidBy: Prisma.$walletPayload<ExtArgs> | null
      PaidTo: Prisma.$walletPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Type: string | null
      Info: string | null
      Status: string | null
      Result: number | null
      Balance: number | null
      IsPayment: boolean | null
      IsReceived: boolean | null
      OrderPaymentID: string | null
      PaidByID: string | null
      PaidToID: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }


  type transactionGetPayload<S extends boolean | null | undefined | transactionDefaultArgs> = $Result.GetResult<Prisma.$transactionPayload, S>

  type transactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<transactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface transactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transaction'], meta: { name: 'transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {transactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends transactionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, transactionFindUniqueArgs<ExtArgs>>
    ): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {transactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends transactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends transactionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionFindFirstArgs<ExtArgs>>
    ): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends transactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const transactionWithIDOnly = await prisma.transaction.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends transactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Transaction.
     * @param {transactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
    **/
    create<T extends transactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, transactionCreateArgs<ExtArgs>>
    ): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {transactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends transactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {transactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
    **/
    delete<T extends transactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, transactionDeleteArgs<ExtArgs>>
    ): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {transactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends transactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, transactionUpdateArgs<ExtArgs>>
    ): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {transactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends transactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends transactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, transactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {transactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
    **/
    upsert<T extends transactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, transactionUpsertArgs<ExtArgs>>
    ): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends transactionCountArgs>(
      args?: Subset<T, transactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transactionGroupByArgs['orderBy'] }
        : { orderBy?: transactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transaction model
   */
  readonly fields: transactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    OrderPayment<T extends transaction$OrderPaymentArgs<ExtArgs> = {}>(args?: Subset<T, transaction$OrderPaymentArgs<ExtArgs>>): Prisma__orderPaymentClient<$Result.GetResult<Prisma.$orderPaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    PaidBy<T extends transaction$PaidByArgs<ExtArgs> = {}>(args?: Subset<T, transaction$PaidByArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    PaidTo<T extends transaction$PaidToArgs<ExtArgs> = {}>(args?: Subset<T, transaction$PaidToArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the transaction model
   */ 
  interface transactionFieldRefs {
    readonly ID: FieldRef<"transaction", 'String'>
    readonly Type: FieldRef<"transaction", 'String'>
    readonly Info: FieldRef<"transaction", 'String'>
    readonly Status: FieldRef<"transaction", 'String'>
    readonly Result: FieldRef<"transaction", 'Float'>
    readonly Balance: FieldRef<"transaction", 'Float'>
    readonly IsPayment: FieldRef<"transaction", 'Boolean'>
    readonly IsReceived: FieldRef<"transaction", 'Boolean'>
    readonly OrderPaymentID: FieldRef<"transaction", 'String'>
    readonly PaidByID: FieldRef<"transaction", 'String'>
    readonly PaidToID: FieldRef<"transaction", 'String'>
    readonly IsActive: FieldRef<"transaction", 'Boolean'>
    readonly CreatedAt: FieldRef<"transaction", 'DateTime'>
    readonly UpdatedAt: FieldRef<"transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * transaction findUnique
   */
  export type transactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction findUniqueOrThrow
   */
  export type transactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction findFirst
   */
  export type transactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction findFirstOrThrow
   */
  export type transactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction findMany
   */
  export type transactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction create
   */
  export type transactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The data needed to create a transaction.
     */
    data?: XOR<transactionCreateInput, transactionUncheckedCreateInput>
  }

  /**
   * transaction createMany
   */
  export type transactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transactions.
     */
    data: transactionCreateManyInput | transactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transaction update
   */
  export type transactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The data needed to update a transaction.
     */
    data: XOR<transactionUpdateInput, transactionUncheckedUpdateInput>
    /**
     * Choose, which transaction to update.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction updateMany
   */
  export type transactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionWhereInput
  }

  /**
   * transaction upsert
   */
  export type transactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The filter to search for the transaction to update in case it exists.
     */
    where: transactionWhereUniqueInput
    /**
     * In case the transaction found by the `where` argument doesn't exist, create a new transaction with this data.
     */
    create: XOR<transactionCreateInput, transactionUncheckedCreateInput>
    /**
     * In case the transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionUpdateInput, transactionUncheckedUpdateInput>
  }

  /**
   * transaction delete
   */
  export type transactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter which transaction to delete.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction deleteMany
   */
  export type transactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to delete
     */
    where?: transactionWhereInput
  }

  /**
   * transaction.OrderPayment
   */
  export type transaction$OrderPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPayment
     */
    select?: orderPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPaymentInclude<ExtArgs> | null
    where?: orderPaymentWhereInput
  }

  /**
   * transaction.PaidBy
   */
  export type transaction$PaidByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    where?: walletWhereInput
  }

  /**
   * transaction.PaidTo
   */
  export type transaction$PaidToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    where?: walletWhereInput
  }

  /**
   * transaction without action
   */
  export type transactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    ID: string | null
    UserName: string | null
    Password: string | null
    URL: string | null
    PhoneNumber: string | null
    Email: string | null
    Pin: string | null
    IsRemember: boolean | null
    IsPin: boolean | null
    IsBiometric: boolean | null
    Status: string | null
    Remask: string | null
    LastActive: Date | null
    BranchesID: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    ID: string | null
    UserName: string | null
    Password: string | null
    URL: string | null
    PhoneNumber: string | null
    Email: string | null
    Pin: string | null
    IsRemember: boolean | null
    IsPin: boolean | null
    IsBiometric: boolean | null
    Status: string | null
    Remask: string | null
    LastActive: Date | null
    BranchesID: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    ID: number
    UserName: number
    Password: number
    URL: number
    PhoneNumber: number
    Email: number
    Pin: number
    IsRemember: number
    IsPin: number
    IsBiometric: number
    Status: number
    Remask: number
    LastActive: number
    BranchesID: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    ID?: true
    UserName?: true
    Password?: true
    URL?: true
    PhoneNumber?: true
    Email?: true
    Pin?: true
    IsRemember?: true
    IsPin?: true
    IsBiometric?: true
    Status?: true
    Remask?: true
    LastActive?: true
    BranchesID?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    ID?: true
    UserName?: true
    Password?: true
    URL?: true
    PhoneNumber?: true
    Email?: true
    Pin?: true
    IsRemember?: true
    IsPin?: true
    IsBiometric?: true
    Status?: true
    Remask?: true
    LastActive?: true
    BranchesID?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    ID?: true
    UserName?: true
    Password?: true
    URL?: true
    PhoneNumber?: true
    Email?: true
    Pin?: true
    IsRemember?: true
    IsPin?: true
    IsBiometric?: true
    Status?: true
    Remask?: true
    LastActive?: true
    BranchesID?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    ID: string
    UserName: string
    Password: string
    URL: string | null
    PhoneNumber: string
    Email: string | null
    Pin: string | null
    IsRemember: boolean | null
    IsPin: boolean | null
    IsBiometric: boolean | null
    Status: string | null
    Remask: string | null
    LastActive: Date | null
    BranchesID: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    UserName?: boolean
    Password?: boolean
    URL?: boolean
    PhoneNumber?: boolean
    Email?: boolean
    Pin?: boolean
    IsRemember?: boolean
    IsPin?: boolean
    IsBiometric?: boolean
    Status?: boolean
    Remask?: boolean
    LastActive?: boolean
    BranchesID?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Branches?: boolean | users$BranchesArgs<ExtArgs>
    Wallet?: boolean | users$WalletArgs<ExtArgs>
    RecipientPayment?: boolean | users$RecipientPaymentArgs<ExtArgs>
    AdminProfile?: boolean | users$AdminProfileArgs<ExtArgs>
    UserProfile?: boolean | users$UserProfileArgs<ExtArgs>
    OTP?: boolean | users$OTPArgs<ExtArgs>
    Roles?: boolean | users$RolesArgs<ExtArgs>
    Forgot?: boolean | users$ForgotArgs<ExtArgs>
    Notifications?: boolean | users$NotificationsArgs<ExtArgs>
    Activities?: boolean | users$ActivitiesArgs<ExtArgs>
    Order?: boolean | users$OrderArgs<ExtArgs>
    SenderOrder?: boolean | users$SenderOrderArgs<ExtArgs>
    RecipientOrder?: boolean | users$RecipientOrderArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    ID?: boolean
    UserName?: boolean
    Password?: boolean
    URL?: boolean
    PhoneNumber?: boolean
    Email?: boolean
    Pin?: boolean
    IsRemember?: boolean
    IsPin?: boolean
    IsBiometric?: boolean
    Status?: boolean
    Remask?: boolean
    LastActive?: boolean
    BranchesID?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Branches?: boolean | users$BranchesArgs<ExtArgs>
    Wallet?: boolean | users$WalletArgs<ExtArgs>
    RecipientPayment?: boolean | users$RecipientPaymentArgs<ExtArgs>
    AdminProfile?: boolean | users$AdminProfileArgs<ExtArgs>
    UserProfile?: boolean | users$UserProfileArgs<ExtArgs>
    OTP?: boolean | users$OTPArgs<ExtArgs>
    Roles?: boolean | users$RolesArgs<ExtArgs>
    Forgot?: boolean | users$ForgotArgs<ExtArgs>
    Notifications?: boolean | users$NotificationsArgs<ExtArgs>
    Activities?: boolean | users$ActivitiesArgs<ExtArgs>
    Order?: boolean | users$OrderArgs<ExtArgs>
    SenderOrder?: boolean | users$SenderOrderArgs<ExtArgs>
    RecipientOrder?: boolean | users$RecipientOrderArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      Branches: Prisma.$branchesPayload<ExtArgs> | null
      Wallet: Prisma.$walletPayload<ExtArgs>[]
      RecipientPayment: Prisma.$orderPaymentPayload<ExtArgs>[]
      AdminProfile: Prisma.$profilePayload<ExtArgs>[]
      UserProfile: Prisma.$profilePayload<ExtArgs> | null
      OTP: Prisma.$otpPayload<ExtArgs>[]
      Roles: Prisma.$usersRolesPayload<ExtArgs>[]
      Forgot: Prisma.$forgotPasswordPayload<ExtArgs>[]
      Notifications: Prisma.$notificationsPayload<ExtArgs>[]
      Activities: Prisma.$usersActivitiesPayload<ExtArgs>[]
      Order: Prisma.$orderPayload<ExtArgs>[]
      SenderOrder: Prisma.$orderPersonalPayload<ExtArgs>[]
      RecipientOrder: Prisma.$orderPersonalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      UserName: string
      Password: string
      URL: string | null
      PhoneNumber: string
      Email: string | null
      Pin: string | null
      IsRemember: boolean | null
      IsPin: boolean | null
      IsBiometric: boolean | null
      Status: string | null
      Remask: string | null
      LastActive: Date | null
      BranchesID: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }


  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const usersWithIDOnly = await prisma.users.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, usersCreateArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends usersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, usersDeleteArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpsertArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Branches<T extends users$BranchesArgs<ExtArgs> = {}>(args?: Subset<T, users$BranchesArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Wallet<T extends users$WalletArgs<ExtArgs> = {}>(args?: Subset<T, users$WalletArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, 'findMany'> | Null>;

    RecipientPayment<T extends users$RecipientPaymentArgs<ExtArgs> = {}>(args?: Subset<T, users$RecipientPaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    AdminProfile<T extends users$AdminProfileArgs<ExtArgs> = {}>(args?: Subset<T, users$AdminProfileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'findMany'> | Null>;

    UserProfile<T extends users$UserProfileArgs<ExtArgs> = {}>(args?: Subset<T, users$UserProfileArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    OTP<T extends users$OTPArgs<ExtArgs> = {}>(args?: Subset<T, users$OTPArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'findMany'> | Null>;

    Roles<T extends users$RolesArgs<ExtArgs> = {}>(args?: Subset<T, users$RolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersRolesPayload<ExtArgs>, T, 'findMany'> | Null>;

    Forgot<T extends users$ForgotArgs<ExtArgs> = {}>(args?: Subset<T, users$ForgotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forgotPasswordPayload<ExtArgs>, T, 'findMany'> | Null>;

    Notifications<T extends users$NotificationsArgs<ExtArgs> = {}>(args?: Subset<T, users$NotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Activities<T extends users$ActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, users$ActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersActivitiesPayload<ExtArgs>, T, 'findMany'> | Null>;

    Order<T extends users$OrderArgs<ExtArgs> = {}>(args?: Subset<T, users$OrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findMany'> | Null>;

    SenderOrder<T extends users$SenderOrderArgs<ExtArgs> = {}>(args?: Subset<T, users$SenderOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPersonalPayload<ExtArgs>, T, 'findMany'> | Null>;

    RecipientOrder<T extends users$RecipientOrderArgs<ExtArgs> = {}>(args?: Subset<T, users$RecipientOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPersonalPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly ID: FieldRef<"users", 'String'>
    readonly UserName: FieldRef<"users", 'String'>
    readonly Password: FieldRef<"users", 'String'>
    readonly URL: FieldRef<"users", 'String'>
    readonly PhoneNumber: FieldRef<"users", 'String'>
    readonly Email: FieldRef<"users", 'String'>
    readonly Pin: FieldRef<"users", 'String'>
    readonly IsRemember: FieldRef<"users", 'Boolean'>
    readonly IsPin: FieldRef<"users", 'Boolean'>
    readonly IsBiometric: FieldRef<"users", 'Boolean'>
    readonly Status: FieldRef<"users", 'String'>
    readonly Remask: FieldRef<"users", 'String'>
    readonly LastActive: FieldRef<"users", 'DateTime'>
    readonly BranchesID: FieldRef<"users", 'String'>
    readonly IsActive: FieldRef<"users", 'Boolean'>
    readonly CreatedAt: FieldRef<"users", 'DateTime'>
    readonly UpdatedAt: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users.Branches
   */
  export type users$BranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * users.Wallet
   */
  export type users$WalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    where?: walletWhereInput
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    cursor?: walletWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * users.RecipientPayment
   */
  export type users$RecipientPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPayment
     */
    select?: orderPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPaymentInclude<ExtArgs> | null
    where?: orderPaymentWhereInput
    orderBy?: orderPaymentOrderByWithRelationInput | orderPaymentOrderByWithRelationInput[]
    cursor?: orderPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderPaymentScalarFieldEnum | OrderPaymentScalarFieldEnum[]
  }

  /**
   * users.AdminProfile
   */
  export type users$AdminProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    where?: profileWhereInput
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    cursor?: profileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * users.UserProfile
   */
  export type users$UserProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    where?: profileWhereInput
  }

  /**
   * users.OTP
   */
  export type users$OTPArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    where?: otpWhereInput
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    cursor?: otpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * users.Roles
   */
  export type users$RolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersRoles
     */
    select?: usersRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersRolesInclude<ExtArgs> | null
    where?: usersRolesWhereInput
    orderBy?: usersRolesOrderByWithRelationInput | usersRolesOrderByWithRelationInput[]
    cursor?: usersRolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersRolesScalarFieldEnum | UsersRolesScalarFieldEnum[]
  }

  /**
   * users.Forgot
   */
  export type users$ForgotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forgotPassword
     */
    select?: forgotPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forgotPasswordInclude<ExtArgs> | null
    where?: forgotPasswordWhereInput
    orderBy?: forgotPasswordOrderByWithRelationInput | forgotPasswordOrderByWithRelationInput[]
    cursor?: forgotPasswordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForgotPasswordScalarFieldEnum | ForgotPasswordScalarFieldEnum[]
  }

  /**
   * users.Notifications
   */
  export type users$NotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * users.Activities
   */
  export type users$ActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersActivities
     */
    select?: usersActivitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersActivitiesInclude<ExtArgs> | null
    where?: usersActivitiesWhereInput
    orderBy?: usersActivitiesOrderByWithRelationInput | usersActivitiesOrderByWithRelationInput[]
    cursor?: usersActivitiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersActivitiesScalarFieldEnum | UsersActivitiesScalarFieldEnum[]
  }

  /**
   * users.Order
   */
  export type users$OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    cursor?: orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * users.SenderOrder
   */
  export type users$SenderOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPersonal
     */
    select?: orderPersonalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPersonalInclude<ExtArgs> | null
    where?: orderPersonalWhereInput
    orderBy?: orderPersonalOrderByWithRelationInput | orderPersonalOrderByWithRelationInput[]
    cursor?: orderPersonalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderPersonalScalarFieldEnum | OrderPersonalScalarFieldEnum[]
  }

  /**
   * users.RecipientOrder
   */
  export type users$RecipientOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPersonal
     */
    select?: orderPersonalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPersonalInclude<ExtArgs> | null
    where?: orderPersonalWhereInput
    orderBy?: orderPersonalOrderByWithRelationInput | orderPersonalOrderByWithRelationInput[]
    cursor?: orderPersonalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderPersonalScalarFieldEnum | OrderPersonalScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    ID: string | null
    Gender: string | null
    Name: string | null
    SurName: string | null
    ProfileURL: string | null
    UserID: string | null
    AdminID: string | null
    AdminPin: string | null
    Remask: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    ID: string | null
    Gender: string | null
    Name: string | null
    SurName: string | null
    ProfileURL: string | null
    UserID: string | null
    AdminID: string | null
    AdminPin: string | null
    Remask: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    ID: number
    Gender: number
    Name: number
    SurName: number
    ProfileURL: number
    UserID: number
    AdminID: number
    AdminPin: number
    Remask: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    ID?: true
    Gender?: true
    Name?: true
    SurName?: true
    ProfileURL?: true
    UserID?: true
    AdminID?: true
    AdminPin?: true
    Remask?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    ID?: true
    Gender?: true
    Name?: true
    SurName?: true
    ProfileURL?: true
    UserID?: true
    AdminID?: true
    AdminPin?: true
    Remask?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    ID?: true
    Gender?: true
    Name?: true
    SurName?: true
    ProfileURL?: true
    UserID?: true
    AdminID?: true
    AdminPin?: true
    Remask?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profile to aggregate.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type profileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profileWhereInput
    orderBy?: profileOrderByWithAggregationInput | profileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: profileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    ID: string
    Gender: string | null
    Name: string
    SurName: string
    ProfileURL: string | null
    UserID: string | null
    AdminID: string | null
    AdminPin: string | null
    Remask: string | null
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends profileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type profileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Gender?: boolean
    Name?: boolean
    SurName?: boolean
    ProfileURL?: boolean
    UserID?: boolean
    AdminID?: boolean
    AdminPin?: boolean
    Remask?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    User?: boolean | profile$UserArgs<ExtArgs>
    Admin?: boolean | profile$AdminArgs<ExtArgs>
    Address?: boolean | profile$AddressArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type profileSelectScalar = {
    ID?: boolean
    Gender?: boolean
    Name?: boolean
    SurName?: boolean
    ProfileURL?: boolean
    UserID?: boolean
    AdminID?: boolean
    AdminPin?: boolean
    Remask?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type profileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | profile$UserArgs<ExtArgs>
    Admin?: boolean | profile$AdminArgs<ExtArgs>
    Address?: boolean | profile$AddressArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $profilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "profile"
    objects: {
      User: Prisma.$usersPayload<ExtArgs> | null
      Admin: Prisma.$usersPayload<ExtArgs> | null
      Address: Prisma.$addressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Gender: string | null
      Name: string
      SurName: string
      ProfileURL: string | null
      UserID: string | null
      AdminID: string | null
      AdminPin: string | null
      Remask: string | null
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }


  type profileGetPayload<S extends boolean | null | undefined | profileDefaultArgs> = $Result.GetResult<Prisma.$profilePayload, S>

  type profileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<profileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface profileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['profile'], meta: { name: 'profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {profileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends profileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, profileFindUniqueArgs<ExtArgs>>
    ): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {profileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends profileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, profileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends profileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, profileFindFirstArgs<ExtArgs>>
    ): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends profileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, profileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const profileWithIDOnly = await prisma.profile.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends profileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, profileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Profile.
     * @param {profileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
    **/
    create<T extends profileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, profileCreateArgs<ExtArgs>>
    ): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {profileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends profileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, profileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Profile.
     * @param {profileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
    **/
    delete<T extends profileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, profileDeleteArgs<ExtArgs>>
    ): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {profileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends profileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, profileUpdateArgs<ExtArgs>>
    ): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {profileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends profileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, profileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends profileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, profileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {profileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
    **/
    upsert<T extends profileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, profileUpsertArgs<ExtArgs>>
    ): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends profileCountArgs>(
      args?: Subset<T, profileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends profileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: profileGroupByArgs['orderBy'] }
        : { orderBy?: profileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, profileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the profile model
   */
  readonly fields: profileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__profileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    User<T extends profile$UserArgs<ExtArgs> = {}>(args?: Subset<T, profile$UserArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Admin<T extends profile$AdminArgs<ExtArgs> = {}>(args?: Subset<T, profile$AdminArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Address<T extends profile$AddressArgs<ExtArgs> = {}>(args?: Subset<T, profile$AddressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the profile model
   */ 
  interface profileFieldRefs {
    readonly ID: FieldRef<"profile", 'String'>
    readonly Gender: FieldRef<"profile", 'String'>
    readonly Name: FieldRef<"profile", 'String'>
    readonly SurName: FieldRef<"profile", 'String'>
    readonly ProfileURL: FieldRef<"profile", 'String'>
    readonly UserID: FieldRef<"profile", 'String'>
    readonly AdminID: FieldRef<"profile", 'String'>
    readonly AdminPin: FieldRef<"profile", 'String'>
    readonly Remask: FieldRef<"profile", 'String'>
    readonly Status: FieldRef<"profile", 'String'>
    readonly IsActive: FieldRef<"profile", 'Boolean'>
    readonly CreatedAt: FieldRef<"profile", 'DateTime'>
    readonly UpdatedAt: FieldRef<"profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * profile findUnique
   */
  export type profileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile findUniqueOrThrow
   */
  export type profileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile findFirst
   */
  export type profileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * profile findFirstOrThrow
   */
  export type profileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * profile findMany
   */
  export type profileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profiles to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * profile create
   */
  export type profileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The data needed to create a profile.
     */
    data: XOR<profileCreateInput, profileUncheckedCreateInput>
  }

  /**
   * profile createMany
   */
  export type profileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many profiles.
     */
    data: profileCreateManyInput | profileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * profile update
   */
  export type profileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The data needed to update a profile.
     */
    data: XOR<profileUpdateInput, profileUncheckedUpdateInput>
    /**
     * Choose, which profile to update.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile updateMany
   */
  export type profileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update profiles.
     */
    data: XOR<profileUpdateManyMutationInput, profileUncheckedUpdateManyInput>
    /**
     * Filter which profiles to update
     */
    where?: profileWhereInput
  }

  /**
   * profile upsert
   */
  export type profileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The filter to search for the profile to update in case it exists.
     */
    where: profileWhereUniqueInput
    /**
     * In case the profile found by the `where` argument doesn't exist, create a new profile with this data.
     */
    create: XOR<profileCreateInput, profileUncheckedCreateInput>
    /**
     * In case the profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<profileUpdateInput, profileUncheckedUpdateInput>
  }

  /**
   * profile delete
   */
  export type profileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter which profile to delete.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile deleteMany
   */
  export type profileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profiles to delete
     */
    where?: profileWhereInput
  }

  /**
   * profile.User
   */
  export type profile$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * profile.Admin
   */
  export type profile$AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * profile.Address
   */
  export type profile$AddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: addressInclude<ExtArgs> | null
    where?: addressWhereInput
    orderBy?: addressOrderByWithRelationInput | addressOrderByWithRelationInput[]
    cursor?: addressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * profile without action
   */
  export type profileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
  }


  /**
   * Model otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpMinAggregateOutputType = {
    ID: string | null
    OTP: string | null
    IsVerify: boolean | null
    UserName: string | null
    Type: string | null
    Remask: string | null
    UsersID: string | null
    BranchesID: string | null
    SmsGatewayUUID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OtpMaxAggregateOutputType = {
    ID: string | null
    OTP: string | null
    IsVerify: boolean | null
    UserName: string | null
    Type: string | null
    Remask: string | null
    UsersID: string | null
    BranchesID: string | null
    SmsGatewayUUID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OtpCountAggregateOutputType = {
    ID: number
    OTP: number
    IsVerify: number
    UserName: number
    Type: number
    Remask: number
    UsersID: number
    BranchesID: number
    SmsGatewayUUID: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type OtpMinAggregateInputType = {
    ID?: true
    OTP?: true
    IsVerify?: true
    UserName?: true
    Type?: true
    Remask?: true
    UsersID?: true
    BranchesID?: true
    SmsGatewayUUID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OtpMaxAggregateInputType = {
    ID?: true
    OTP?: true
    IsVerify?: true
    UserName?: true
    Type?: true
    Remask?: true
    UsersID?: true
    BranchesID?: true
    SmsGatewayUUID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OtpCountAggregateInputType = {
    ID?: true
    OTP?: true
    IsVerify?: true
    UserName?: true
    Type?: true
    Remask?: true
    UsersID?: true
    BranchesID?: true
    SmsGatewayUUID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which otp to aggregate.
     */
    where?: otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type otpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: otpWhereInput
    orderBy?: otpOrderByWithAggregationInput | otpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: otpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    ID: string
    OTP: string | null
    IsVerify: boolean
    UserName: string
    Type: string | null
    Remask: string | null
    UsersID: string | null
    BranchesID: string | null
    SmsGatewayUUID: string | null
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends otpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type otpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    OTP?: boolean
    IsVerify?: boolean
    UserName?: boolean
    Type?: boolean
    Remask?: boolean
    UsersID?: boolean
    BranchesID?: boolean
    SmsGatewayUUID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Users?: boolean | otp$UsersArgs<ExtArgs>
    Branches?: boolean | otp$BranchesArgs<ExtArgs>
  }, ExtArgs["result"]["otp"]>

  export type otpSelectScalar = {
    ID?: boolean
    OTP?: boolean
    IsVerify?: boolean
    UserName?: boolean
    Type?: boolean
    Remask?: boolean
    UsersID?: boolean
    BranchesID?: boolean
    SmsGatewayUUID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type otpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | otp$UsersArgs<ExtArgs>
    Branches?: boolean | otp$BranchesArgs<ExtArgs>
  }


  export type $otpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "otp"
    objects: {
      Users: Prisma.$usersPayload<ExtArgs> | null
      Branches: Prisma.$branchesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      OTP: string | null
      IsVerify: boolean
      UserName: string
      Type: string | null
      Remask: string | null
      UsersID: string | null
      BranchesID: string | null
      SmsGatewayUUID: string | null
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }


  type otpGetPayload<S extends boolean | null | undefined | otpDefaultArgs> = $Result.GetResult<Prisma.$otpPayload, S>

  type otpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<otpFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface otpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['otp'], meta: { name: 'otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {otpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends otpFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, otpFindUniqueArgs<ExtArgs>>
    ): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Otp that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {otpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends otpFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, otpFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends otpFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, otpFindFirstArgs<ExtArgs>>
    ): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends otpFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, otpFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const otpWithIDOnly = await prisma.otp.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends otpFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, otpFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Otp.
     * @param {otpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
    **/
    create<T extends otpCreateArgs<ExtArgs>>(
      args: SelectSubset<T, otpCreateArgs<ExtArgs>>
    ): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Otps.
     * @param {otpCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends otpCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, otpCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Otp.
     * @param {otpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
    **/
    delete<T extends otpDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, otpDeleteArgs<ExtArgs>>
    ): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Otp.
     * @param {otpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends otpUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, otpUpdateArgs<ExtArgs>>
    ): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Otps.
     * @param {otpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends otpDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, otpDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends otpUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, otpUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Otp.
     * @param {otpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
    **/
    upsert<T extends otpUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, otpUpsertArgs<ExtArgs>>
    ): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends otpCountArgs>(
      args?: Subset<T, otpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends otpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: otpGroupByArgs['orderBy'] }
        : { orderBy?: otpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, otpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the otp model
   */
  readonly fields: otpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__otpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Users<T extends otp$UsersArgs<ExtArgs> = {}>(args?: Subset<T, otp$UsersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Branches<T extends otp$BranchesArgs<ExtArgs> = {}>(args?: Subset<T, otp$BranchesArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the otp model
   */ 
  interface otpFieldRefs {
    readonly ID: FieldRef<"otp", 'String'>
    readonly OTP: FieldRef<"otp", 'String'>
    readonly IsVerify: FieldRef<"otp", 'Boolean'>
    readonly UserName: FieldRef<"otp", 'String'>
    readonly Type: FieldRef<"otp", 'String'>
    readonly Remask: FieldRef<"otp", 'String'>
    readonly UsersID: FieldRef<"otp", 'String'>
    readonly BranchesID: FieldRef<"otp", 'String'>
    readonly SmsGatewayUUID: FieldRef<"otp", 'String'>
    readonly Status: FieldRef<"otp", 'String'>
    readonly IsActive: FieldRef<"otp", 'Boolean'>
    readonly CreatedAt: FieldRef<"otp", 'DateTime'>
    readonly UpdatedAt: FieldRef<"otp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * otp findUnique
   */
  export type otpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter, which otp to fetch.
     */
    where: otpWhereUniqueInput
  }

  /**
   * otp findUniqueOrThrow
   */
  export type otpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter, which otp to fetch.
     */
    where: otpWhereUniqueInput
  }

  /**
   * otp findFirst
   */
  export type otpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter, which otp to fetch.
     */
    where?: otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for otps.
     */
    cursor?: otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * otp findFirstOrThrow
   */
  export type otpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter, which otp to fetch.
     */
    where?: otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for otps.
     */
    cursor?: otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * otp findMany
   */
  export type otpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter, which otps to fetch.
     */
    where?: otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing otps.
     */
    cursor?: otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * otp create
   */
  export type otpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * The data needed to create a otp.
     */
    data: XOR<otpCreateInput, otpUncheckedCreateInput>
  }

  /**
   * otp createMany
   */
  export type otpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many otps.
     */
    data: otpCreateManyInput | otpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * otp update
   */
  export type otpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * The data needed to update a otp.
     */
    data: XOR<otpUpdateInput, otpUncheckedUpdateInput>
    /**
     * Choose, which otp to update.
     */
    where: otpWhereUniqueInput
  }

  /**
   * otp updateMany
   */
  export type otpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update otps.
     */
    data: XOR<otpUpdateManyMutationInput, otpUncheckedUpdateManyInput>
    /**
     * Filter which otps to update
     */
    where?: otpWhereInput
  }

  /**
   * otp upsert
   */
  export type otpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * The filter to search for the otp to update in case it exists.
     */
    where: otpWhereUniqueInput
    /**
     * In case the otp found by the `where` argument doesn't exist, create a new otp with this data.
     */
    create: XOR<otpCreateInput, otpUncheckedCreateInput>
    /**
     * In case the otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<otpUpdateInput, otpUncheckedUpdateInput>
  }

  /**
   * otp delete
   */
  export type otpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter which otp to delete.
     */
    where: otpWhereUniqueInput
  }

  /**
   * otp deleteMany
   */
  export type otpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which otps to delete
     */
    where?: otpWhereInput
  }

  /**
   * otp.Users
   */
  export type otp$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * otp.Branches
   */
  export type otp$BranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * otp without action
   */
  export type otpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsMinAggregateOutputType = {
    ID: string | null
    Titel: string | null
    Details: string | null
    Type: string | null
    Provider: string | null
    Remask: string | null
    UsersID: string | null
    BranchesID: string | null
    SmsGatewayUUID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    ID: string | null
    Titel: string | null
    Details: string | null
    Type: string | null
    Provider: string | null
    Remask: string | null
    UsersID: string | null
    BranchesID: string | null
    SmsGatewayUUID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    ID: number
    Titel: number
    Details: number
    Type: number
    Provider: number
    Remask: number
    UsersID: number
    BranchesID: number
    SmsGatewayUUID: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type NotificationsMinAggregateInputType = {
    ID?: true
    Titel?: true
    Details?: true
    Type?: true
    Provider?: true
    Remask?: true
    UsersID?: true
    BranchesID?: true
    SmsGatewayUUID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type NotificationsMaxAggregateInputType = {
    ID?: true
    Titel?: true
    Details?: true
    Type?: true
    Provider?: true
    Remask?: true
    UsersID?: true
    BranchesID?: true
    SmsGatewayUUID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type NotificationsCountAggregateInputType = {
    ID?: true
    Titel?: true
    Details?: true
    Type?: true
    Provider?: true
    Remask?: true
    UsersID?: true
    BranchesID?: true
    SmsGatewayUUID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    ID: string
    Titel: string | null
    Details: string | null
    Type: string | null
    Provider: string | null
    Remask: string | null
    UsersID: string | null
    BranchesID: string | null
    SmsGatewayUUID: string | null
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Titel?: boolean
    Details?: boolean
    Type?: boolean
    Provider?: boolean
    Remask?: boolean
    UsersID?: boolean
    BranchesID?: boolean
    SmsGatewayUUID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Users?: boolean | notifications$UsersArgs<ExtArgs>
    Branches?: boolean | notifications$BranchesArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectScalar = {
    ID?: boolean
    Titel?: boolean
    Details?: boolean
    Type?: boolean
    Provider?: boolean
    Remask?: boolean
    UsersID?: boolean
    BranchesID?: boolean
    SmsGatewayUUID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | notifications$UsersArgs<ExtArgs>
    Branches?: boolean | notifications$BranchesArgs<ExtArgs>
  }


  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {
      Users: Prisma.$usersPayload<ExtArgs> | null
      Branches: Prisma.$branchesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Titel: string | null
      Details: string | null
      Type: string | null
      Provider: string | null
      Remask: string | null
      UsersID: string | null
      BranchesID: string | null
      SmsGatewayUUID: string | null
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }


  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends notificationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>
    ): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends notificationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>
    ): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const notificationsWithIDOnly = await prisma.notifications.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends notificationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
    **/
    create<T extends notificationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>
    ): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends notificationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
    **/
    delete<T extends notificationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>
    ): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends notificationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>
    ): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends notificationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends notificationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
    **/
    upsert<T extends notificationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>
    ): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Users<T extends notifications$UsersArgs<ExtArgs> = {}>(args?: Subset<T, notifications$UsersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Branches<T extends notifications$BranchesArgs<ExtArgs> = {}>(args?: Subset<T, notifications$BranchesArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the notifications model
   */ 
  interface notificationsFieldRefs {
    readonly ID: FieldRef<"notifications", 'String'>
    readonly Titel: FieldRef<"notifications", 'String'>
    readonly Details: FieldRef<"notifications", 'String'>
    readonly Type: FieldRef<"notifications", 'String'>
    readonly Provider: FieldRef<"notifications", 'String'>
    readonly Remask: FieldRef<"notifications", 'String'>
    readonly UsersID: FieldRef<"notifications", 'String'>
    readonly BranchesID: FieldRef<"notifications", 'String'>
    readonly SmsGatewayUUID: FieldRef<"notifications", 'String'>
    readonly Status: FieldRef<"notifications", 'String'>
    readonly IsActive: FieldRef<"notifications", 'Boolean'>
    readonly CreatedAt: FieldRef<"notifications", 'DateTime'>
    readonly UpdatedAt: FieldRef<"notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data?: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
  }

  /**
   * notifications.Users
   */
  export type notifications$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * notifications.Branches
   */
  export type notifications$BranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
  }


  /**
   * Model forgotPassword
   */

  export type AggregateForgotPassword = {
    _count: ForgotPasswordCountAggregateOutputType | null
    _min: ForgotPasswordMinAggregateOutputType | null
    _max: ForgotPasswordMaxAggregateOutputType | null
  }

  export type ForgotPasswordMinAggregateOutputType = {
    ID: string | null
    Titel: string | null
    Token: string | null
    OldPassword: string | null
    OtpID: string | null
    Provider: string | null
    Remask: string | null
    UsersID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type ForgotPasswordMaxAggregateOutputType = {
    ID: string | null
    Titel: string | null
    Token: string | null
    OldPassword: string | null
    OtpID: string | null
    Provider: string | null
    Remask: string | null
    UsersID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type ForgotPasswordCountAggregateOutputType = {
    ID: number
    Titel: number
    Token: number
    OldPassword: number
    OtpID: number
    Provider: number
    Remask: number
    UsersID: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type ForgotPasswordMinAggregateInputType = {
    ID?: true
    Titel?: true
    Token?: true
    OldPassword?: true
    OtpID?: true
    Provider?: true
    Remask?: true
    UsersID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type ForgotPasswordMaxAggregateInputType = {
    ID?: true
    Titel?: true
    Token?: true
    OldPassword?: true
    OtpID?: true
    Provider?: true
    Remask?: true
    UsersID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type ForgotPasswordCountAggregateInputType = {
    ID?: true
    Titel?: true
    Token?: true
    OldPassword?: true
    OtpID?: true
    Provider?: true
    Remask?: true
    UsersID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type ForgotPasswordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which forgotPassword to aggregate.
     */
    where?: forgotPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forgotPasswords to fetch.
     */
    orderBy?: forgotPasswordOrderByWithRelationInput | forgotPasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: forgotPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forgotPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forgotPasswords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned forgotPasswords
    **/
    _count?: true | ForgotPasswordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForgotPasswordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForgotPasswordMaxAggregateInputType
  }

  export type GetForgotPasswordAggregateType<T extends ForgotPasswordAggregateArgs> = {
        [P in keyof T & keyof AggregateForgotPassword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForgotPassword[P]>
      : GetScalarType<T[P], AggregateForgotPassword[P]>
  }




  export type forgotPasswordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: forgotPasswordWhereInput
    orderBy?: forgotPasswordOrderByWithAggregationInput | forgotPasswordOrderByWithAggregationInput[]
    by: ForgotPasswordScalarFieldEnum[] | ForgotPasswordScalarFieldEnum
    having?: forgotPasswordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForgotPasswordCountAggregateInputType | true
    _min?: ForgotPasswordMinAggregateInputType
    _max?: ForgotPasswordMaxAggregateInputType
  }

  export type ForgotPasswordGroupByOutputType = {
    ID: string
    Titel: string | null
    Token: string | null
    OldPassword: string | null
    OtpID: string | null
    Provider: string | null
    Remask: string | null
    UsersID: string | null
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: ForgotPasswordCountAggregateOutputType | null
    _min: ForgotPasswordMinAggregateOutputType | null
    _max: ForgotPasswordMaxAggregateOutputType | null
  }

  type GetForgotPasswordGroupByPayload<T extends forgotPasswordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForgotPasswordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForgotPasswordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForgotPasswordGroupByOutputType[P]>
            : GetScalarType<T[P], ForgotPasswordGroupByOutputType[P]>
        }
      >
    >


  export type forgotPasswordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Titel?: boolean
    Token?: boolean
    OldPassword?: boolean
    OtpID?: boolean
    Provider?: boolean
    Remask?: boolean
    UsersID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Users?: boolean | forgotPassword$UsersArgs<ExtArgs>
  }, ExtArgs["result"]["forgotPassword"]>

  export type forgotPasswordSelectScalar = {
    ID?: boolean
    Titel?: boolean
    Token?: boolean
    OldPassword?: boolean
    OtpID?: boolean
    Provider?: boolean
    Remask?: boolean
    UsersID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type forgotPasswordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | forgotPassword$UsersArgs<ExtArgs>
  }


  export type $forgotPasswordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "forgotPassword"
    objects: {
      Users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Titel: string | null
      Token: string | null
      OldPassword: string | null
      OtpID: string | null
      Provider: string | null
      Remask: string | null
      UsersID: string | null
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["forgotPassword"]>
    composites: {}
  }


  type forgotPasswordGetPayload<S extends boolean | null | undefined | forgotPasswordDefaultArgs> = $Result.GetResult<Prisma.$forgotPasswordPayload, S>

  type forgotPasswordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<forgotPasswordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ForgotPasswordCountAggregateInputType | true
    }

  export interface forgotPasswordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['forgotPassword'], meta: { name: 'forgotPassword' } }
    /**
     * Find zero or one ForgotPassword that matches the filter.
     * @param {forgotPasswordFindUniqueArgs} args - Arguments to find a ForgotPassword
     * @example
     * // Get one ForgotPassword
     * const forgotPassword = await prisma.forgotPassword.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends forgotPasswordFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, forgotPasswordFindUniqueArgs<ExtArgs>>
    ): Prisma__forgotPasswordClient<$Result.GetResult<Prisma.$forgotPasswordPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ForgotPassword that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {forgotPasswordFindUniqueOrThrowArgs} args - Arguments to find a ForgotPassword
     * @example
     * // Get one ForgotPassword
     * const forgotPassword = await prisma.forgotPassword.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends forgotPasswordFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, forgotPasswordFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__forgotPasswordClient<$Result.GetResult<Prisma.$forgotPasswordPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ForgotPassword that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forgotPasswordFindFirstArgs} args - Arguments to find a ForgotPassword
     * @example
     * // Get one ForgotPassword
     * const forgotPassword = await prisma.forgotPassword.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends forgotPasswordFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, forgotPasswordFindFirstArgs<ExtArgs>>
    ): Prisma__forgotPasswordClient<$Result.GetResult<Prisma.$forgotPasswordPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ForgotPassword that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forgotPasswordFindFirstOrThrowArgs} args - Arguments to find a ForgotPassword
     * @example
     * // Get one ForgotPassword
     * const forgotPassword = await prisma.forgotPassword.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends forgotPasswordFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, forgotPasswordFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__forgotPasswordClient<$Result.GetResult<Prisma.$forgotPasswordPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ForgotPasswords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forgotPasswordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForgotPasswords
     * const forgotPasswords = await prisma.forgotPassword.findMany()
     * 
     * // Get first 10 ForgotPasswords
     * const forgotPasswords = await prisma.forgotPassword.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const forgotPasswordWithIDOnly = await prisma.forgotPassword.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends forgotPasswordFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, forgotPasswordFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$forgotPasswordPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ForgotPassword.
     * @param {forgotPasswordCreateArgs} args - Arguments to create a ForgotPassword.
     * @example
     * // Create one ForgotPassword
     * const ForgotPassword = await prisma.forgotPassword.create({
     *   data: {
     *     // ... data to create a ForgotPassword
     *   }
     * })
     * 
    **/
    create<T extends forgotPasswordCreateArgs<ExtArgs>>(
      args: SelectSubset<T, forgotPasswordCreateArgs<ExtArgs>>
    ): Prisma__forgotPasswordClient<$Result.GetResult<Prisma.$forgotPasswordPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ForgotPasswords.
     * @param {forgotPasswordCreateManyArgs} args - Arguments to create many ForgotPasswords.
     * @example
     * // Create many ForgotPasswords
     * const forgotPassword = await prisma.forgotPassword.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends forgotPasswordCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, forgotPasswordCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ForgotPassword.
     * @param {forgotPasswordDeleteArgs} args - Arguments to delete one ForgotPassword.
     * @example
     * // Delete one ForgotPassword
     * const ForgotPassword = await prisma.forgotPassword.delete({
     *   where: {
     *     // ... filter to delete one ForgotPassword
     *   }
     * })
     * 
    **/
    delete<T extends forgotPasswordDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, forgotPasswordDeleteArgs<ExtArgs>>
    ): Prisma__forgotPasswordClient<$Result.GetResult<Prisma.$forgotPasswordPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ForgotPassword.
     * @param {forgotPasswordUpdateArgs} args - Arguments to update one ForgotPassword.
     * @example
     * // Update one ForgotPassword
     * const forgotPassword = await prisma.forgotPassword.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends forgotPasswordUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, forgotPasswordUpdateArgs<ExtArgs>>
    ): Prisma__forgotPasswordClient<$Result.GetResult<Prisma.$forgotPasswordPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ForgotPasswords.
     * @param {forgotPasswordDeleteManyArgs} args - Arguments to filter ForgotPasswords to delete.
     * @example
     * // Delete a few ForgotPasswords
     * const { count } = await prisma.forgotPassword.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends forgotPasswordDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, forgotPasswordDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForgotPasswords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forgotPasswordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForgotPasswords
     * const forgotPassword = await prisma.forgotPassword.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends forgotPasswordUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, forgotPasswordUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForgotPassword.
     * @param {forgotPasswordUpsertArgs} args - Arguments to update or create a ForgotPassword.
     * @example
     * // Update or create a ForgotPassword
     * const forgotPassword = await prisma.forgotPassword.upsert({
     *   create: {
     *     // ... data to create a ForgotPassword
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForgotPassword we want to update
     *   }
     * })
    **/
    upsert<T extends forgotPasswordUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, forgotPasswordUpsertArgs<ExtArgs>>
    ): Prisma__forgotPasswordClient<$Result.GetResult<Prisma.$forgotPasswordPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ForgotPasswords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forgotPasswordCountArgs} args - Arguments to filter ForgotPasswords to count.
     * @example
     * // Count the number of ForgotPasswords
     * const count = await prisma.forgotPassword.count({
     *   where: {
     *     // ... the filter for the ForgotPasswords we want to count
     *   }
     * })
    **/
    count<T extends forgotPasswordCountArgs>(
      args?: Subset<T, forgotPasswordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForgotPasswordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForgotPassword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForgotPasswordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForgotPasswordAggregateArgs>(args: Subset<T, ForgotPasswordAggregateArgs>): Prisma.PrismaPromise<GetForgotPasswordAggregateType<T>>

    /**
     * Group by ForgotPassword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {forgotPasswordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends forgotPasswordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: forgotPasswordGroupByArgs['orderBy'] }
        : { orderBy?: forgotPasswordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, forgotPasswordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForgotPasswordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the forgotPassword model
   */
  readonly fields: forgotPasswordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for forgotPassword.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__forgotPasswordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Users<T extends forgotPassword$UsersArgs<ExtArgs> = {}>(args?: Subset<T, forgotPassword$UsersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the forgotPassword model
   */ 
  interface forgotPasswordFieldRefs {
    readonly ID: FieldRef<"forgotPassword", 'String'>
    readonly Titel: FieldRef<"forgotPassword", 'String'>
    readonly Token: FieldRef<"forgotPassword", 'String'>
    readonly OldPassword: FieldRef<"forgotPassword", 'String'>
    readonly OtpID: FieldRef<"forgotPassword", 'String'>
    readonly Provider: FieldRef<"forgotPassword", 'String'>
    readonly Remask: FieldRef<"forgotPassword", 'String'>
    readonly UsersID: FieldRef<"forgotPassword", 'String'>
    readonly Status: FieldRef<"forgotPassword", 'String'>
    readonly IsActive: FieldRef<"forgotPassword", 'Boolean'>
    readonly CreatedAt: FieldRef<"forgotPassword", 'DateTime'>
    readonly UpdatedAt: FieldRef<"forgotPassword", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * forgotPassword findUnique
   */
  export type forgotPasswordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forgotPassword
     */
    select?: forgotPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forgotPasswordInclude<ExtArgs> | null
    /**
     * Filter, which forgotPassword to fetch.
     */
    where: forgotPasswordWhereUniqueInput
  }

  /**
   * forgotPassword findUniqueOrThrow
   */
  export type forgotPasswordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forgotPassword
     */
    select?: forgotPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forgotPasswordInclude<ExtArgs> | null
    /**
     * Filter, which forgotPassword to fetch.
     */
    where: forgotPasswordWhereUniqueInput
  }

  /**
   * forgotPassword findFirst
   */
  export type forgotPasswordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forgotPassword
     */
    select?: forgotPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forgotPasswordInclude<ExtArgs> | null
    /**
     * Filter, which forgotPassword to fetch.
     */
    where?: forgotPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forgotPasswords to fetch.
     */
    orderBy?: forgotPasswordOrderByWithRelationInput | forgotPasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for forgotPasswords.
     */
    cursor?: forgotPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forgotPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forgotPasswords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of forgotPasswords.
     */
    distinct?: ForgotPasswordScalarFieldEnum | ForgotPasswordScalarFieldEnum[]
  }

  /**
   * forgotPassword findFirstOrThrow
   */
  export type forgotPasswordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forgotPassword
     */
    select?: forgotPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forgotPasswordInclude<ExtArgs> | null
    /**
     * Filter, which forgotPassword to fetch.
     */
    where?: forgotPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forgotPasswords to fetch.
     */
    orderBy?: forgotPasswordOrderByWithRelationInput | forgotPasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for forgotPasswords.
     */
    cursor?: forgotPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forgotPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forgotPasswords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of forgotPasswords.
     */
    distinct?: ForgotPasswordScalarFieldEnum | ForgotPasswordScalarFieldEnum[]
  }

  /**
   * forgotPassword findMany
   */
  export type forgotPasswordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forgotPassword
     */
    select?: forgotPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forgotPasswordInclude<ExtArgs> | null
    /**
     * Filter, which forgotPasswords to fetch.
     */
    where?: forgotPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forgotPasswords to fetch.
     */
    orderBy?: forgotPasswordOrderByWithRelationInput | forgotPasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing forgotPasswords.
     */
    cursor?: forgotPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forgotPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forgotPasswords.
     */
    skip?: number
    distinct?: ForgotPasswordScalarFieldEnum | ForgotPasswordScalarFieldEnum[]
  }

  /**
   * forgotPassword create
   */
  export type forgotPasswordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forgotPassword
     */
    select?: forgotPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forgotPasswordInclude<ExtArgs> | null
    /**
     * The data needed to create a forgotPassword.
     */
    data?: XOR<forgotPasswordCreateInput, forgotPasswordUncheckedCreateInput>
  }

  /**
   * forgotPassword createMany
   */
  export type forgotPasswordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many forgotPasswords.
     */
    data: forgotPasswordCreateManyInput | forgotPasswordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * forgotPassword update
   */
  export type forgotPasswordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forgotPassword
     */
    select?: forgotPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forgotPasswordInclude<ExtArgs> | null
    /**
     * The data needed to update a forgotPassword.
     */
    data: XOR<forgotPasswordUpdateInput, forgotPasswordUncheckedUpdateInput>
    /**
     * Choose, which forgotPassword to update.
     */
    where: forgotPasswordWhereUniqueInput
  }

  /**
   * forgotPassword updateMany
   */
  export type forgotPasswordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update forgotPasswords.
     */
    data: XOR<forgotPasswordUpdateManyMutationInput, forgotPasswordUncheckedUpdateManyInput>
    /**
     * Filter which forgotPasswords to update
     */
    where?: forgotPasswordWhereInput
  }

  /**
   * forgotPassword upsert
   */
  export type forgotPasswordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forgotPassword
     */
    select?: forgotPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forgotPasswordInclude<ExtArgs> | null
    /**
     * The filter to search for the forgotPassword to update in case it exists.
     */
    where: forgotPasswordWhereUniqueInput
    /**
     * In case the forgotPassword found by the `where` argument doesn't exist, create a new forgotPassword with this data.
     */
    create: XOR<forgotPasswordCreateInput, forgotPasswordUncheckedCreateInput>
    /**
     * In case the forgotPassword was found with the provided `where` argument, update it with this data.
     */
    update: XOR<forgotPasswordUpdateInput, forgotPasswordUncheckedUpdateInput>
  }

  /**
   * forgotPassword delete
   */
  export type forgotPasswordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forgotPassword
     */
    select?: forgotPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forgotPasswordInclude<ExtArgs> | null
    /**
     * Filter which forgotPassword to delete.
     */
    where: forgotPasswordWhereUniqueInput
  }

  /**
   * forgotPassword deleteMany
   */
  export type forgotPasswordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which forgotPasswords to delete
     */
    where?: forgotPasswordWhereInput
  }

  /**
   * forgotPassword.Users
   */
  export type forgotPassword$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * forgotPassword without action
   */
  export type forgotPasswordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the forgotPassword
     */
    select?: forgotPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: forgotPasswordInclude<ExtArgs> | null
  }


  /**
   * Model usersRoles
   */

  export type AggregateUsersRoles = {
    _count: UsersRolesCountAggregateOutputType | null
    _min: UsersRolesMinAggregateOutputType | null
    _max: UsersRolesMaxAggregateOutputType | null
  }

  export type UsersRolesMinAggregateOutputType = {
    ID: string | null
    Titel: string | null
    Type: string | null
    Role: string | null
    Permission: string | null
    Remask: string | null
    UsersID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type UsersRolesMaxAggregateOutputType = {
    ID: string | null
    Titel: string | null
    Type: string | null
    Role: string | null
    Permission: string | null
    Remask: string | null
    UsersID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type UsersRolesCountAggregateOutputType = {
    ID: number
    Titel: number
    Type: number
    Role: number
    Permission: number
    Remask: number
    UsersID: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type UsersRolesMinAggregateInputType = {
    ID?: true
    Titel?: true
    Type?: true
    Role?: true
    Permission?: true
    Remask?: true
    UsersID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type UsersRolesMaxAggregateInputType = {
    ID?: true
    Titel?: true
    Type?: true
    Role?: true
    Permission?: true
    Remask?: true
    UsersID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type UsersRolesCountAggregateInputType = {
    ID?: true
    Titel?: true
    Type?: true
    Role?: true
    Permission?: true
    Remask?: true
    UsersID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type UsersRolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usersRoles to aggregate.
     */
    where?: usersRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usersRoles to fetch.
     */
    orderBy?: usersRolesOrderByWithRelationInput | usersRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usersRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usersRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usersRoles
    **/
    _count?: true | UsersRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersRolesMaxAggregateInputType
  }

  export type GetUsersRolesAggregateType<T extends UsersRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateUsersRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsersRoles[P]>
      : GetScalarType<T[P], AggregateUsersRoles[P]>
  }




  export type usersRolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersRolesWhereInput
    orderBy?: usersRolesOrderByWithAggregationInput | usersRolesOrderByWithAggregationInput[]
    by: UsersRolesScalarFieldEnum[] | UsersRolesScalarFieldEnum
    having?: usersRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersRolesCountAggregateInputType | true
    _min?: UsersRolesMinAggregateInputType
    _max?: UsersRolesMaxAggregateInputType
  }

  export type UsersRolesGroupByOutputType = {
    ID: string
    Titel: string | null
    Type: string | null
    Role: string
    Permission: string
    Remask: string | null
    UsersID: string | null
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: UsersRolesCountAggregateOutputType | null
    _min: UsersRolesMinAggregateOutputType | null
    _max: UsersRolesMaxAggregateOutputType | null
  }

  type GetUsersRolesGroupByPayload<T extends usersRolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersRolesGroupByOutputType[P]>
            : GetScalarType<T[P], UsersRolesGroupByOutputType[P]>
        }
      >
    >


  export type usersRolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Titel?: boolean
    Type?: boolean
    Role?: boolean
    Permission?: boolean
    Remask?: boolean
    UsersID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Users?: boolean | usersRoles$UsersArgs<ExtArgs>
  }, ExtArgs["result"]["usersRoles"]>

  export type usersRolesSelectScalar = {
    ID?: boolean
    Titel?: boolean
    Type?: boolean
    Role?: boolean
    Permission?: boolean
    Remask?: boolean
    UsersID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type usersRolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | usersRoles$UsersArgs<ExtArgs>
  }


  export type $usersRolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usersRoles"
    objects: {
      Users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Titel: string | null
      Type: string | null
      Role: string
      Permission: string
      Remask: string | null
      UsersID: string | null
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["usersRoles"]>
    composites: {}
  }


  type usersRolesGetPayload<S extends boolean | null | undefined | usersRolesDefaultArgs> = $Result.GetResult<Prisma.$usersRolesPayload, S>

  type usersRolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersRolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersRolesCountAggregateInputType | true
    }

  export interface usersRolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usersRoles'], meta: { name: 'usersRoles' } }
    /**
     * Find zero or one UsersRoles that matches the filter.
     * @param {usersRolesFindUniqueArgs} args - Arguments to find a UsersRoles
     * @example
     * // Get one UsersRoles
     * const usersRoles = await prisma.usersRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersRolesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, usersRolesFindUniqueArgs<ExtArgs>>
    ): Prisma__usersRolesClient<$Result.GetResult<Prisma.$usersRolesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UsersRoles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersRolesFindUniqueOrThrowArgs} args - Arguments to find a UsersRoles
     * @example
     * // Get one UsersRoles
     * const usersRoles = await prisma.usersRoles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersRolesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersRolesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__usersRolesClient<$Result.GetResult<Prisma.$usersRolesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UsersRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersRolesFindFirstArgs} args - Arguments to find a UsersRoles
     * @example
     * // Get one UsersRoles
     * const usersRoles = await prisma.usersRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersRolesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, usersRolesFindFirstArgs<ExtArgs>>
    ): Prisma__usersRolesClient<$Result.GetResult<Prisma.$usersRolesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UsersRoles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersRolesFindFirstOrThrowArgs} args - Arguments to find a UsersRoles
     * @example
     * // Get one UsersRoles
     * const usersRoles = await prisma.usersRoles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersRolesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersRolesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__usersRolesClient<$Result.GetResult<Prisma.$usersRolesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UsersRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersRolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsersRoles
     * const usersRoles = await prisma.usersRoles.findMany()
     * 
     * // Get first 10 UsersRoles
     * const usersRoles = await prisma.usersRoles.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const usersRolesWithIDOnly = await prisma.usersRoles.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends usersRolesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersRolesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersRolesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UsersRoles.
     * @param {usersRolesCreateArgs} args - Arguments to create a UsersRoles.
     * @example
     * // Create one UsersRoles
     * const UsersRoles = await prisma.usersRoles.create({
     *   data: {
     *     // ... data to create a UsersRoles
     *   }
     * })
     * 
    **/
    create<T extends usersRolesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, usersRolesCreateArgs<ExtArgs>>
    ): Prisma__usersRolesClient<$Result.GetResult<Prisma.$usersRolesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UsersRoles.
     * @param {usersRolesCreateManyArgs} args - Arguments to create many UsersRoles.
     * @example
     * // Create many UsersRoles
     * const usersRoles = await prisma.usersRoles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends usersRolesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersRolesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UsersRoles.
     * @param {usersRolesDeleteArgs} args - Arguments to delete one UsersRoles.
     * @example
     * // Delete one UsersRoles
     * const UsersRoles = await prisma.usersRoles.delete({
     *   where: {
     *     // ... filter to delete one UsersRoles
     *   }
     * })
     * 
    **/
    delete<T extends usersRolesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, usersRolesDeleteArgs<ExtArgs>>
    ): Prisma__usersRolesClient<$Result.GetResult<Prisma.$usersRolesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UsersRoles.
     * @param {usersRolesUpdateArgs} args - Arguments to update one UsersRoles.
     * @example
     * // Update one UsersRoles
     * const usersRoles = await prisma.usersRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersRolesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, usersRolesUpdateArgs<ExtArgs>>
    ): Prisma__usersRolesClient<$Result.GetResult<Prisma.$usersRolesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UsersRoles.
     * @param {usersRolesDeleteManyArgs} args - Arguments to filter UsersRoles to delete.
     * @example
     * // Delete a few UsersRoles
     * const { count } = await prisma.usersRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersRolesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersRolesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsersRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsersRoles
     * const usersRoles = await prisma.usersRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersRolesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, usersRolesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsersRoles.
     * @param {usersRolesUpsertArgs} args - Arguments to update or create a UsersRoles.
     * @example
     * // Update or create a UsersRoles
     * const usersRoles = await prisma.usersRoles.upsert({
     *   create: {
     *     // ... data to create a UsersRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsersRoles we want to update
     *   }
     * })
    **/
    upsert<T extends usersRolesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, usersRolesUpsertArgs<ExtArgs>>
    ): Prisma__usersRolesClient<$Result.GetResult<Prisma.$usersRolesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UsersRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersRolesCountArgs} args - Arguments to filter UsersRoles to count.
     * @example
     * // Count the number of UsersRoles
     * const count = await prisma.usersRoles.count({
     *   where: {
     *     // ... the filter for the UsersRoles we want to count
     *   }
     * })
    **/
    count<T extends usersRolesCountArgs>(
      args?: Subset<T, usersRolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsersRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersRolesAggregateArgs>(args: Subset<T, UsersRolesAggregateArgs>): Prisma.PrismaPromise<GetUsersRolesAggregateType<T>>

    /**
     * Group by UsersRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersRolesGroupByArgs['orderBy'] }
        : { orderBy?: usersRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usersRoles model
   */
  readonly fields: usersRolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usersRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersRolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Users<T extends usersRoles$UsersArgs<ExtArgs> = {}>(args?: Subset<T, usersRoles$UsersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the usersRoles model
   */ 
  interface usersRolesFieldRefs {
    readonly ID: FieldRef<"usersRoles", 'String'>
    readonly Titel: FieldRef<"usersRoles", 'String'>
    readonly Type: FieldRef<"usersRoles", 'String'>
    readonly Role: FieldRef<"usersRoles", 'String'>
    readonly Permission: FieldRef<"usersRoles", 'String'>
    readonly Remask: FieldRef<"usersRoles", 'String'>
    readonly UsersID: FieldRef<"usersRoles", 'String'>
    readonly Status: FieldRef<"usersRoles", 'String'>
    readonly IsActive: FieldRef<"usersRoles", 'Boolean'>
    readonly CreatedAt: FieldRef<"usersRoles", 'DateTime'>
    readonly UpdatedAt: FieldRef<"usersRoles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * usersRoles findUnique
   */
  export type usersRolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersRoles
     */
    select?: usersRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersRolesInclude<ExtArgs> | null
    /**
     * Filter, which usersRoles to fetch.
     */
    where: usersRolesWhereUniqueInput
  }

  /**
   * usersRoles findUniqueOrThrow
   */
  export type usersRolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersRoles
     */
    select?: usersRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersRolesInclude<ExtArgs> | null
    /**
     * Filter, which usersRoles to fetch.
     */
    where: usersRolesWhereUniqueInput
  }

  /**
   * usersRoles findFirst
   */
  export type usersRolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersRoles
     */
    select?: usersRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersRolesInclude<ExtArgs> | null
    /**
     * Filter, which usersRoles to fetch.
     */
    where?: usersRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usersRoles to fetch.
     */
    orderBy?: usersRolesOrderByWithRelationInput | usersRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usersRoles.
     */
    cursor?: usersRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usersRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usersRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usersRoles.
     */
    distinct?: UsersRolesScalarFieldEnum | UsersRolesScalarFieldEnum[]
  }

  /**
   * usersRoles findFirstOrThrow
   */
  export type usersRolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersRoles
     */
    select?: usersRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersRolesInclude<ExtArgs> | null
    /**
     * Filter, which usersRoles to fetch.
     */
    where?: usersRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usersRoles to fetch.
     */
    orderBy?: usersRolesOrderByWithRelationInput | usersRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usersRoles.
     */
    cursor?: usersRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usersRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usersRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usersRoles.
     */
    distinct?: UsersRolesScalarFieldEnum | UsersRolesScalarFieldEnum[]
  }

  /**
   * usersRoles findMany
   */
  export type usersRolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersRoles
     */
    select?: usersRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersRolesInclude<ExtArgs> | null
    /**
     * Filter, which usersRoles to fetch.
     */
    where?: usersRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usersRoles to fetch.
     */
    orderBy?: usersRolesOrderByWithRelationInput | usersRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usersRoles.
     */
    cursor?: usersRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usersRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usersRoles.
     */
    skip?: number
    distinct?: UsersRolesScalarFieldEnum | UsersRolesScalarFieldEnum[]
  }

  /**
   * usersRoles create
   */
  export type usersRolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersRoles
     */
    select?: usersRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersRolesInclude<ExtArgs> | null
    /**
     * The data needed to create a usersRoles.
     */
    data: XOR<usersRolesCreateInput, usersRolesUncheckedCreateInput>
  }

  /**
   * usersRoles createMany
   */
  export type usersRolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usersRoles.
     */
    data: usersRolesCreateManyInput | usersRolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usersRoles update
   */
  export type usersRolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersRoles
     */
    select?: usersRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersRolesInclude<ExtArgs> | null
    /**
     * The data needed to update a usersRoles.
     */
    data: XOR<usersRolesUpdateInput, usersRolesUncheckedUpdateInput>
    /**
     * Choose, which usersRoles to update.
     */
    where: usersRolesWhereUniqueInput
  }

  /**
   * usersRoles updateMany
   */
  export type usersRolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usersRoles.
     */
    data: XOR<usersRolesUpdateManyMutationInput, usersRolesUncheckedUpdateManyInput>
    /**
     * Filter which usersRoles to update
     */
    where?: usersRolesWhereInput
  }

  /**
   * usersRoles upsert
   */
  export type usersRolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersRoles
     */
    select?: usersRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersRolesInclude<ExtArgs> | null
    /**
     * The filter to search for the usersRoles to update in case it exists.
     */
    where: usersRolesWhereUniqueInput
    /**
     * In case the usersRoles found by the `where` argument doesn't exist, create a new usersRoles with this data.
     */
    create: XOR<usersRolesCreateInput, usersRolesUncheckedCreateInput>
    /**
     * In case the usersRoles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersRolesUpdateInput, usersRolesUncheckedUpdateInput>
  }

  /**
   * usersRoles delete
   */
  export type usersRolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersRoles
     */
    select?: usersRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersRolesInclude<ExtArgs> | null
    /**
     * Filter which usersRoles to delete.
     */
    where: usersRolesWhereUniqueInput
  }

  /**
   * usersRoles deleteMany
   */
  export type usersRolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usersRoles to delete
     */
    where?: usersRolesWhereInput
  }

  /**
   * usersRoles.Users
   */
  export type usersRoles$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * usersRoles without action
   */
  export type usersRolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersRoles
     */
    select?: usersRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersRolesInclude<ExtArgs> | null
  }


  /**
   * Model usersActivities
   */

  export type AggregateUsersActivities = {
    _count: UsersActivitiesCountAggregateOutputType | null
    _min: UsersActivitiesMinAggregateOutputType | null
    _max: UsersActivitiesMaxAggregateOutputType | null
  }

  export type UsersActivitiesMinAggregateOutputType = {
    ID: string | null
    Activity: string | null
    IP: string | null
    MacAddress: string | null
    UDID: string | null
    Remask: string | null
    Log: string | null
    Error: string | null
    Messages: string | null
    UsersID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type UsersActivitiesMaxAggregateOutputType = {
    ID: string | null
    Activity: string | null
    IP: string | null
    MacAddress: string | null
    UDID: string | null
    Remask: string | null
    Log: string | null
    Error: string | null
    Messages: string | null
    UsersID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type UsersActivitiesCountAggregateOutputType = {
    ID: number
    Activity: number
    IP: number
    MacAddress: number
    UDID: number
    Remask: number
    Log: number
    Error: number
    Messages: number
    UsersID: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type UsersActivitiesMinAggregateInputType = {
    ID?: true
    Activity?: true
    IP?: true
    MacAddress?: true
    UDID?: true
    Remask?: true
    Log?: true
    Error?: true
    Messages?: true
    UsersID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type UsersActivitiesMaxAggregateInputType = {
    ID?: true
    Activity?: true
    IP?: true
    MacAddress?: true
    UDID?: true
    Remask?: true
    Log?: true
    Error?: true
    Messages?: true
    UsersID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type UsersActivitiesCountAggregateInputType = {
    ID?: true
    Activity?: true
    IP?: true
    MacAddress?: true
    UDID?: true
    Remask?: true
    Log?: true
    Error?: true
    Messages?: true
    UsersID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type UsersActivitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usersActivities to aggregate.
     */
    where?: usersActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usersActivities to fetch.
     */
    orderBy?: usersActivitiesOrderByWithRelationInput | usersActivitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usersActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usersActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usersActivities
    **/
    _count?: true | UsersActivitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersActivitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersActivitiesMaxAggregateInputType
  }

  export type GetUsersActivitiesAggregateType<T extends UsersActivitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateUsersActivities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsersActivities[P]>
      : GetScalarType<T[P], AggregateUsersActivities[P]>
  }




  export type usersActivitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersActivitiesWhereInput
    orderBy?: usersActivitiesOrderByWithAggregationInput | usersActivitiesOrderByWithAggregationInput[]
    by: UsersActivitiesScalarFieldEnum[] | UsersActivitiesScalarFieldEnum
    having?: usersActivitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersActivitiesCountAggregateInputType | true
    _min?: UsersActivitiesMinAggregateInputType
    _max?: UsersActivitiesMaxAggregateInputType
  }

  export type UsersActivitiesGroupByOutputType = {
    ID: string
    Activity: string | null
    IP: string | null
    MacAddress: string | null
    UDID: string | null
    Remask: string | null
    Log: string | null
    Error: string | null
    Messages: string | null
    UsersID: string | null
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: UsersActivitiesCountAggregateOutputType | null
    _min: UsersActivitiesMinAggregateOutputType | null
    _max: UsersActivitiesMaxAggregateOutputType | null
  }

  type GetUsersActivitiesGroupByPayload<T extends usersActivitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersActivitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersActivitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersActivitiesGroupByOutputType[P]>
            : GetScalarType<T[P], UsersActivitiesGroupByOutputType[P]>
        }
      >
    >


  export type usersActivitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Activity?: boolean
    IP?: boolean
    MacAddress?: boolean
    UDID?: boolean
    Remask?: boolean
    Log?: boolean
    Error?: boolean
    Messages?: boolean
    UsersID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Users?: boolean | usersActivities$UsersArgs<ExtArgs>
    ThreadingOrder?: boolean | usersActivities$ThreadingOrderArgs<ExtArgs>
  }, ExtArgs["result"]["usersActivities"]>

  export type usersActivitiesSelectScalar = {
    ID?: boolean
    Activity?: boolean
    IP?: boolean
    MacAddress?: boolean
    UDID?: boolean
    Remask?: boolean
    Log?: boolean
    Error?: boolean
    Messages?: boolean
    UsersID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type usersActivitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | usersActivities$UsersArgs<ExtArgs>
    ThreadingOrder?: boolean | usersActivities$ThreadingOrderArgs<ExtArgs>
  }


  export type $usersActivitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usersActivities"
    objects: {
      Users: Prisma.$usersPayload<ExtArgs> | null
      ThreadingOrder: Prisma.$orderThreadingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Activity: string | null
      IP: string | null
      MacAddress: string | null
      UDID: string | null
      Remask: string | null
      Log: string | null
      Error: string | null
      Messages: string | null
      UsersID: string | null
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["usersActivities"]>
    composites: {}
  }


  type usersActivitiesGetPayload<S extends boolean | null | undefined | usersActivitiesDefaultArgs> = $Result.GetResult<Prisma.$usersActivitiesPayload, S>

  type usersActivitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersActivitiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersActivitiesCountAggregateInputType | true
    }

  export interface usersActivitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usersActivities'], meta: { name: 'usersActivities' } }
    /**
     * Find zero or one UsersActivities that matches the filter.
     * @param {usersActivitiesFindUniqueArgs} args - Arguments to find a UsersActivities
     * @example
     * // Get one UsersActivities
     * const usersActivities = await prisma.usersActivities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersActivitiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, usersActivitiesFindUniqueArgs<ExtArgs>>
    ): Prisma__usersActivitiesClient<$Result.GetResult<Prisma.$usersActivitiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UsersActivities that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersActivitiesFindUniqueOrThrowArgs} args - Arguments to find a UsersActivities
     * @example
     * // Get one UsersActivities
     * const usersActivities = await prisma.usersActivities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersActivitiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersActivitiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__usersActivitiesClient<$Result.GetResult<Prisma.$usersActivitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UsersActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersActivitiesFindFirstArgs} args - Arguments to find a UsersActivities
     * @example
     * // Get one UsersActivities
     * const usersActivities = await prisma.usersActivities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersActivitiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, usersActivitiesFindFirstArgs<ExtArgs>>
    ): Prisma__usersActivitiesClient<$Result.GetResult<Prisma.$usersActivitiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UsersActivities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersActivitiesFindFirstOrThrowArgs} args - Arguments to find a UsersActivities
     * @example
     * // Get one UsersActivities
     * const usersActivities = await prisma.usersActivities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersActivitiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersActivitiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__usersActivitiesClient<$Result.GetResult<Prisma.$usersActivitiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UsersActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersActivitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsersActivities
     * const usersActivities = await prisma.usersActivities.findMany()
     * 
     * // Get first 10 UsersActivities
     * const usersActivities = await prisma.usersActivities.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const usersActivitiesWithIDOnly = await prisma.usersActivities.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends usersActivitiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersActivitiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersActivitiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UsersActivities.
     * @param {usersActivitiesCreateArgs} args - Arguments to create a UsersActivities.
     * @example
     * // Create one UsersActivities
     * const UsersActivities = await prisma.usersActivities.create({
     *   data: {
     *     // ... data to create a UsersActivities
     *   }
     * })
     * 
    **/
    create<T extends usersActivitiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, usersActivitiesCreateArgs<ExtArgs>>
    ): Prisma__usersActivitiesClient<$Result.GetResult<Prisma.$usersActivitiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UsersActivities.
     * @param {usersActivitiesCreateManyArgs} args - Arguments to create many UsersActivities.
     * @example
     * // Create many UsersActivities
     * const usersActivities = await prisma.usersActivities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends usersActivitiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersActivitiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UsersActivities.
     * @param {usersActivitiesDeleteArgs} args - Arguments to delete one UsersActivities.
     * @example
     * // Delete one UsersActivities
     * const UsersActivities = await prisma.usersActivities.delete({
     *   where: {
     *     // ... filter to delete one UsersActivities
     *   }
     * })
     * 
    **/
    delete<T extends usersActivitiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, usersActivitiesDeleteArgs<ExtArgs>>
    ): Prisma__usersActivitiesClient<$Result.GetResult<Prisma.$usersActivitiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UsersActivities.
     * @param {usersActivitiesUpdateArgs} args - Arguments to update one UsersActivities.
     * @example
     * // Update one UsersActivities
     * const usersActivities = await prisma.usersActivities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersActivitiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, usersActivitiesUpdateArgs<ExtArgs>>
    ): Prisma__usersActivitiesClient<$Result.GetResult<Prisma.$usersActivitiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UsersActivities.
     * @param {usersActivitiesDeleteManyArgs} args - Arguments to filter UsersActivities to delete.
     * @example
     * // Delete a few UsersActivities
     * const { count } = await prisma.usersActivities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersActivitiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersActivitiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsersActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersActivitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsersActivities
     * const usersActivities = await prisma.usersActivities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersActivitiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, usersActivitiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsersActivities.
     * @param {usersActivitiesUpsertArgs} args - Arguments to update or create a UsersActivities.
     * @example
     * // Update or create a UsersActivities
     * const usersActivities = await prisma.usersActivities.upsert({
     *   create: {
     *     // ... data to create a UsersActivities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsersActivities we want to update
     *   }
     * })
    **/
    upsert<T extends usersActivitiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, usersActivitiesUpsertArgs<ExtArgs>>
    ): Prisma__usersActivitiesClient<$Result.GetResult<Prisma.$usersActivitiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UsersActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersActivitiesCountArgs} args - Arguments to filter UsersActivities to count.
     * @example
     * // Count the number of UsersActivities
     * const count = await prisma.usersActivities.count({
     *   where: {
     *     // ... the filter for the UsersActivities we want to count
     *   }
     * })
    **/
    count<T extends usersActivitiesCountArgs>(
      args?: Subset<T, usersActivitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersActivitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsersActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersActivitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersActivitiesAggregateArgs>(args: Subset<T, UsersActivitiesAggregateArgs>): Prisma.PrismaPromise<GetUsersActivitiesAggregateType<T>>

    /**
     * Group by UsersActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersActivitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersActivitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersActivitiesGroupByArgs['orderBy'] }
        : { orderBy?: usersActivitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersActivitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersActivitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usersActivities model
   */
  readonly fields: usersActivitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usersActivities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersActivitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Users<T extends usersActivities$UsersArgs<ExtArgs> = {}>(args?: Subset<T, usersActivities$UsersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    ThreadingOrder<T extends usersActivities$ThreadingOrderArgs<ExtArgs> = {}>(args?: Subset<T, usersActivities$ThreadingOrderArgs<ExtArgs>>): Prisma__orderThreadingClient<$Result.GetResult<Prisma.$orderThreadingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the usersActivities model
   */ 
  interface usersActivitiesFieldRefs {
    readonly ID: FieldRef<"usersActivities", 'String'>
    readonly Activity: FieldRef<"usersActivities", 'String'>
    readonly IP: FieldRef<"usersActivities", 'String'>
    readonly MacAddress: FieldRef<"usersActivities", 'String'>
    readonly UDID: FieldRef<"usersActivities", 'String'>
    readonly Remask: FieldRef<"usersActivities", 'String'>
    readonly Log: FieldRef<"usersActivities", 'String'>
    readonly Error: FieldRef<"usersActivities", 'String'>
    readonly Messages: FieldRef<"usersActivities", 'String'>
    readonly UsersID: FieldRef<"usersActivities", 'String'>
    readonly Status: FieldRef<"usersActivities", 'String'>
    readonly IsActive: FieldRef<"usersActivities", 'Boolean'>
    readonly CreatedAt: FieldRef<"usersActivities", 'DateTime'>
    readonly UpdatedAt: FieldRef<"usersActivities", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * usersActivities findUnique
   */
  export type usersActivitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersActivities
     */
    select?: usersActivitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersActivitiesInclude<ExtArgs> | null
    /**
     * Filter, which usersActivities to fetch.
     */
    where: usersActivitiesWhereUniqueInput
  }

  /**
   * usersActivities findUniqueOrThrow
   */
  export type usersActivitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersActivities
     */
    select?: usersActivitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersActivitiesInclude<ExtArgs> | null
    /**
     * Filter, which usersActivities to fetch.
     */
    where: usersActivitiesWhereUniqueInput
  }

  /**
   * usersActivities findFirst
   */
  export type usersActivitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersActivities
     */
    select?: usersActivitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersActivitiesInclude<ExtArgs> | null
    /**
     * Filter, which usersActivities to fetch.
     */
    where?: usersActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usersActivities to fetch.
     */
    orderBy?: usersActivitiesOrderByWithRelationInput | usersActivitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usersActivities.
     */
    cursor?: usersActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usersActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usersActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usersActivities.
     */
    distinct?: UsersActivitiesScalarFieldEnum | UsersActivitiesScalarFieldEnum[]
  }

  /**
   * usersActivities findFirstOrThrow
   */
  export type usersActivitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersActivities
     */
    select?: usersActivitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersActivitiesInclude<ExtArgs> | null
    /**
     * Filter, which usersActivities to fetch.
     */
    where?: usersActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usersActivities to fetch.
     */
    orderBy?: usersActivitiesOrderByWithRelationInput | usersActivitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usersActivities.
     */
    cursor?: usersActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usersActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usersActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usersActivities.
     */
    distinct?: UsersActivitiesScalarFieldEnum | UsersActivitiesScalarFieldEnum[]
  }

  /**
   * usersActivities findMany
   */
  export type usersActivitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersActivities
     */
    select?: usersActivitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersActivitiesInclude<ExtArgs> | null
    /**
     * Filter, which usersActivities to fetch.
     */
    where?: usersActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usersActivities to fetch.
     */
    orderBy?: usersActivitiesOrderByWithRelationInput | usersActivitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usersActivities.
     */
    cursor?: usersActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usersActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usersActivities.
     */
    skip?: number
    distinct?: UsersActivitiesScalarFieldEnum | UsersActivitiesScalarFieldEnum[]
  }

  /**
   * usersActivities create
   */
  export type usersActivitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersActivities
     */
    select?: usersActivitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersActivitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a usersActivities.
     */
    data?: XOR<usersActivitiesCreateInput, usersActivitiesUncheckedCreateInput>
  }

  /**
   * usersActivities createMany
   */
  export type usersActivitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usersActivities.
     */
    data: usersActivitiesCreateManyInput | usersActivitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usersActivities update
   */
  export type usersActivitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersActivities
     */
    select?: usersActivitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersActivitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a usersActivities.
     */
    data: XOR<usersActivitiesUpdateInput, usersActivitiesUncheckedUpdateInput>
    /**
     * Choose, which usersActivities to update.
     */
    where: usersActivitiesWhereUniqueInput
  }

  /**
   * usersActivities updateMany
   */
  export type usersActivitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usersActivities.
     */
    data: XOR<usersActivitiesUpdateManyMutationInput, usersActivitiesUncheckedUpdateManyInput>
    /**
     * Filter which usersActivities to update
     */
    where?: usersActivitiesWhereInput
  }

  /**
   * usersActivities upsert
   */
  export type usersActivitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersActivities
     */
    select?: usersActivitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersActivitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the usersActivities to update in case it exists.
     */
    where: usersActivitiesWhereUniqueInput
    /**
     * In case the usersActivities found by the `where` argument doesn't exist, create a new usersActivities with this data.
     */
    create: XOR<usersActivitiesCreateInput, usersActivitiesUncheckedCreateInput>
    /**
     * In case the usersActivities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersActivitiesUpdateInput, usersActivitiesUncheckedUpdateInput>
  }

  /**
   * usersActivities delete
   */
  export type usersActivitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersActivities
     */
    select?: usersActivitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersActivitiesInclude<ExtArgs> | null
    /**
     * Filter which usersActivities to delete.
     */
    where: usersActivitiesWhereUniqueInput
  }

  /**
   * usersActivities deleteMany
   */
  export type usersActivitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usersActivities to delete
     */
    where?: usersActivitiesWhereInput
  }

  /**
   * usersActivities.Users
   */
  export type usersActivities$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * usersActivities.ThreadingOrder
   */
  export type usersActivities$ThreadingOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderThreading
     */
    select?: orderThreadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderThreadingInclude<ExtArgs> | null
    where?: orderThreadingWhereInput
  }

  /**
   * usersActivities without action
   */
  export type usersActivitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersActivities
     */
    select?: usersActivitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersActivitiesInclude<ExtArgs> | null
  }


  /**
   * Model orderType
   */

  export type AggregateOrderType = {
    _count: OrderTypeCountAggregateOutputType | null
    _min: OrderTypeMinAggregateOutputType | null
    _max: OrderTypeMaxAggregateOutputType | null
  }

  export type OrderTypeMinAggregateOutputType = {
    ID: string | null
    TypeCode: string | null
    TypeNmae: string | null
    Remask: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OrderTypeMaxAggregateOutputType = {
    ID: string | null
    TypeCode: string | null
    TypeNmae: string | null
    Remask: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OrderTypeCountAggregateOutputType = {
    ID: number
    TypeCode: number
    TypeNmae: number
    Remask: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type OrderTypeMinAggregateInputType = {
    ID?: true
    TypeCode?: true
    TypeNmae?: true
    Remask?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OrderTypeMaxAggregateInputType = {
    ID?: true
    TypeCode?: true
    TypeNmae?: true
    Remask?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OrderTypeCountAggregateInputType = {
    ID?: true
    TypeCode?: true
    TypeNmae?: true
    Remask?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type OrderTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderType to aggregate.
     */
    where?: orderTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderTypes to fetch.
     */
    orderBy?: orderTypeOrderByWithRelationInput | orderTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: orderTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orderTypes
    **/
    _count?: true | OrderTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderTypeMaxAggregateInputType
  }

  export type GetOrderTypeAggregateType<T extends OrderTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderType[P]>
      : GetScalarType<T[P], AggregateOrderType[P]>
  }




  export type orderTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderTypeWhereInput
    orderBy?: orderTypeOrderByWithAggregationInput | orderTypeOrderByWithAggregationInput[]
    by: OrderTypeScalarFieldEnum[] | OrderTypeScalarFieldEnum
    having?: orderTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderTypeCountAggregateInputType | true
    _min?: OrderTypeMinAggregateInputType
    _max?: OrderTypeMaxAggregateInputType
  }

  export type OrderTypeGroupByOutputType = {
    ID: string
    TypeCode: string | null
    TypeNmae: string | null
    Remask: string | null
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: OrderTypeCountAggregateOutputType | null
    _min: OrderTypeMinAggregateOutputType | null
    _max: OrderTypeMaxAggregateOutputType | null
  }

  type GetOrderTypeGroupByPayload<T extends orderTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderTypeGroupByOutputType[P]>
            : GetScalarType<T[P], OrderTypeGroupByOutputType[P]>
        }
      >
    >


  export type orderTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    TypeCode?: boolean
    TypeNmae?: boolean
    Remask?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }, ExtArgs["result"]["orderType"]>

  export type orderTypeSelectScalar = {
    ID?: boolean
    TypeCode?: boolean
    TypeNmae?: boolean
    Remask?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }



  export type $orderTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "orderType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      TypeCode: string | null
      TypeNmae: string | null
      Remask: string | null
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["orderType"]>
    composites: {}
  }


  type orderTypeGetPayload<S extends boolean | null | undefined | orderTypeDefaultArgs> = $Result.GetResult<Prisma.$orderTypePayload, S>

  type orderTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<orderTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderTypeCountAggregateInputType | true
    }

  export interface orderTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['orderType'], meta: { name: 'orderType' } }
    /**
     * Find zero or one OrderType that matches the filter.
     * @param {orderTypeFindUniqueArgs} args - Arguments to find a OrderType
     * @example
     * // Get one OrderType
     * const orderType = await prisma.orderType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends orderTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, orderTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__orderTypeClient<$Result.GetResult<Prisma.$orderTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrderType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {orderTypeFindUniqueOrThrowArgs} args - Arguments to find a OrderType
     * @example
     * // Get one OrderType
     * const orderType = await prisma.orderType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends orderTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__orderTypeClient<$Result.GetResult<Prisma.$orderTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrderType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderTypeFindFirstArgs} args - Arguments to find a OrderType
     * @example
     * // Get one OrderType
     * const orderType = await prisma.orderType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends orderTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, orderTypeFindFirstArgs<ExtArgs>>
    ): Prisma__orderTypeClient<$Result.GetResult<Prisma.$orderTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrderType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderTypeFindFirstOrThrowArgs} args - Arguments to find a OrderType
     * @example
     * // Get one OrderType
     * const orderType = await prisma.orderType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends orderTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__orderTypeClient<$Result.GetResult<Prisma.$orderTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrderTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderTypes
     * const orderTypes = await prisma.orderType.findMany()
     * 
     * // Get first 10 OrderTypes
     * const orderTypes = await prisma.orderType.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const orderTypeWithIDOnly = await prisma.orderType.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends orderTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrderType.
     * @param {orderTypeCreateArgs} args - Arguments to create a OrderType.
     * @example
     * // Create one OrderType
     * const OrderType = await prisma.orderType.create({
     *   data: {
     *     // ... data to create a OrderType
     *   }
     * })
     * 
    **/
    create<T extends orderTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, orderTypeCreateArgs<ExtArgs>>
    ): Prisma__orderTypeClient<$Result.GetResult<Prisma.$orderTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrderTypes.
     * @param {orderTypeCreateManyArgs} args - Arguments to create many OrderTypes.
     * @example
     * // Create many OrderTypes
     * const orderType = await prisma.orderType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends orderTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderType.
     * @param {orderTypeDeleteArgs} args - Arguments to delete one OrderType.
     * @example
     * // Delete one OrderType
     * const OrderType = await prisma.orderType.delete({
     *   where: {
     *     // ... filter to delete one OrderType
     *   }
     * })
     * 
    **/
    delete<T extends orderTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, orderTypeDeleteArgs<ExtArgs>>
    ): Prisma__orderTypeClient<$Result.GetResult<Prisma.$orderTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrderType.
     * @param {orderTypeUpdateArgs} args - Arguments to update one OrderType.
     * @example
     * // Update one OrderType
     * const orderType = await prisma.orderType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends orderTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, orderTypeUpdateArgs<ExtArgs>>
    ): Prisma__orderTypeClient<$Result.GetResult<Prisma.$orderTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrderTypes.
     * @param {orderTypeDeleteManyArgs} args - Arguments to filter OrderTypes to delete.
     * @example
     * // Delete a few OrderTypes
     * const { count } = await prisma.orderType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends orderTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderTypes
     * const orderType = await prisma.orderType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends orderTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, orderTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderType.
     * @param {orderTypeUpsertArgs} args - Arguments to update or create a OrderType.
     * @example
     * // Update or create a OrderType
     * const orderType = await prisma.orderType.upsert({
     *   create: {
     *     // ... data to create a OrderType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderType we want to update
     *   }
     * })
    **/
    upsert<T extends orderTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, orderTypeUpsertArgs<ExtArgs>>
    ): Prisma__orderTypeClient<$Result.GetResult<Prisma.$orderTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrderTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderTypeCountArgs} args - Arguments to filter OrderTypes to count.
     * @example
     * // Count the number of OrderTypes
     * const count = await prisma.orderType.count({
     *   where: {
     *     // ... the filter for the OrderTypes we want to count
     *   }
     * })
    **/
    count<T extends orderTypeCountArgs>(
      args?: Subset<T, orderTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderTypeAggregateArgs>(args: Subset<T, OrderTypeAggregateArgs>): Prisma.PrismaPromise<GetOrderTypeAggregateType<T>>

    /**
     * Group by OrderType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends orderTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: orderTypeGroupByArgs['orderBy'] }
        : { orderBy?: orderTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, orderTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the orderType model
   */
  readonly fields: orderTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for orderType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__orderTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the orderType model
   */ 
  interface orderTypeFieldRefs {
    readonly ID: FieldRef<"orderType", 'String'>
    readonly TypeCode: FieldRef<"orderType", 'String'>
    readonly TypeNmae: FieldRef<"orderType", 'String'>
    readonly Remask: FieldRef<"orderType", 'String'>
    readonly Status: FieldRef<"orderType", 'String'>
    readonly IsActive: FieldRef<"orderType", 'Boolean'>
    readonly CreatedAt: FieldRef<"orderType", 'DateTime'>
    readonly UpdatedAt: FieldRef<"orderType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * orderType findUnique
   */
  export type orderTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderType
     */
    select?: orderTypeSelect<ExtArgs> | null
    /**
     * Filter, which orderType to fetch.
     */
    where: orderTypeWhereUniqueInput
  }

  /**
   * orderType findUniqueOrThrow
   */
  export type orderTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderType
     */
    select?: orderTypeSelect<ExtArgs> | null
    /**
     * Filter, which orderType to fetch.
     */
    where: orderTypeWhereUniqueInput
  }

  /**
   * orderType findFirst
   */
  export type orderTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderType
     */
    select?: orderTypeSelect<ExtArgs> | null
    /**
     * Filter, which orderType to fetch.
     */
    where?: orderTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderTypes to fetch.
     */
    orderBy?: orderTypeOrderByWithRelationInput | orderTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderTypes.
     */
    cursor?: orderTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderTypes.
     */
    distinct?: OrderTypeScalarFieldEnum | OrderTypeScalarFieldEnum[]
  }

  /**
   * orderType findFirstOrThrow
   */
  export type orderTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderType
     */
    select?: orderTypeSelect<ExtArgs> | null
    /**
     * Filter, which orderType to fetch.
     */
    where?: orderTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderTypes to fetch.
     */
    orderBy?: orderTypeOrderByWithRelationInput | orderTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderTypes.
     */
    cursor?: orderTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderTypes.
     */
    distinct?: OrderTypeScalarFieldEnum | OrderTypeScalarFieldEnum[]
  }

  /**
   * orderType findMany
   */
  export type orderTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderType
     */
    select?: orderTypeSelect<ExtArgs> | null
    /**
     * Filter, which orderTypes to fetch.
     */
    where?: orderTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderTypes to fetch.
     */
    orderBy?: orderTypeOrderByWithRelationInput | orderTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orderTypes.
     */
    cursor?: orderTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderTypes.
     */
    skip?: number
    distinct?: OrderTypeScalarFieldEnum | OrderTypeScalarFieldEnum[]
  }

  /**
   * orderType create
   */
  export type orderTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderType
     */
    select?: orderTypeSelect<ExtArgs> | null
    /**
     * The data needed to create a orderType.
     */
    data?: XOR<orderTypeCreateInput, orderTypeUncheckedCreateInput>
  }

  /**
   * orderType createMany
   */
  export type orderTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orderTypes.
     */
    data: orderTypeCreateManyInput | orderTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * orderType update
   */
  export type orderTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderType
     */
    select?: orderTypeSelect<ExtArgs> | null
    /**
     * The data needed to update a orderType.
     */
    data: XOR<orderTypeUpdateInput, orderTypeUncheckedUpdateInput>
    /**
     * Choose, which orderType to update.
     */
    where: orderTypeWhereUniqueInput
  }

  /**
   * orderType updateMany
   */
  export type orderTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orderTypes.
     */
    data: XOR<orderTypeUpdateManyMutationInput, orderTypeUncheckedUpdateManyInput>
    /**
     * Filter which orderTypes to update
     */
    where?: orderTypeWhereInput
  }

  /**
   * orderType upsert
   */
  export type orderTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderType
     */
    select?: orderTypeSelect<ExtArgs> | null
    /**
     * The filter to search for the orderType to update in case it exists.
     */
    where: orderTypeWhereUniqueInput
    /**
     * In case the orderType found by the `where` argument doesn't exist, create a new orderType with this data.
     */
    create: XOR<orderTypeCreateInput, orderTypeUncheckedCreateInput>
    /**
     * In case the orderType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<orderTypeUpdateInput, orderTypeUncheckedUpdateInput>
  }

  /**
   * orderType delete
   */
  export type orderTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderType
     */
    select?: orderTypeSelect<ExtArgs> | null
    /**
     * Filter which orderType to delete.
     */
    where: orderTypeWhereUniqueInput
  }

  /**
   * orderType deleteMany
   */
  export type orderTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderTypes to delete
     */
    where?: orderTypeWhereInput
  }

  /**
   * orderType without action
   */
  export type orderTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderType
     */
    select?: orderTypeSelect<ExtArgs> | null
  }


  /**
   * Model orderCategory
   */

  export type AggregateOrderCategory = {
    _count: OrderCategoryCountAggregateOutputType | null
    _min: OrderCategoryMinAggregateOutputType | null
    _max: OrderCategoryMaxAggregateOutputType | null
  }

  export type OrderCategoryMinAggregateOutputType = {
    ID: string | null
    TypeCode: string | null
    TypeNmae: string | null
    Remask: string | null
    BranchesID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OrderCategoryMaxAggregateOutputType = {
    ID: string | null
    TypeCode: string | null
    TypeNmae: string | null
    Remask: string | null
    BranchesID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OrderCategoryCountAggregateOutputType = {
    ID: number
    TypeCode: number
    TypeNmae: number
    Remask: number
    BranchesID: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type OrderCategoryMinAggregateInputType = {
    ID?: true
    TypeCode?: true
    TypeNmae?: true
    Remask?: true
    BranchesID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OrderCategoryMaxAggregateInputType = {
    ID?: true
    TypeCode?: true
    TypeNmae?: true
    Remask?: true
    BranchesID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OrderCategoryCountAggregateInputType = {
    ID?: true
    TypeCode?: true
    TypeNmae?: true
    Remask?: true
    BranchesID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type OrderCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderCategory to aggregate.
     */
    where?: orderCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderCategories to fetch.
     */
    orderBy?: orderCategoryOrderByWithRelationInput | orderCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: orderCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orderCategories
    **/
    _count?: true | OrderCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderCategoryMaxAggregateInputType
  }

  export type GetOrderCategoryAggregateType<T extends OrderCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderCategory[P]>
      : GetScalarType<T[P], AggregateOrderCategory[P]>
  }




  export type orderCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderCategoryWhereInput
    orderBy?: orderCategoryOrderByWithAggregationInput | orderCategoryOrderByWithAggregationInput[]
    by: OrderCategoryScalarFieldEnum[] | OrderCategoryScalarFieldEnum
    having?: orderCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCategoryCountAggregateInputType | true
    _min?: OrderCategoryMinAggregateInputType
    _max?: OrderCategoryMaxAggregateInputType
  }

  export type OrderCategoryGroupByOutputType = {
    ID: string
    TypeCode: string | null
    TypeNmae: string | null
    Remask: string | null
    BranchesID: string | null
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: OrderCategoryCountAggregateOutputType | null
    _min: OrderCategoryMinAggregateOutputType | null
    _max: OrderCategoryMaxAggregateOutputType | null
  }

  type GetOrderCategoryGroupByPayload<T extends orderCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], OrderCategoryGroupByOutputType[P]>
        }
      >
    >


  export type orderCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    TypeCode?: boolean
    TypeNmae?: boolean
    Remask?: boolean
    BranchesID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Branches?: boolean | orderCategory$BranchesArgs<ExtArgs>
    Order?: boolean | orderCategory$OrderArgs<ExtArgs>
    _count?: boolean | OrderCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderCategory"]>

  export type orderCategorySelectScalar = {
    ID?: boolean
    TypeCode?: boolean
    TypeNmae?: boolean
    Remask?: boolean
    BranchesID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type orderCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Branches?: boolean | orderCategory$BranchesArgs<ExtArgs>
    Order?: boolean | orderCategory$OrderArgs<ExtArgs>
    _count?: boolean | OrderCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $orderCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "orderCategory"
    objects: {
      Branches: Prisma.$branchesPayload<ExtArgs> | null
      Order: Prisma.$orderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      TypeCode: string | null
      TypeNmae: string | null
      Remask: string | null
      BranchesID: string | null
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["orderCategory"]>
    composites: {}
  }


  type orderCategoryGetPayload<S extends boolean | null | undefined | orderCategoryDefaultArgs> = $Result.GetResult<Prisma.$orderCategoryPayload, S>

  type orderCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<orderCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCategoryCountAggregateInputType | true
    }

  export interface orderCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['orderCategory'], meta: { name: 'orderCategory' } }
    /**
     * Find zero or one OrderCategory that matches the filter.
     * @param {orderCategoryFindUniqueArgs} args - Arguments to find a OrderCategory
     * @example
     * // Get one OrderCategory
     * const orderCategory = await prisma.orderCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends orderCategoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, orderCategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__orderCategoryClient<$Result.GetResult<Prisma.$orderCategoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrderCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {orderCategoryFindUniqueOrThrowArgs} args - Arguments to find a OrderCategory
     * @example
     * // Get one OrderCategory
     * const orderCategory = await prisma.orderCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends orderCategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderCategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__orderCategoryClient<$Result.GetResult<Prisma.$orderCategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrderCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderCategoryFindFirstArgs} args - Arguments to find a OrderCategory
     * @example
     * // Get one OrderCategory
     * const orderCategory = await prisma.orderCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends orderCategoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, orderCategoryFindFirstArgs<ExtArgs>>
    ): Prisma__orderCategoryClient<$Result.GetResult<Prisma.$orderCategoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrderCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderCategoryFindFirstOrThrowArgs} args - Arguments to find a OrderCategory
     * @example
     * // Get one OrderCategory
     * const orderCategory = await prisma.orderCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends orderCategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderCategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__orderCategoryClient<$Result.GetResult<Prisma.$orderCategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrderCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderCategories
     * const orderCategories = await prisma.orderCategory.findMany()
     * 
     * // Get first 10 OrderCategories
     * const orderCategories = await prisma.orderCategory.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const orderCategoryWithIDOnly = await prisma.orderCategory.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends orderCategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderCategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderCategoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrderCategory.
     * @param {orderCategoryCreateArgs} args - Arguments to create a OrderCategory.
     * @example
     * // Create one OrderCategory
     * const OrderCategory = await prisma.orderCategory.create({
     *   data: {
     *     // ... data to create a OrderCategory
     *   }
     * })
     * 
    **/
    create<T extends orderCategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, orderCategoryCreateArgs<ExtArgs>>
    ): Prisma__orderCategoryClient<$Result.GetResult<Prisma.$orderCategoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrderCategories.
     * @param {orderCategoryCreateManyArgs} args - Arguments to create many OrderCategories.
     * @example
     * // Create many OrderCategories
     * const orderCategory = await prisma.orderCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends orderCategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderCategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderCategory.
     * @param {orderCategoryDeleteArgs} args - Arguments to delete one OrderCategory.
     * @example
     * // Delete one OrderCategory
     * const OrderCategory = await prisma.orderCategory.delete({
     *   where: {
     *     // ... filter to delete one OrderCategory
     *   }
     * })
     * 
    **/
    delete<T extends orderCategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, orderCategoryDeleteArgs<ExtArgs>>
    ): Prisma__orderCategoryClient<$Result.GetResult<Prisma.$orderCategoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrderCategory.
     * @param {orderCategoryUpdateArgs} args - Arguments to update one OrderCategory.
     * @example
     * // Update one OrderCategory
     * const orderCategory = await prisma.orderCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends orderCategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, orderCategoryUpdateArgs<ExtArgs>>
    ): Prisma__orderCategoryClient<$Result.GetResult<Prisma.$orderCategoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrderCategories.
     * @param {orderCategoryDeleteManyArgs} args - Arguments to filter OrderCategories to delete.
     * @example
     * // Delete a few OrderCategories
     * const { count } = await prisma.orderCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends orderCategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderCategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderCategories
     * const orderCategory = await prisma.orderCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends orderCategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, orderCategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderCategory.
     * @param {orderCategoryUpsertArgs} args - Arguments to update or create a OrderCategory.
     * @example
     * // Update or create a OrderCategory
     * const orderCategory = await prisma.orderCategory.upsert({
     *   create: {
     *     // ... data to create a OrderCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderCategory we want to update
     *   }
     * })
    **/
    upsert<T extends orderCategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, orderCategoryUpsertArgs<ExtArgs>>
    ): Prisma__orderCategoryClient<$Result.GetResult<Prisma.$orderCategoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrderCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderCategoryCountArgs} args - Arguments to filter OrderCategories to count.
     * @example
     * // Count the number of OrderCategories
     * const count = await prisma.orderCategory.count({
     *   where: {
     *     // ... the filter for the OrderCategories we want to count
     *   }
     * })
    **/
    count<T extends orderCategoryCountArgs>(
      args?: Subset<T, orderCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderCategoryAggregateArgs>(args: Subset<T, OrderCategoryAggregateArgs>): Prisma.PrismaPromise<GetOrderCategoryAggregateType<T>>

    /**
     * Group by OrderCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends orderCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: orderCategoryGroupByArgs['orderBy'] }
        : { orderBy?: orderCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, orderCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the orderCategory model
   */
  readonly fields: orderCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for orderCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__orderCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Branches<T extends orderCategory$BranchesArgs<ExtArgs> = {}>(args?: Subset<T, orderCategory$BranchesArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Order<T extends orderCategory$OrderArgs<ExtArgs> = {}>(args?: Subset<T, orderCategory$OrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the orderCategory model
   */ 
  interface orderCategoryFieldRefs {
    readonly ID: FieldRef<"orderCategory", 'String'>
    readonly TypeCode: FieldRef<"orderCategory", 'String'>
    readonly TypeNmae: FieldRef<"orderCategory", 'String'>
    readonly Remask: FieldRef<"orderCategory", 'String'>
    readonly BranchesID: FieldRef<"orderCategory", 'String'>
    readonly Status: FieldRef<"orderCategory", 'String'>
    readonly IsActive: FieldRef<"orderCategory", 'Boolean'>
    readonly CreatedAt: FieldRef<"orderCategory", 'DateTime'>
    readonly UpdatedAt: FieldRef<"orderCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * orderCategory findUnique
   */
  export type orderCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderCategory
     */
    select?: orderCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderCategoryInclude<ExtArgs> | null
    /**
     * Filter, which orderCategory to fetch.
     */
    where: orderCategoryWhereUniqueInput
  }

  /**
   * orderCategory findUniqueOrThrow
   */
  export type orderCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderCategory
     */
    select?: orderCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderCategoryInclude<ExtArgs> | null
    /**
     * Filter, which orderCategory to fetch.
     */
    where: orderCategoryWhereUniqueInput
  }

  /**
   * orderCategory findFirst
   */
  export type orderCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderCategory
     */
    select?: orderCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderCategoryInclude<ExtArgs> | null
    /**
     * Filter, which orderCategory to fetch.
     */
    where?: orderCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderCategories to fetch.
     */
    orderBy?: orderCategoryOrderByWithRelationInput | orderCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderCategories.
     */
    cursor?: orderCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderCategories.
     */
    distinct?: OrderCategoryScalarFieldEnum | OrderCategoryScalarFieldEnum[]
  }

  /**
   * orderCategory findFirstOrThrow
   */
  export type orderCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderCategory
     */
    select?: orderCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderCategoryInclude<ExtArgs> | null
    /**
     * Filter, which orderCategory to fetch.
     */
    where?: orderCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderCategories to fetch.
     */
    orderBy?: orderCategoryOrderByWithRelationInput | orderCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderCategories.
     */
    cursor?: orderCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderCategories.
     */
    distinct?: OrderCategoryScalarFieldEnum | OrderCategoryScalarFieldEnum[]
  }

  /**
   * orderCategory findMany
   */
  export type orderCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderCategory
     */
    select?: orderCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderCategoryInclude<ExtArgs> | null
    /**
     * Filter, which orderCategories to fetch.
     */
    where?: orderCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderCategories to fetch.
     */
    orderBy?: orderCategoryOrderByWithRelationInput | orderCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orderCategories.
     */
    cursor?: orderCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderCategories.
     */
    skip?: number
    distinct?: OrderCategoryScalarFieldEnum | OrderCategoryScalarFieldEnum[]
  }

  /**
   * orderCategory create
   */
  export type orderCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderCategory
     */
    select?: orderCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a orderCategory.
     */
    data?: XOR<orderCategoryCreateInput, orderCategoryUncheckedCreateInput>
  }

  /**
   * orderCategory createMany
   */
  export type orderCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orderCategories.
     */
    data: orderCategoryCreateManyInput | orderCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * orderCategory update
   */
  export type orderCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderCategory
     */
    select?: orderCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a orderCategory.
     */
    data: XOR<orderCategoryUpdateInput, orderCategoryUncheckedUpdateInput>
    /**
     * Choose, which orderCategory to update.
     */
    where: orderCategoryWhereUniqueInput
  }

  /**
   * orderCategory updateMany
   */
  export type orderCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orderCategories.
     */
    data: XOR<orderCategoryUpdateManyMutationInput, orderCategoryUncheckedUpdateManyInput>
    /**
     * Filter which orderCategories to update
     */
    where?: orderCategoryWhereInput
  }

  /**
   * orderCategory upsert
   */
  export type orderCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderCategory
     */
    select?: orderCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the orderCategory to update in case it exists.
     */
    where: orderCategoryWhereUniqueInput
    /**
     * In case the orderCategory found by the `where` argument doesn't exist, create a new orderCategory with this data.
     */
    create: XOR<orderCategoryCreateInput, orderCategoryUncheckedCreateInput>
    /**
     * In case the orderCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<orderCategoryUpdateInput, orderCategoryUncheckedUpdateInput>
  }

  /**
   * orderCategory delete
   */
  export type orderCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderCategory
     */
    select?: orderCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderCategoryInclude<ExtArgs> | null
    /**
     * Filter which orderCategory to delete.
     */
    where: orderCategoryWhereUniqueInput
  }

  /**
   * orderCategory deleteMany
   */
  export type orderCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderCategories to delete
     */
    where?: orderCategoryWhereInput
  }

  /**
   * orderCategory.Branches
   */
  export type orderCategory$BranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * orderCategory.Order
   */
  export type orderCategory$OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    cursor?: orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * orderCategory without action
   */
  export type orderCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderCategory
     */
    select?: orderCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderCategoryInclude<ExtArgs> | null
  }


  /**
   * Model order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderMinAggregateOutputType = {
    ID: string | null
    Code: string | null
    PrimaryCode: string | null
    SecondaryCode: string | null
    OrderDate: Date | null
    Name: string | null
    UplaodURL: string | null
    CategoryID: string | null
    BranchesID: string | null
    CreateByID: string | null
    Remask: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    ID: string | null
    Code: string | null
    PrimaryCode: string | null
    SecondaryCode: string | null
    OrderDate: Date | null
    Name: string | null
    UplaodURL: string | null
    CategoryID: string | null
    BranchesID: string | null
    CreateByID: string | null
    Remask: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    ID: number
    Code: number
    PrimaryCode: number
    SecondaryCode: number
    OrderDate: number
    Name: number
    UplaodURL: number
    CategoryID: number
    BranchesID: number
    CreateByID: number
    Remask: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type OrderMinAggregateInputType = {
    ID?: true
    Code?: true
    PrimaryCode?: true
    SecondaryCode?: true
    OrderDate?: true
    Name?: true
    UplaodURL?: true
    CategoryID?: true
    BranchesID?: true
    CreateByID?: true
    Remask?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    ID?: true
    Code?: true
    PrimaryCode?: true
    SecondaryCode?: true
    OrderDate?: true
    Name?: true
    UplaodURL?: true
    CategoryID?: true
    BranchesID?: true
    CreateByID?: true
    Remask?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    ID?: true
    Code?: true
    PrimaryCode?: true
    SecondaryCode?: true
    OrderDate?: true
    Name?: true
    UplaodURL?: true
    CategoryID?: true
    BranchesID?: true
    CreateByID?: true
    Remask?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order to aggregate.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type orderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
    orderBy?: orderOrderByWithAggregationInput | orderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: orderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    ID: string
    Code: string | null
    PrimaryCode: string | null
    SecondaryCode: string | null
    OrderDate: Date | null
    Name: string | null
    UplaodURL: string | null
    CategoryID: string | null
    BranchesID: string | null
    CreateByID: string | null
    Remask: string | null
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends orderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type orderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Code?: boolean
    PrimaryCode?: boolean
    SecondaryCode?: boolean
    OrderDate?: boolean
    Name?: boolean
    UplaodURL?: boolean
    CategoryID?: boolean
    BranchesID?: boolean
    CreateByID?: boolean
    Remask?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Category?: boolean | order$CategoryArgs<ExtArgs>
    Personal?: boolean | order$PersonalArgs<ExtArgs>
    Details?: boolean | order$DetailsArgs<ExtArgs>
    Payment?: boolean | order$PaymentArgs<ExtArgs>
    Branches?: boolean | order$BranchesArgs<ExtArgs>
    CreateBy?: boolean | order$CreateByArgs<ExtArgs>
    Tacking?: boolean | order$TackingArgs<ExtArgs>
    Threading?: boolean | order$ThreadingArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type orderSelectScalar = {
    ID?: boolean
    Code?: boolean
    PrimaryCode?: boolean
    SecondaryCode?: boolean
    OrderDate?: boolean
    Name?: boolean
    UplaodURL?: boolean
    CategoryID?: boolean
    BranchesID?: boolean
    CreateByID?: boolean
    Remask?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type orderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Category?: boolean | order$CategoryArgs<ExtArgs>
    Personal?: boolean | order$PersonalArgs<ExtArgs>
    Details?: boolean | order$DetailsArgs<ExtArgs>
    Payment?: boolean | order$PaymentArgs<ExtArgs>
    Branches?: boolean | order$BranchesArgs<ExtArgs>
    CreateBy?: boolean | order$CreateByArgs<ExtArgs>
    Tacking?: boolean | order$TackingArgs<ExtArgs>
    Threading?: boolean | order$ThreadingArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $orderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order"
    objects: {
      Category: Prisma.$orderCategoryPayload<ExtArgs> | null
      Personal: Prisma.$orderPersonalPayload<ExtArgs> | null
      Details: Prisma.$orderDetailsPayload<ExtArgs> | null
      Payment: Prisma.$orderPaymentPayload<ExtArgs> | null
      Branches: Prisma.$branchesPayload<ExtArgs> | null
      CreateBy: Prisma.$usersPayload<ExtArgs> | null
      Tacking: Prisma.$orderTackingPayload<ExtArgs>[]
      Threading: Prisma.$orderThreadingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Code: string | null
      PrimaryCode: string | null
      SecondaryCode: string | null
      OrderDate: Date | null
      Name: string | null
      UplaodURL: string | null
      CategoryID: string | null
      BranchesID: string | null
      CreateByID: string | null
      Remask: string | null
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }


  type orderGetPayload<S extends boolean | null | undefined | orderDefaultArgs> = $Result.GetResult<Prisma.$orderPayload, S>

  type orderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<orderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface orderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order'], meta: { name: 'order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {orderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends orderFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, orderFindUniqueArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {orderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends orderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends orderFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, orderFindFirstArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends orderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const orderWithIDOnly = await prisma.order.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends orderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Order.
     * @param {orderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends orderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, orderCreateArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {orderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends orderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {orderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends orderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, orderDeleteArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Order.
     * @param {orderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends orderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, orderUpdateArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {orderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends orderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends orderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, orderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {orderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends orderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, orderUpsertArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends orderCountArgs>(
      args?: Subset<T, orderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends orderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: orderGroupByArgs['orderBy'] }
        : { orderBy?: orderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, orderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order model
   */
  readonly fields: orderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__orderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Category<T extends order$CategoryArgs<ExtArgs> = {}>(args?: Subset<T, order$CategoryArgs<ExtArgs>>): Prisma__orderCategoryClient<$Result.GetResult<Prisma.$orderCategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Personal<T extends order$PersonalArgs<ExtArgs> = {}>(args?: Subset<T, order$PersonalArgs<ExtArgs>>): Prisma__orderPersonalClient<$Result.GetResult<Prisma.$orderPersonalPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Details<T extends order$DetailsArgs<ExtArgs> = {}>(args?: Subset<T, order$DetailsArgs<ExtArgs>>): Prisma__orderDetailsClient<$Result.GetResult<Prisma.$orderDetailsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Payment<T extends order$PaymentArgs<ExtArgs> = {}>(args?: Subset<T, order$PaymentArgs<ExtArgs>>): Prisma__orderPaymentClient<$Result.GetResult<Prisma.$orderPaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Branches<T extends order$BranchesArgs<ExtArgs> = {}>(args?: Subset<T, order$BranchesArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    CreateBy<T extends order$CreateByArgs<ExtArgs> = {}>(args?: Subset<T, order$CreateByArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Tacking<T extends order$TackingArgs<ExtArgs> = {}>(args?: Subset<T, order$TackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderTackingPayload<ExtArgs>, T, 'findMany'> | Null>;

    Threading<T extends order$ThreadingArgs<ExtArgs> = {}>(args?: Subset<T, order$ThreadingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderThreadingPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the order model
   */ 
  interface orderFieldRefs {
    readonly ID: FieldRef<"order", 'String'>
    readonly Code: FieldRef<"order", 'String'>
    readonly PrimaryCode: FieldRef<"order", 'String'>
    readonly SecondaryCode: FieldRef<"order", 'String'>
    readonly OrderDate: FieldRef<"order", 'DateTime'>
    readonly Name: FieldRef<"order", 'String'>
    readonly UplaodURL: FieldRef<"order", 'String'>
    readonly CategoryID: FieldRef<"order", 'String'>
    readonly BranchesID: FieldRef<"order", 'String'>
    readonly CreateByID: FieldRef<"order", 'String'>
    readonly Remask: FieldRef<"order", 'String'>
    readonly Status: FieldRef<"order", 'String'>
    readonly IsActive: FieldRef<"order", 'Boolean'>
    readonly CreatedAt: FieldRef<"order", 'DateTime'>
    readonly UpdatedAt: FieldRef<"order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * order findUnique
   */
  export type orderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where: orderWhereUniqueInput
  }

  /**
   * order findUniqueOrThrow
   */
  export type orderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where: orderWhereUniqueInput
  }

  /**
   * order findFirst
   */
  export type orderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * order findFirstOrThrow
   */
  export type orderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * order findMany
   */
  export type orderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * order create
   */
  export type orderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * The data needed to create a order.
     */
    data?: XOR<orderCreateInput, orderUncheckedCreateInput>
  }

  /**
   * order createMany
   */
  export type orderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orders.
     */
    data: orderCreateManyInput | orderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * order update
   */
  export type orderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * The data needed to update a order.
     */
    data: XOR<orderUpdateInput, orderUncheckedUpdateInput>
    /**
     * Choose, which order to update.
     */
    where: orderWhereUniqueInput
  }

  /**
   * order updateMany
   */
  export type orderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orders.
     */
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     */
    where?: orderWhereInput
  }

  /**
   * order upsert
   */
  export type orderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * The filter to search for the order to update in case it exists.
     */
    where: orderWhereUniqueInput
    /**
     * In case the order found by the `where` argument doesn't exist, create a new order with this data.
     */
    create: XOR<orderCreateInput, orderUncheckedCreateInput>
    /**
     * In case the order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<orderUpdateInput, orderUncheckedUpdateInput>
  }

  /**
   * order delete
   */
  export type orderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter which order to delete.
     */
    where: orderWhereUniqueInput
  }

  /**
   * order deleteMany
   */
  export type orderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orders to delete
     */
    where?: orderWhereInput
  }

  /**
   * order.Category
   */
  export type order$CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderCategory
     */
    select?: orderCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderCategoryInclude<ExtArgs> | null
    where?: orderCategoryWhereInput
  }

  /**
   * order.Personal
   */
  export type order$PersonalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPersonal
     */
    select?: orderPersonalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPersonalInclude<ExtArgs> | null
    where?: orderPersonalWhereInput
  }

  /**
   * order.Details
   */
  export type order$DetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderDetails
     */
    select?: orderDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderDetailsInclude<ExtArgs> | null
    where?: orderDetailsWhereInput
  }

  /**
   * order.Payment
   */
  export type order$PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPayment
     */
    select?: orderPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPaymentInclude<ExtArgs> | null
    where?: orderPaymentWhereInput
  }

  /**
   * order.Branches
   */
  export type order$BranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * order.CreateBy
   */
  export type order$CreateByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * order.Tacking
   */
  export type order$TackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderTacking
     */
    select?: orderTackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderTackingInclude<ExtArgs> | null
    where?: orderTackingWhereInput
    orderBy?: orderTackingOrderByWithRelationInput | orderTackingOrderByWithRelationInput[]
    cursor?: orderTackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderTackingScalarFieldEnum | OrderTackingScalarFieldEnum[]
  }

  /**
   * order.Threading
   */
  export type order$ThreadingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderThreading
     */
    select?: orderThreadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderThreadingInclude<ExtArgs> | null
    where?: orderThreadingWhereInput
    orderBy?: orderThreadingOrderByWithRelationInput | orderThreadingOrderByWithRelationInput[]
    cursor?: orderThreadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderThreadingScalarFieldEnum | OrderThreadingScalarFieldEnum[]
  }

  /**
   * order without action
   */
  export type orderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
  }


  /**
   * Model orderThreading
   */

  export type AggregateOrderThreading = {
    _count: OrderThreadingCountAggregateOutputType | null
    _min: OrderThreadingMinAggregateOutputType | null
    _max: OrderThreadingMaxAggregateOutputType | null
  }

  export type OrderThreadingMinAggregateOutputType = {
    ID: string | null
    Tasks: string | null
    ActivitieID: string | null
    OrderID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OrderThreadingMaxAggregateOutputType = {
    ID: string | null
    Tasks: string | null
    ActivitieID: string | null
    OrderID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OrderThreadingCountAggregateOutputType = {
    ID: number
    Tasks: number
    ActivitieID: number
    OrderID: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type OrderThreadingMinAggregateInputType = {
    ID?: true
    Tasks?: true
    ActivitieID?: true
    OrderID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OrderThreadingMaxAggregateInputType = {
    ID?: true
    Tasks?: true
    ActivitieID?: true
    OrderID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OrderThreadingCountAggregateInputType = {
    ID?: true
    Tasks?: true
    ActivitieID?: true
    OrderID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type OrderThreadingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderThreading to aggregate.
     */
    where?: orderThreadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderThreadings to fetch.
     */
    orderBy?: orderThreadingOrderByWithRelationInput | orderThreadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: orderThreadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderThreadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderThreadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orderThreadings
    **/
    _count?: true | OrderThreadingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderThreadingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderThreadingMaxAggregateInputType
  }

  export type GetOrderThreadingAggregateType<T extends OrderThreadingAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderThreading]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderThreading[P]>
      : GetScalarType<T[P], AggregateOrderThreading[P]>
  }




  export type orderThreadingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderThreadingWhereInput
    orderBy?: orderThreadingOrderByWithAggregationInput | orderThreadingOrderByWithAggregationInput[]
    by: OrderThreadingScalarFieldEnum[] | OrderThreadingScalarFieldEnum
    having?: orderThreadingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderThreadingCountAggregateInputType | true
    _min?: OrderThreadingMinAggregateInputType
    _max?: OrderThreadingMaxAggregateInputType
  }

  export type OrderThreadingGroupByOutputType = {
    ID: string
    Tasks: string | null
    ActivitieID: string | null
    OrderID: string | null
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: OrderThreadingCountAggregateOutputType | null
    _min: OrderThreadingMinAggregateOutputType | null
    _max: OrderThreadingMaxAggregateOutputType | null
  }

  type GetOrderThreadingGroupByPayload<T extends orderThreadingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderThreadingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderThreadingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderThreadingGroupByOutputType[P]>
            : GetScalarType<T[P], OrderThreadingGroupByOutputType[P]>
        }
      >
    >


  export type orderThreadingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Tasks?: boolean
    ActivitieID?: boolean
    OrderID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Activitie?: boolean | orderThreading$ActivitieArgs<ExtArgs>
    Order?: boolean | orderThreading$OrderArgs<ExtArgs>
  }, ExtArgs["result"]["orderThreading"]>

  export type orderThreadingSelectScalar = {
    ID?: boolean
    Tasks?: boolean
    ActivitieID?: boolean
    OrderID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type orderThreadingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Activitie?: boolean | orderThreading$ActivitieArgs<ExtArgs>
    Order?: boolean | orderThreading$OrderArgs<ExtArgs>
  }


  export type $orderThreadingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "orderThreading"
    objects: {
      Activitie: Prisma.$usersActivitiesPayload<ExtArgs> | null
      Order: Prisma.$orderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Tasks: string | null
      ActivitieID: string | null
      OrderID: string | null
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["orderThreading"]>
    composites: {}
  }


  type orderThreadingGetPayload<S extends boolean | null | undefined | orderThreadingDefaultArgs> = $Result.GetResult<Prisma.$orderThreadingPayload, S>

  type orderThreadingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<orderThreadingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderThreadingCountAggregateInputType | true
    }

  export interface orderThreadingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['orderThreading'], meta: { name: 'orderThreading' } }
    /**
     * Find zero or one OrderThreading that matches the filter.
     * @param {orderThreadingFindUniqueArgs} args - Arguments to find a OrderThreading
     * @example
     * // Get one OrderThreading
     * const orderThreading = await prisma.orderThreading.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends orderThreadingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, orderThreadingFindUniqueArgs<ExtArgs>>
    ): Prisma__orderThreadingClient<$Result.GetResult<Prisma.$orderThreadingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrderThreading that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {orderThreadingFindUniqueOrThrowArgs} args - Arguments to find a OrderThreading
     * @example
     * // Get one OrderThreading
     * const orderThreading = await prisma.orderThreading.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends orderThreadingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderThreadingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__orderThreadingClient<$Result.GetResult<Prisma.$orderThreadingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrderThreading that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderThreadingFindFirstArgs} args - Arguments to find a OrderThreading
     * @example
     * // Get one OrderThreading
     * const orderThreading = await prisma.orderThreading.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends orderThreadingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, orderThreadingFindFirstArgs<ExtArgs>>
    ): Prisma__orderThreadingClient<$Result.GetResult<Prisma.$orderThreadingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrderThreading that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderThreadingFindFirstOrThrowArgs} args - Arguments to find a OrderThreading
     * @example
     * // Get one OrderThreading
     * const orderThreading = await prisma.orderThreading.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends orderThreadingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderThreadingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__orderThreadingClient<$Result.GetResult<Prisma.$orderThreadingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrderThreadings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderThreadingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderThreadings
     * const orderThreadings = await prisma.orderThreading.findMany()
     * 
     * // Get first 10 OrderThreadings
     * const orderThreadings = await prisma.orderThreading.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const orderThreadingWithIDOnly = await prisma.orderThreading.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends orderThreadingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderThreadingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderThreadingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrderThreading.
     * @param {orderThreadingCreateArgs} args - Arguments to create a OrderThreading.
     * @example
     * // Create one OrderThreading
     * const OrderThreading = await prisma.orderThreading.create({
     *   data: {
     *     // ... data to create a OrderThreading
     *   }
     * })
     * 
    **/
    create<T extends orderThreadingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, orderThreadingCreateArgs<ExtArgs>>
    ): Prisma__orderThreadingClient<$Result.GetResult<Prisma.$orderThreadingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrderThreadings.
     * @param {orderThreadingCreateManyArgs} args - Arguments to create many OrderThreadings.
     * @example
     * // Create many OrderThreadings
     * const orderThreading = await prisma.orderThreading.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends orderThreadingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderThreadingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderThreading.
     * @param {orderThreadingDeleteArgs} args - Arguments to delete one OrderThreading.
     * @example
     * // Delete one OrderThreading
     * const OrderThreading = await prisma.orderThreading.delete({
     *   where: {
     *     // ... filter to delete one OrderThreading
     *   }
     * })
     * 
    **/
    delete<T extends orderThreadingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, orderThreadingDeleteArgs<ExtArgs>>
    ): Prisma__orderThreadingClient<$Result.GetResult<Prisma.$orderThreadingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrderThreading.
     * @param {orderThreadingUpdateArgs} args - Arguments to update one OrderThreading.
     * @example
     * // Update one OrderThreading
     * const orderThreading = await prisma.orderThreading.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends orderThreadingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, orderThreadingUpdateArgs<ExtArgs>>
    ): Prisma__orderThreadingClient<$Result.GetResult<Prisma.$orderThreadingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrderThreadings.
     * @param {orderThreadingDeleteManyArgs} args - Arguments to filter OrderThreadings to delete.
     * @example
     * // Delete a few OrderThreadings
     * const { count } = await prisma.orderThreading.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends orderThreadingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderThreadingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderThreadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderThreadingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderThreadings
     * const orderThreading = await prisma.orderThreading.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends orderThreadingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, orderThreadingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderThreading.
     * @param {orderThreadingUpsertArgs} args - Arguments to update or create a OrderThreading.
     * @example
     * // Update or create a OrderThreading
     * const orderThreading = await prisma.orderThreading.upsert({
     *   create: {
     *     // ... data to create a OrderThreading
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderThreading we want to update
     *   }
     * })
    **/
    upsert<T extends orderThreadingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, orderThreadingUpsertArgs<ExtArgs>>
    ): Prisma__orderThreadingClient<$Result.GetResult<Prisma.$orderThreadingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrderThreadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderThreadingCountArgs} args - Arguments to filter OrderThreadings to count.
     * @example
     * // Count the number of OrderThreadings
     * const count = await prisma.orderThreading.count({
     *   where: {
     *     // ... the filter for the OrderThreadings we want to count
     *   }
     * })
    **/
    count<T extends orderThreadingCountArgs>(
      args?: Subset<T, orderThreadingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderThreadingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderThreading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderThreadingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderThreadingAggregateArgs>(args: Subset<T, OrderThreadingAggregateArgs>): Prisma.PrismaPromise<GetOrderThreadingAggregateType<T>>

    /**
     * Group by OrderThreading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderThreadingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends orderThreadingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: orderThreadingGroupByArgs['orderBy'] }
        : { orderBy?: orderThreadingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, orderThreadingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderThreadingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the orderThreading model
   */
  readonly fields: orderThreadingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for orderThreading.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__orderThreadingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Activitie<T extends orderThreading$ActivitieArgs<ExtArgs> = {}>(args?: Subset<T, orderThreading$ActivitieArgs<ExtArgs>>): Prisma__usersActivitiesClient<$Result.GetResult<Prisma.$usersActivitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Order<T extends orderThreading$OrderArgs<ExtArgs> = {}>(args?: Subset<T, orderThreading$OrderArgs<ExtArgs>>): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the orderThreading model
   */ 
  interface orderThreadingFieldRefs {
    readonly ID: FieldRef<"orderThreading", 'String'>
    readonly Tasks: FieldRef<"orderThreading", 'String'>
    readonly ActivitieID: FieldRef<"orderThreading", 'String'>
    readonly OrderID: FieldRef<"orderThreading", 'String'>
    readonly Status: FieldRef<"orderThreading", 'String'>
    readonly IsActive: FieldRef<"orderThreading", 'Boolean'>
    readonly CreatedAt: FieldRef<"orderThreading", 'DateTime'>
    readonly UpdatedAt: FieldRef<"orderThreading", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * orderThreading findUnique
   */
  export type orderThreadingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderThreading
     */
    select?: orderThreadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderThreadingInclude<ExtArgs> | null
    /**
     * Filter, which orderThreading to fetch.
     */
    where: orderThreadingWhereUniqueInput
  }

  /**
   * orderThreading findUniqueOrThrow
   */
  export type orderThreadingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderThreading
     */
    select?: orderThreadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderThreadingInclude<ExtArgs> | null
    /**
     * Filter, which orderThreading to fetch.
     */
    where: orderThreadingWhereUniqueInput
  }

  /**
   * orderThreading findFirst
   */
  export type orderThreadingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderThreading
     */
    select?: orderThreadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderThreadingInclude<ExtArgs> | null
    /**
     * Filter, which orderThreading to fetch.
     */
    where?: orderThreadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderThreadings to fetch.
     */
    orderBy?: orderThreadingOrderByWithRelationInput | orderThreadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderThreadings.
     */
    cursor?: orderThreadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderThreadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderThreadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderThreadings.
     */
    distinct?: OrderThreadingScalarFieldEnum | OrderThreadingScalarFieldEnum[]
  }

  /**
   * orderThreading findFirstOrThrow
   */
  export type orderThreadingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderThreading
     */
    select?: orderThreadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderThreadingInclude<ExtArgs> | null
    /**
     * Filter, which orderThreading to fetch.
     */
    where?: orderThreadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderThreadings to fetch.
     */
    orderBy?: orderThreadingOrderByWithRelationInput | orderThreadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderThreadings.
     */
    cursor?: orderThreadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderThreadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderThreadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderThreadings.
     */
    distinct?: OrderThreadingScalarFieldEnum | OrderThreadingScalarFieldEnum[]
  }

  /**
   * orderThreading findMany
   */
  export type orderThreadingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderThreading
     */
    select?: orderThreadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderThreadingInclude<ExtArgs> | null
    /**
     * Filter, which orderThreadings to fetch.
     */
    where?: orderThreadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderThreadings to fetch.
     */
    orderBy?: orderThreadingOrderByWithRelationInput | orderThreadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orderThreadings.
     */
    cursor?: orderThreadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderThreadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderThreadings.
     */
    skip?: number
    distinct?: OrderThreadingScalarFieldEnum | OrderThreadingScalarFieldEnum[]
  }

  /**
   * orderThreading create
   */
  export type orderThreadingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderThreading
     */
    select?: orderThreadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderThreadingInclude<ExtArgs> | null
    /**
     * The data needed to create a orderThreading.
     */
    data?: XOR<orderThreadingCreateInput, orderThreadingUncheckedCreateInput>
  }

  /**
   * orderThreading createMany
   */
  export type orderThreadingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orderThreadings.
     */
    data: orderThreadingCreateManyInput | orderThreadingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * orderThreading update
   */
  export type orderThreadingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderThreading
     */
    select?: orderThreadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderThreadingInclude<ExtArgs> | null
    /**
     * The data needed to update a orderThreading.
     */
    data: XOR<orderThreadingUpdateInput, orderThreadingUncheckedUpdateInput>
    /**
     * Choose, which orderThreading to update.
     */
    where: orderThreadingWhereUniqueInput
  }

  /**
   * orderThreading updateMany
   */
  export type orderThreadingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orderThreadings.
     */
    data: XOR<orderThreadingUpdateManyMutationInput, orderThreadingUncheckedUpdateManyInput>
    /**
     * Filter which orderThreadings to update
     */
    where?: orderThreadingWhereInput
  }

  /**
   * orderThreading upsert
   */
  export type orderThreadingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderThreading
     */
    select?: orderThreadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderThreadingInclude<ExtArgs> | null
    /**
     * The filter to search for the orderThreading to update in case it exists.
     */
    where: orderThreadingWhereUniqueInput
    /**
     * In case the orderThreading found by the `where` argument doesn't exist, create a new orderThreading with this data.
     */
    create: XOR<orderThreadingCreateInput, orderThreadingUncheckedCreateInput>
    /**
     * In case the orderThreading was found with the provided `where` argument, update it with this data.
     */
    update: XOR<orderThreadingUpdateInput, orderThreadingUncheckedUpdateInput>
  }

  /**
   * orderThreading delete
   */
  export type orderThreadingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderThreading
     */
    select?: orderThreadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderThreadingInclude<ExtArgs> | null
    /**
     * Filter which orderThreading to delete.
     */
    where: orderThreadingWhereUniqueInput
  }

  /**
   * orderThreading deleteMany
   */
  export type orderThreadingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderThreadings to delete
     */
    where?: orderThreadingWhereInput
  }

  /**
   * orderThreading.Activitie
   */
  export type orderThreading$ActivitieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersActivities
     */
    select?: usersActivitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersActivitiesInclude<ExtArgs> | null
    where?: usersActivitiesWhereInput
  }

  /**
   * orderThreading.Order
   */
  export type orderThreading$OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
  }

  /**
   * orderThreading without action
   */
  export type orderThreadingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderThreading
     */
    select?: orderThreadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderThreadingInclude<ExtArgs> | null
  }


  /**
   * Model orderPersonal
   */

  export type AggregateOrderPersonal = {
    _count: OrderPersonalCountAggregateOutputType | null
    _min: OrderPersonalMinAggregateOutputType | null
    _max: OrderPersonalMaxAggregateOutputType | null
  }

  export type OrderPersonalMinAggregateOutputType = {
    ID: string | null
    SenderName: string | null
    SenderPhoneNumber: string | null
    SenderUserID: string | null
    RecipientName: string | null
    RecipientPhoneNumber: string | null
    RecipientID: string | null
    OrderID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OrderPersonalMaxAggregateOutputType = {
    ID: string | null
    SenderName: string | null
    SenderPhoneNumber: string | null
    SenderUserID: string | null
    RecipientName: string | null
    RecipientPhoneNumber: string | null
    RecipientID: string | null
    OrderID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OrderPersonalCountAggregateOutputType = {
    ID: number
    SenderName: number
    SenderPhoneNumber: number
    SenderUserID: number
    RecipientName: number
    RecipientPhoneNumber: number
    RecipientID: number
    OrderID: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type OrderPersonalMinAggregateInputType = {
    ID?: true
    SenderName?: true
    SenderPhoneNumber?: true
    SenderUserID?: true
    RecipientName?: true
    RecipientPhoneNumber?: true
    RecipientID?: true
    OrderID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OrderPersonalMaxAggregateInputType = {
    ID?: true
    SenderName?: true
    SenderPhoneNumber?: true
    SenderUserID?: true
    RecipientName?: true
    RecipientPhoneNumber?: true
    RecipientID?: true
    OrderID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OrderPersonalCountAggregateInputType = {
    ID?: true
    SenderName?: true
    SenderPhoneNumber?: true
    SenderUserID?: true
    RecipientName?: true
    RecipientPhoneNumber?: true
    RecipientID?: true
    OrderID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type OrderPersonalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderPersonal to aggregate.
     */
    where?: orderPersonalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderPersonals to fetch.
     */
    orderBy?: orderPersonalOrderByWithRelationInput | orderPersonalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: orderPersonalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderPersonals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderPersonals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orderPersonals
    **/
    _count?: true | OrderPersonalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderPersonalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderPersonalMaxAggregateInputType
  }

  export type GetOrderPersonalAggregateType<T extends OrderPersonalAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderPersonal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderPersonal[P]>
      : GetScalarType<T[P], AggregateOrderPersonal[P]>
  }




  export type orderPersonalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderPersonalWhereInput
    orderBy?: orderPersonalOrderByWithAggregationInput | orderPersonalOrderByWithAggregationInput[]
    by: OrderPersonalScalarFieldEnum[] | OrderPersonalScalarFieldEnum
    having?: orderPersonalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderPersonalCountAggregateInputType | true
    _min?: OrderPersonalMinAggregateInputType
    _max?: OrderPersonalMaxAggregateInputType
  }

  export type OrderPersonalGroupByOutputType = {
    ID: string
    SenderName: string | null
    SenderPhoneNumber: string | null
    SenderUserID: string | null
    RecipientName: string | null
    RecipientPhoneNumber: string | null
    RecipientID: string | null
    OrderID: string | null
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: OrderPersonalCountAggregateOutputType | null
    _min: OrderPersonalMinAggregateOutputType | null
    _max: OrderPersonalMaxAggregateOutputType | null
  }

  type GetOrderPersonalGroupByPayload<T extends orderPersonalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderPersonalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderPersonalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderPersonalGroupByOutputType[P]>
            : GetScalarType<T[P], OrderPersonalGroupByOutputType[P]>
        }
      >
    >


  export type orderPersonalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    SenderName?: boolean
    SenderPhoneNumber?: boolean
    SenderUserID?: boolean
    RecipientName?: boolean
    RecipientPhoneNumber?: boolean
    RecipientID?: boolean
    OrderID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    SenderUser?: boolean | orderPersonal$SenderUserArgs<ExtArgs>
    RecipientUser?: boolean | orderPersonal$RecipientUserArgs<ExtArgs>
    Order?: boolean | orderPersonal$OrderArgs<ExtArgs>
  }, ExtArgs["result"]["orderPersonal"]>

  export type orderPersonalSelectScalar = {
    ID?: boolean
    SenderName?: boolean
    SenderPhoneNumber?: boolean
    SenderUserID?: boolean
    RecipientName?: boolean
    RecipientPhoneNumber?: boolean
    RecipientID?: boolean
    OrderID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type orderPersonalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SenderUser?: boolean | orderPersonal$SenderUserArgs<ExtArgs>
    RecipientUser?: boolean | orderPersonal$RecipientUserArgs<ExtArgs>
    Order?: boolean | orderPersonal$OrderArgs<ExtArgs>
  }


  export type $orderPersonalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "orderPersonal"
    objects: {
      SenderUser: Prisma.$usersPayload<ExtArgs> | null
      RecipientUser: Prisma.$usersPayload<ExtArgs> | null
      Order: Prisma.$orderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      SenderName: string | null
      SenderPhoneNumber: string | null
      SenderUserID: string | null
      RecipientName: string | null
      RecipientPhoneNumber: string | null
      RecipientID: string | null
      OrderID: string | null
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["orderPersonal"]>
    composites: {}
  }


  type orderPersonalGetPayload<S extends boolean | null | undefined | orderPersonalDefaultArgs> = $Result.GetResult<Prisma.$orderPersonalPayload, S>

  type orderPersonalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<orderPersonalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderPersonalCountAggregateInputType | true
    }

  export interface orderPersonalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['orderPersonal'], meta: { name: 'orderPersonal' } }
    /**
     * Find zero or one OrderPersonal that matches the filter.
     * @param {orderPersonalFindUniqueArgs} args - Arguments to find a OrderPersonal
     * @example
     * // Get one OrderPersonal
     * const orderPersonal = await prisma.orderPersonal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends orderPersonalFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, orderPersonalFindUniqueArgs<ExtArgs>>
    ): Prisma__orderPersonalClient<$Result.GetResult<Prisma.$orderPersonalPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrderPersonal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {orderPersonalFindUniqueOrThrowArgs} args - Arguments to find a OrderPersonal
     * @example
     * // Get one OrderPersonal
     * const orderPersonal = await prisma.orderPersonal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends orderPersonalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderPersonalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__orderPersonalClient<$Result.GetResult<Prisma.$orderPersonalPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrderPersonal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderPersonalFindFirstArgs} args - Arguments to find a OrderPersonal
     * @example
     * // Get one OrderPersonal
     * const orderPersonal = await prisma.orderPersonal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends orderPersonalFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, orderPersonalFindFirstArgs<ExtArgs>>
    ): Prisma__orderPersonalClient<$Result.GetResult<Prisma.$orderPersonalPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrderPersonal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderPersonalFindFirstOrThrowArgs} args - Arguments to find a OrderPersonal
     * @example
     * // Get one OrderPersonal
     * const orderPersonal = await prisma.orderPersonal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends orderPersonalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderPersonalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__orderPersonalClient<$Result.GetResult<Prisma.$orderPersonalPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrderPersonals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderPersonalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderPersonals
     * const orderPersonals = await prisma.orderPersonal.findMany()
     * 
     * // Get first 10 OrderPersonals
     * const orderPersonals = await prisma.orderPersonal.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const orderPersonalWithIDOnly = await prisma.orderPersonal.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends orderPersonalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderPersonalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPersonalPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrderPersonal.
     * @param {orderPersonalCreateArgs} args - Arguments to create a OrderPersonal.
     * @example
     * // Create one OrderPersonal
     * const OrderPersonal = await prisma.orderPersonal.create({
     *   data: {
     *     // ... data to create a OrderPersonal
     *   }
     * })
     * 
    **/
    create<T extends orderPersonalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, orderPersonalCreateArgs<ExtArgs>>
    ): Prisma__orderPersonalClient<$Result.GetResult<Prisma.$orderPersonalPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrderPersonals.
     * @param {orderPersonalCreateManyArgs} args - Arguments to create many OrderPersonals.
     * @example
     * // Create many OrderPersonals
     * const orderPersonal = await prisma.orderPersonal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends orderPersonalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderPersonalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderPersonal.
     * @param {orderPersonalDeleteArgs} args - Arguments to delete one OrderPersonal.
     * @example
     * // Delete one OrderPersonal
     * const OrderPersonal = await prisma.orderPersonal.delete({
     *   where: {
     *     // ... filter to delete one OrderPersonal
     *   }
     * })
     * 
    **/
    delete<T extends orderPersonalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, orderPersonalDeleteArgs<ExtArgs>>
    ): Prisma__orderPersonalClient<$Result.GetResult<Prisma.$orderPersonalPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrderPersonal.
     * @param {orderPersonalUpdateArgs} args - Arguments to update one OrderPersonal.
     * @example
     * // Update one OrderPersonal
     * const orderPersonal = await prisma.orderPersonal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends orderPersonalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, orderPersonalUpdateArgs<ExtArgs>>
    ): Prisma__orderPersonalClient<$Result.GetResult<Prisma.$orderPersonalPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrderPersonals.
     * @param {orderPersonalDeleteManyArgs} args - Arguments to filter OrderPersonals to delete.
     * @example
     * // Delete a few OrderPersonals
     * const { count } = await prisma.orderPersonal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends orderPersonalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderPersonalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderPersonals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderPersonalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderPersonals
     * const orderPersonal = await prisma.orderPersonal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends orderPersonalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, orderPersonalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderPersonal.
     * @param {orderPersonalUpsertArgs} args - Arguments to update or create a OrderPersonal.
     * @example
     * // Update or create a OrderPersonal
     * const orderPersonal = await prisma.orderPersonal.upsert({
     *   create: {
     *     // ... data to create a OrderPersonal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderPersonal we want to update
     *   }
     * })
    **/
    upsert<T extends orderPersonalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, orderPersonalUpsertArgs<ExtArgs>>
    ): Prisma__orderPersonalClient<$Result.GetResult<Prisma.$orderPersonalPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrderPersonals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderPersonalCountArgs} args - Arguments to filter OrderPersonals to count.
     * @example
     * // Count the number of OrderPersonals
     * const count = await prisma.orderPersonal.count({
     *   where: {
     *     // ... the filter for the OrderPersonals we want to count
     *   }
     * })
    **/
    count<T extends orderPersonalCountArgs>(
      args?: Subset<T, orderPersonalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderPersonalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderPersonal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPersonalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderPersonalAggregateArgs>(args: Subset<T, OrderPersonalAggregateArgs>): Prisma.PrismaPromise<GetOrderPersonalAggregateType<T>>

    /**
     * Group by OrderPersonal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderPersonalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends orderPersonalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: orderPersonalGroupByArgs['orderBy'] }
        : { orderBy?: orderPersonalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, orderPersonalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderPersonalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the orderPersonal model
   */
  readonly fields: orderPersonalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for orderPersonal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__orderPersonalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    SenderUser<T extends orderPersonal$SenderUserArgs<ExtArgs> = {}>(args?: Subset<T, orderPersonal$SenderUserArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    RecipientUser<T extends orderPersonal$RecipientUserArgs<ExtArgs> = {}>(args?: Subset<T, orderPersonal$RecipientUserArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Order<T extends orderPersonal$OrderArgs<ExtArgs> = {}>(args?: Subset<T, orderPersonal$OrderArgs<ExtArgs>>): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the orderPersonal model
   */ 
  interface orderPersonalFieldRefs {
    readonly ID: FieldRef<"orderPersonal", 'String'>
    readonly SenderName: FieldRef<"orderPersonal", 'String'>
    readonly SenderPhoneNumber: FieldRef<"orderPersonal", 'String'>
    readonly SenderUserID: FieldRef<"orderPersonal", 'String'>
    readonly RecipientName: FieldRef<"orderPersonal", 'String'>
    readonly RecipientPhoneNumber: FieldRef<"orderPersonal", 'String'>
    readonly RecipientID: FieldRef<"orderPersonal", 'String'>
    readonly OrderID: FieldRef<"orderPersonal", 'String'>
    readonly Status: FieldRef<"orderPersonal", 'String'>
    readonly IsActive: FieldRef<"orderPersonal", 'Boolean'>
    readonly CreatedAt: FieldRef<"orderPersonal", 'DateTime'>
    readonly UpdatedAt: FieldRef<"orderPersonal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * orderPersonal findUnique
   */
  export type orderPersonalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPersonal
     */
    select?: orderPersonalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPersonalInclude<ExtArgs> | null
    /**
     * Filter, which orderPersonal to fetch.
     */
    where: orderPersonalWhereUniqueInput
  }

  /**
   * orderPersonal findUniqueOrThrow
   */
  export type orderPersonalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPersonal
     */
    select?: orderPersonalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPersonalInclude<ExtArgs> | null
    /**
     * Filter, which orderPersonal to fetch.
     */
    where: orderPersonalWhereUniqueInput
  }

  /**
   * orderPersonal findFirst
   */
  export type orderPersonalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPersonal
     */
    select?: orderPersonalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPersonalInclude<ExtArgs> | null
    /**
     * Filter, which orderPersonal to fetch.
     */
    where?: orderPersonalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderPersonals to fetch.
     */
    orderBy?: orderPersonalOrderByWithRelationInput | orderPersonalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderPersonals.
     */
    cursor?: orderPersonalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderPersonals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderPersonals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderPersonals.
     */
    distinct?: OrderPersonalScalarFieldEnum | OrderPersonalScalarFieldEnum[]
  }

  /**
   * orderPersonal findFirstOrThrow
   */
  export type orderPersonalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPersonal
     */
    select?: orderPersonalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPersonalInclude<ExtArgs> | null
    /**
     * Filter, which orderPersonal to fetch.
     */
    where?: orderPersonalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderPersonals to fetch.
     */
    orderBy?: orderPersonalOrderByWithRelationInput | orderPersonalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderPersonals.
     */
    cursor?: orderPersonalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderPersonals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderPersonals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderPersonals.
     */
    distinct?: OrderPersonalScalarFieldEnum | OrderPersonalScalarFieldEnum[]
  }

  /**
   * orderPersonal findMany
   */
  export type orderPersonalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPersonal
     */
    select?: orderPersonalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPersonalInclude<ExtArgs> | null
    /**
     * Filter, which orderPersonals to fetch.
     */
    where?: orderPersonalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderPersonals to fetch.
     */
    orderBy?: orderPersonalOrderByWithRelationInput | orderPersonalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orderPersonals.
     */
    cursor?: orderPersonalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderPersonals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderPersonals.
     */
    skip?: number
    distinct?: OrderPersonalScalarFieldEnum | OrderPersonalScalarFieldEnum[]
  }

  /**
   * orderPersonal create
   */
  export type orderPersonalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPersonal
     */
    select?: orderPersonalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPersonalInclude<ExtArgs> | null
    /**
     * The data needed to create a orderPersonal.
     */
    data?: XOR<orderPersonalCreateInput, orderPersonalUncheckedCreateInput>
  }

  /**
   * orderPersonal createMany
   */
  export type orderPersonalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orderPersonals.
     */
    data: orderPersonalCreateManyInput | orderPersonalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * orderPersonal update
   */
  export type orderPersonalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPersonal
     */
    select?: orderPersonalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPersonalInclude<ExtArgs> | null
    /**
     * The data needed to update a orderPersonal.
     */
    data: XOR<orderPersonalUpdateInput, orderPersonalUncheckedUpdateInput>
    /**
     * Choose, which orderPersonal to update.
     */
    where: orderPersonalWhereUniqueInput
  }

  /**
   * orderPersonal updateMany
   */
  export type orderPersonalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orderPersonals.
     */
    data: XOR<orderPersonalUpdateManyMutationInput, orderPersonalUncheckedUpdateManyInput>
    /**
     * Filter which orderPersonals to update
     */
    where?: orderPersonalWhereInput
  }

  /**
   * orderPersonal upsert
   */
  export type orderPersonalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPersonal
     */
    select?: orderPersonalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPersonalInclude<ExtArgs> | null
    /**
     * The filter to search for the orderPersonal to update in case it exists.
     */
    where: orderPersonalWhereUniqueInput
    /**
     * In case the orderPersonal found by the `where` argument doesn't exist, create a new orderPersonal with this data.
     */
    create: XOR<orderPersonalCreateInput, orderPersonalUncheckedCreateInput>
    /**
     * In case the orderPersonal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<orderPersonalUpdateInput, orderPersonalUncheckedUpdateInput>
  }

  /**
   * orderPersonal delete
   */
  export type orderPersonalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPersonal
     */
    select?: orderPersonalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPersonalInclude<ExtArgs> | null
    /**
     * Filter which orderPersonal to delete.
     */
    where: orderPersonalWhereUniqueInput
  }

  /**
   * orderPersonal deleteMany
   */
  export type orderPersonalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderPersonals to delete
     */
    where?: orderPersonalWhereInput
  }

  /**
   * orderPersonal.SenderUser
   */
  export type orderPersonal$SenderUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * orderPersonal.RecipientUser
   */
  export type orderPersonal$RecipientUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * orderPersonal.Order
   */
  export type orderPersonal$OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
  }

  /**
   * orderPersonal without action
   */
  export type orderPersonalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPersonal
     */
    select?: orderPersonalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPersonalInclude<ExtArgs> | null
  }


  /**
   * Model orderPayment
   */

  export type AggregateOrderPayment = {
    _count: OrderPaymentCountAggregateOutputType | null
    _avg: OrderPaymentAvgAggregateOutputType | null
    _sum: OrderPaymentSumAggregateOutputType | null
    _min: OrderPaymentMinAggregateOutputType | null
    _max: OrderPaymentMaxAggregateOutputType | null
  }

  export type OrderPaymentAvgAggregateOutputType = {
    AmountDeliver: number | null
  }

  export type OrderPaymentSumAggregateOutputType = {
    AmountDeliver: number | null
  }

  export type OrderPaymentMinAggregateOutputType = {
    ID: string | null
    PaymentStatus: string | null
    AmountDeliver: number | null
    IsPaid: boolean | null
    OrderID: string | null
    PaidToID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OrderPaymentMaxAggregateOutputType = {
    ID: string | null
    PaymentStatus: string | null
    AmountDeliver: number | null
    IsPaid: boolean | null
    OrderID: string | null
    PaidToID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OrderPaymentCountAggregateOutputType = {
    ID: number
    PaymentStatus: number
    AmountDeliver: number
    IsPaid: number
    OrderID: number
    PaidToID: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type OrderPaymentAvgAggregateInputType = {
    AmountDeliver?: true
  }

  export type OrderPaymentSumAggregateInputType = {
    AmountDeliver?: true
  }

  export type OrderPaymentMinAggregateInputType = {
    ID?: true
    PaymentStatus?: true
    AmountDeliver?: true
    IsPaid?: true
    OrderID?: true
    PaidToID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OrderPaymentMaxAggregateInputType = {
    ID?: true
    PaymentStatus?: true
    AmountDeliver?: true
    IsPaid?: true
    OrderID?: true
    PaidToID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OrderPaymentCountAggregateInputType = {
    ID?: true
    PaymentStatus?: true
    AmountDeliver?: true
    IsPaid?: true
    OrderID?: true
    PaidToID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type OrderPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderPayment to aggregate.
     */
    where?: orderPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderPayments to fetch.
     */
    orderBy?: orderPaymentOrderByWithRelationInput | orderPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: orderPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orderPayments
    **/
    _count?: true | OrderPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderPaymentMaxAggregateInputType
  }

  export type GetOrderPaymentAggregateType<T extends OrderPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderPayment[P]>
      : GetScalarType<T[P], AggregateOrderPayment[P]>
  }




  export type orderPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderPaymentWhereInput
    orderBy?: orderPaymentOrderByWithAggregationInput | orderPaymentOrderByWithAggregationInput[]
    by: OrderPaymentScalarFieldEnum[] | OrderPaymentScalarFieldEnum
    having?: orderPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderPaymentCountAggregateInputType | true
    _avg?: OrderPaymentAvgAggregateInputType
    _sum?: OrderPaymentSumAggregateInputType
    _min?: OrderPaymentMinAggregateInputType
    _max?: OrderPaymentMaxAggregateInputType
  }

  export type OrderPaymentGroupByOutputType = {
    ID: string
    PaymentStatus: string | null
    AmountDeliver: number | null
    IsPaid: boolean
    OrderID: string | null
    PaidToID: string | null
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: OrderPaymentCountAggregateOutputType | null
    _avg: OrderPaymentAvgAggregateOutputType | null
    _sum: OrderPaymentSumAggregateOutputType | null
    _min: OrderPaymentMinAggregateOutputType | null
    _max: OrderPaymentMaxAggregateOutputType | null
  }

  type GetOrderPaymentGroupByPayload<T extends orderPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], OrderPaymentGroupByOutputType[P]>
        }
      >
    >


  export type orderPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    PaymentStatus?: boolean
    AmountDeliver?: boolean
    IsPaid?: boolean
    OrderID?: boolean
    PaidToID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Order?: boolean | orderPayment$OrderArgs<ExtArgs>
    PaidTo?: boolean | orderPayment$PaidToArgs<ExtArgs>
    Transaction?: boolean | orderPayment$TransactionArgs<ExtArgs>
  }, ExtArgs["result"]["orderPayment"]>

  export type orderPaymentSelectScalar = {
    ID?: boolean
    PaymentStatus?: boolean
    AmountDeliver?: boolean
    IsPaid?: boolean
    OrderID?: boolean
    PaidToID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type orderPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Order?: boolean | orderPayment$OrderArgs<ExtArgs>
    PaidTo?: boolean | orderPayment$PaidToArgs<ExtArgs>
    Transaction?: boolean | orderPayment$TransactionArgs<ExtArgs>
  }


  export type $orderPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "orderPayment"
    objects: {
      Order: Prisma.$orderPayload<ExtArgs> | null
      PaidTo: Prisma.$usersPayload<ExtArgs> | null
      Transaction: Prisma.$transactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      PaymentStatus: string | null
      AmountDeliver: number | null
      IsPaid: boolean
      OrderID: string | null
      PaidToID: string | null
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["orderPayment"]>
    composites: {}
  }


  type orderPaymentGetPayload<S extends boolean | null | undefined | orderPaymentDefaultArgs> = $Result.GetResult<Prisma.$orderPaymentPayload, S>

  type orderPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<orderPaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderPaymentCountAggregateInputType | true
    }

  export interface orderPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['orderPayment'], meta: { name: 'orderPayment' } }
    /**
     * Find zero or one OrderPayment that matches the filter.
     * @param {orderPaymentFindUniqueArgs} args - Arguments to find a OrderPayment
     * @example
     * // Get one OrderPayment
     * const orderPayment = await prisma.orderPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends orderPaymentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, orderPaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__orderPaymentClient<$Result.GetResult<Prisma.$orderPaymentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrderPayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {orderPaymentFindUniqueOrThrowArgs} args - Arguments to find a OrderPayment
     * @example
     * // Get one OrderPayment
     * const orderPayment = await prisma.orderPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends orderPaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderPaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__orderPaymentClient<$Result.GetResult<Prisma.$orderPaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrderPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderPaymentFindFirstArgs} args - Arguments to find a OrderPayment
     * @example
     * // Get one OrderPayment
     * const orderPayment = await prisma.orderPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends orderPaymentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, orderPaymentFindFirstArgs<ExtArgs>>
    ): Prisma__orderPaymentClient<$Result.GetResult<Prisma.$orderPaymentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrderPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderPaymentFindFirstOrThrowArgs} args - Arguments to find a OrderPayment
     * @example
     * // Get one OrderPayment
     * const orderPayment = await prisma.orderPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends orderPaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderPaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__orderPaymentClient<$Result.GetResult<Prisma.$orderPaymentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrderPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderPayments
     * const orderPayments = await prisma.orderPayment.findMany()
     * 
     * // Get first 10 OrderPayments
     * const orderPayments = await prisma.orderPayment.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const orderPaymentWithIDOnly = await prisma.orderPayment.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends orderPaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderPaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPaymentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrderPayment.
     * @param {orderPaymentCreateArgs} args - Arguments to create a OrderPayment.
     * @example
     * // Create one OrderPayment
     * const OrderPayment = await prisma.orderPayment.create({
     *   data: {
     *     // ... data to create a OrderPayment
     *   }
     * })
     * 
    **/
    create<T extends orderPaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, orderPaymentCreateArgs<ExtArgs>>
    ): Prisma__orderPaymentClient<$Result.GetResult<Prisma.$orderPaymentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrderPayments.
     * @param {orderPaymentCreateManyArgs} args - Arguments to create many OrderPayments.
     * @example
     * // Create many OrderPayments
     * const orderPayment = await prisma.orderPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends orderPaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderPaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderPayment.
     * @param {orderPaymentDeleteArgs} args - Arguments to delete one OrderPayment.
     * @example
     * // Delete one OrderPayment
     * const OrderPayment = await prisma.orderPayment.delete({
     *   where: {
     *     // ... filter to delete one OrderPayment
     *   }
     * })
     * 
    **/
    delete<T extends orderPaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, orderPaymentDeleteArgs<ExtArgs>>
    ): Prisma__orderPaymentClient<$Result.GetResult<Prisma.$orderPaymentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrderPayment.
     * @param {orderPaymentUpdateArgs} args - Arguments to update one OrderPayment.
     * @example
     * // Update one OrderPayment
     * const orderPayment = await prisma.orderPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends orderPaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, orderPaymentUpdateArgs<ExtArgs>>
    ): Prisma__orderPaymentClient<$Result.GetResult<Prisma.$orderPaymentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrderPayments.
     * @param {orderPaymentDeleteManyArgs} args - Arguments to filter OrderPayments to delete.
     * @example
     * // Delete a few OrderPayments
     * const { count } = await prisma.orderPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends orderPaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderPaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderPayments
     * const orderPayment = await prisma.orderPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends orderPaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, orderPaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderPayment.
     * @param {orderPaymentUpsertArgs} args - Arguments to update or create a OrderPayment.
     * @example
     * // Update or create a OrderPayment
     * const orderPayment = await prisma.orderPayment.upsert({
     *   create: {
     *     // ... data to create a OrderPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderPayment we want to update
     *   }
     * })
    **/
    upsert<T extends orderPaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, orderPaymentUpsertArgs<ExtArgs>>
    ): Prisma__orderPaymentClient<$Result.GetResult<Prisma.$orderPaymentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrderPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderPaymentCountArgs} args - Arguments to filter OrderPayments to count.
     * @example
     * // Count the number of OrderPayments
     * const count = await prisma.orderPayment.count({
     *   where: {
     *     // ... the filter for the OrderPayments we want to count
     *   }
     * })
    **/
    count<T extends orderPaymentCountArgs>(
      args?: Subset<T, orderPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderPaymentAggregateArgs>(args: Subset<T, OrderPaymentAggregateArgs>): Prisma.PrismaPromise<GetOrderPaymentAggregateType<T>>

    /**
     * Group by OrderPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends orderPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: orderPaymentGroupByArgs['orderBy'] }
        : { orderBy?: orderPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, orderPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the orderPayment model
   */
  readonly fields: orderPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for orderPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__orderPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Order<T extends orderPayment$OrderArgs<ExtArgs> = {}>(args?: Subset<T, orderPayment$OrderArgs<ExtArgs>>): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    PaidTo<T extends orderPayment$PaidToArgs<ExtArgs> = {}>(args?: Subset<T, orderPayment$PaidToArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Transaction<T extends orderPayment$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, orderPayment$TransactionArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the orderPayment model
   */ 
  interface orderPaymentFieldRefs {
    readonly ID: FieldRef<"orderPayment", 'String'>
    readonly PaymentStatus: FieldRef<"orderPayment", 'String'>
    readonly AmountDeliver: FieldRef<"orderPayment", 'Float'>
    readonly IsPaid: FieldRef<"orderPayment", 'Boolean'>
    readonly OrderID: FieldRef<"orderPayment", 'String'>
    readonly PaidToID: FieldRef<"orderPayment", 'String'>
    readonly Status: FieldRef<"orderPayment", 'String'>
    readonly IsActive: FieldRef<"orderPayment", 'Boolean'>
    readonly CreatedAt: FieldRef<"orderPayment", 'DateTime'>
    readonly UpdatedAt: FieldRef<"orderPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * orderPayment findUnique
   */
  export type orderPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPayment
     */
    select?: orderPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPaymentInclude<ExtArgs> | null
    /**
     * Filter, which orderPayment to fetch.
     */
    where: orderPaymentWhereUniqueInput
  }

  /**
   * orderPayment findUniqueOrThrow
   */
  export type orderPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPayment
     */
    select?: orderPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPaymentInclude<ExtArgs> | null
    /**
     * Filter, which orderPayment to fetch.
     */
    where: orderPaymentWhereUniqueInput
  }

  /**
   * orderPayment findFirst
   */
  export type orderPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPayment
     */
    select?: orderPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPaymentInclude<ExtArgs> | null
    /**
     * Filter, which orderPayment to fetch.
     */
    where?: orderPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderPayments to fetch.
     */
    orderBy?: orderPaymentOrderByWithRelationInput | orderPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderPayments.
     */
    cursor?: orderPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderPayments.
     */
    distinct?: OrderPaymentScalarFieldEnum | OrderPaymentScalarFieldEnum[]
  }

  /**
   * orderPayment findFirstOrThrow
   */
  export type orderPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPayment
     */
    select?: orderPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPaymentInclude<ExtArgs> | null
    /**
     * Filter, which orderPayment to fetch.
     */
    where?: orderPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderPayments to fetch.
     */
    orderBy?: orderPaymentOrderByWithRelationInput | orderPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderPayments.
     */
    cursor?: orderPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderPayments.
     */
    distinct?: OrderPaymentScalarFieldEnum | OrderPaymentScalarFieldEnum[]
  }

  /**
   * orderPayment findMany
   */
  export type orderPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPayment
     */
    select?: orderPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPaymentInclude<ExtArgs> | null
    /**
     * Filter, which orderPayments to fetch.
     */
    where?: orderPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderPayments to fetch.
     */
    orderBy?: orderPaymentOrderByWithRelationInput | orderPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orderPayments.
     */
    cursor?: orderPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderPayments.
     */
    skip?: number
    distinct?: OrderPaymentScalarFieldEnum | OrderPaymentScalarFieldEnum[]
  }

  /**
   * orderPayment create
   */
  export type orderPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPayment
     */
    select?: orderPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a orderPayment.
     */
    data?: XOR<orderPaymentCreateInput, orderPaymentUncheckedCreateInput>
  }

  /**
   * orderPayment createMany
   */
  export type orderPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orderPayments.
     */
    data: orderPaymentCreateManyInput | orderPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * orderPayment update
   */
  export type orderPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPayment
     */
    select?: orderPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a orderPayment.
     */
    data: XOR<orderPaymentUpdateInput, orderPaymentUncheckedUpdateInput>
    /**
     * Choose, which orderPayment to update.
     */
    where: orderPaymentWhereUniqueInput
  }

  /**
   * orderPayment updateMany
   */
  export type orderPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orderPayments.
     */
    data: XOR<orderPaymentUpdateManyMutationInput, orderPaymentUncheckedUpdateManyInput>
    /**
     * Filter which orderPayments to update
     */
    where?: orderPaymentWhereInput
  }

  /**
   * orderPayment upsert
   */
  export type orderPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPayment
     */
    select?: orderPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the orderPayment to update in case it exists.
     */
    where: orderPaymentWhereUniqueInput
    /**
     * In case the orderPayment found by the `where` argument doesn't exist, create a new orderPayment with this data.
     */
    create: XOR<orderPaymentCreateInput, orderPaymentUncheckedCreateInput>
    /**
     * In case the orderPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<orderPaymentUpdateInput, orderPaymentUncheckedUpdateInput>
  }

  /**
   * orderPayment delete
   */
  export type orderPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPayment
     */
    select?: orderPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPaymentInclude<ExtArgs> | null
    /**
     * Filter which orderPayment to delete.
     */
    where: orderPaymentWhereUniqueInput
  }

  /**
   * orderPayment deleteMany
   */
  export type orderPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderPayments to delete
     */
    where?: orderPaymentWhereInput
  }

  /**
   * orderPayment.Order
   */
  export type orderPayment$OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
  }

  /**
   * orderPayment.PaidTo
   */
  export type orderPayment$PaidToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * orderPayment.Transaction
   */
  export type orderPayment$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    where?: transactionWhereInput
  }

  /**
   * orderPayment without action
   */
  export type orderPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderPayment
     */
    select?: orderPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderPaymentInclude<ExtArgs> | null
  }


  /**
   * Model orderDetails
   */

  export type AggregateOrderDetails = {
    _count: OrderDetailsCountAggregateOutputType | null
    _avg: OrderDetailsAvgAggregateOutputType | null
    _sum: OrderDetailsSumAggregateOutputType | null
    _min: OrderDetailsMinAggregateOutputType | null
    _max: OrderDetailsMaxAggregateOutputType | null
  }

  export type OrderDetailsAvgAggregateOutputType = {
    AmountX: number | null
    AmountY: number | null
    AmountH: number | null
    AmountW: number | null
    Amount: number | null
  }

  export type OrderDetailsSumAggregateOutputType = {
    AmountX: number | null
    AmountY: number | null
    AmountH: number | null
    AmountW: number | null
    Amount: number | null
  }

  export type OrderDetailsMinAggregateOutputType = {
    ID: string | null
    Detail: string | null
    AmountX: number | null
    AmountY: number | null
    AmountH: number | null
    AmountW: number | null
    Amount: number | null
    OrderID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OrderDetailsMaxAggregateOutputType = {
    ID: string | null
    Detail: string | null
    AmountX: number | null
    AmountY: number | null
    AmountH: number | null
    AmountW: number | null
    Amount: number | null
    OrderID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OrderDetailsCountAggregateOutputType = {
    ID: number
    Detail: number
    AmountX: number
    AmountY: number
    AmountH: number
    AmountW: number
    Amount: number
    OrderID: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type OrderDetailsAvgAggregateInputType = {
    AmountX?: true
    AmountY?: true
    AmountH?: true
    AmountW?: true
    Amount?: true
  }

  export type OrderDetailsSumAggregateInputType = {
    AmountX?: true
    AmountY?: true
    AmountH?: true
    AmountW?: true
    Amount?: true
  }

  export type OrderDetailsMinAggregateInputType = {
    ID?: true
    Detail?: true
    AmountX?: true
    AmountY?: true
    AmountH?: true
    AmountW?: true
    Amount?: true
    OrderID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OrderDetailsMaxAggregateInputType = {
    ID?: true
    Detail?: true
    AmountX?: true
    AmountY?: true
    AmountH?: true
    AmountW?: true
    Amount?: true
    OrderID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OrderDetailsCountAggregateInputType = {
    ID?: true
    Detail?: true
    AmountX?: true
    AmountY?: true
    AmountH?: true
    AmountW?: true
    Amount?: true
    OrderID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type OrderDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderDetails to aggregate.
     */
    where?: orderDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderDetails to fetch.
     */
    orderBy?: orderDetailsOrderByWithRelationInput | orderDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: orderDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orderDetails
    **/
    _count?: true | OrderDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderDetailsMaxAggregateInputType
  }

  export type GetOrderDetailsAggregateType<T extends OrderDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderDetails[P]>
      : GetScalarType<T[P], AggregateOrderDetails[P]>
  }




  export type orderDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderDetailsWhereInput
    orderBy?: orderDetailsOrderByWithAggregationInput | orderDetailsOrderByWithAggregationInput[]
    by: OrderDetailsScalarFieldEnum[] | OrderDetailsScalarFieldEnum
    having?: orderDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderDetailsCountAggregateInputType | true
    _avg?: OrderDetailsAvgAggregateInputType
    _sum?: OrderDetailsSumAggregateInputType
    _min?: OrderDetailsMinAggregateInputType
    _max?: OrderDetailsMaxAggregateInputType
  }

  export type OrderDetailsGroupByOutputType = {
    ID: string
    Detail: string | null
    AmountX: number | null
    AmountY: number | null
    AmountH: number | null
    AmountW: number | null
    Amount: number | null
    OrderID: string | null
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: OrderDetailsCountAggregateOutputType | null
    _avg: OrderDetailsAvgAggregateOutputType | null
    _sum: OrderDetailsSumAggregateOutputType | null
    _min: OrderDetailsMinAggregateOutputType | null
    _max: OrderDetailsMaxAggregateOutputType | null
  }

  type GetOrderDetailsGroupByPayload<T extends orderDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], OrderDetailsGroupByOutputType[P]>
        }
      >
    >


  export type orderDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Detail?: boolean
    AmountX?: boolean
    AmountY?: boolean
    AmountH?: boolean
    AmountW?: boolean
    Amount?: boolean
    OrderID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Order?: boolean | orderDetails$OrderArgs<ExtArgs>
  }, ExtArgs["result"]["orderDetails"]>

  export type orderDetailsSelectScalar = {
    ID?: boolean
    Detail?: boolean
    AmountX?: boolean
    AmountY?: boolean
    AmountH?: boolean
    AmountW?: boolean
    Amount?: boolean
    OrderID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type orderDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Order?: boolean | orderDetails$OrderArgs<ExtArgs>
  }


  export type $orderDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "orderDetails"
    objects: {
      Order: Prisma.$orderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Detail: string | null
      AmountX: number | null
      AmountY: number | null
      AmountH: number | null
      AmountW: number | null
      Amount: number | null
      OrderID: string | null
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["orderDetails"]>
    composites: {}
  }


  type orderDetailsGetPayload<S extends boolean | null | undefined | orderDetailsDefaultArgs> = $Result.GetResult<Prisma.$orderDetailsPayload, S>

  type orderDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<orderDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderDetailsCountAggregateInputType | true
    }

  export interface orderDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['orderDetails'], meta: { name: 'orderDetails' } }
    /**
     * Find zero or one OrderDetails that matches the filter.
     * @param {orderDetailsFindUniqueArgs} args - Arguments to find a OrderDetails
     * @example
     * // Get one OrderDetails
     * const orderDetails = await prisma.orderDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends orderDetailsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, orderDetailsFindUniqueArgs<ExtArgs>>
    ): Prisma__orderDetailsClient<$Result.GetResult<Prisma.$orderDetailsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrderDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {orderDetailsFindUniqueOrThrowArgs} args - Arguments to find a OrderDetails
     * @example
     * // Get one OrderDetails
     * const orderDetails = await prisma.orderDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends orderDetailsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderDetailsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__orderDetailsClient<$Result.GetResult<Prisma.$orderDetailsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrderDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderDetailsFindFirstArgs} args - Arguments to find a OrderDetails
     * @example
     * // Get one OrderDetails
     * const orderDetails = await prisma.orderDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends orderDetailsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, orderDetailsFindFirstArgs<ExtArgs>>
    ): Prisma__orderDetailsClient<$Result.GetResult<Prisma.$orderDetailsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrderDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderDetailsFindFirstOrThrowArgs} args - Arguments to find a OrderDetails
     * @example
     * // Get one OrderDetails
     * const orderDetails = await prisma.orderDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends orderDetailsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderDetailsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__orderDetailsClient<$Result.GetResult<Prisma.$orderDetailsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrderDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderDetails
     * const orderDetails = await prisma.orderDetails.findMany()
     * 
     * // Get first 10 OrderDetails
     * const orderDetails = await prisma.orderDetails.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const orderDetailsWithIDOnly = await prisma.orderDetails.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends orderDetailsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderDetailsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderDetailsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrderDetails.
     * @param {orderDetailsCreateArgs} args - Arguments to create a OrderDetails.
     * @example
     * // Create one OrderDetails
     * const OrderDetails = await prisma.orderDetails.create({
     *   data: {
     *     // ... data to create a OrderDetails
     *   }
     * })
     * 
    **/
    create<T extends orderDetailsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, orderDetailsCreateArgs<ExtArgs>>
    ): Prisma__orderDetailsClient<$Result.GetResult<Prisma.$orderDetailsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrderDetails.
     * @param {orderDetailsCreateManyArgs} args - Arguments to create many OrderDetails.
     * @example
     * // Create many OrderDetails
     * const orderDetails = await prisma.orderDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends orderDetailsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderDetailsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderDetails.
     * @param {orderDetailsDeleteArgs} args - Arguments to delete one OrderDetails.
     * @example
     * // Delete one OrderDetails
     * const OrderDetails = await prisma.orderDetails.delete({
     *   where: {
     *     // ... filter to delete one OrderDetails
     *   }
     * })
     * 
    **/
    delete<T extends orderDetailsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, orderDetailsDeleteArgs<ExtArgs>>
    ): Prisma__orderDetailsClient<$Result.GetResult<Prisma.$orderDetailsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrderDetails.
     * @param {orderDetailsUpdateArgs} args - Arguments to update one OrderDetails.
     * @example
     * // Update one OrderDetails
     * const orderDetails = await prisma.orderDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends orderDetailsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, orderDetailsUpdateArgs<ExtArgs>>
    ): Prisma__orderDetailsClient<$Result.GetResult<Prisma.$orderDetailsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrderDetails.
     * @param {orderDetailsDeleteManyArgs} args - Arguments to filter OrderDetails to delete.
     * @example
     * // Delete a few OrderDetails
     * const { count } = await prisma.orderDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends orderDetailsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderDetailsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderDetails
     * const orderDetails = await prisma.orderDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends orderDetailsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, orderDetailsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderDetails.
     * @param {orderDetailsUpsertArgs} args - Arguments to update or create a OrderDetails.
     * @example
     * // Update or create a OrderDetails
     * const orderDetails = await prisma.orderDetails.upsert({
     *   create: {
     *     // ... data to create a OrderDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderDetails we want to update
     *   }
     * })
    **/
    upsert<T extends orderDetailsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, orderDetailsUpsertArgs<ExtArgs>>
    ): Prisma__orderDetailsClient<$Result.GetResult<Prisma.$orderDetailsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderDetailsCountArgs} args - Arguments to filter OrderDetails to count.
     * @example
     * // Count the number of OrderDetails
     * const count = await prisma.orderDetails.count({
     *   where: {
     *     // ... the filter for the OrderDetails we want to count
     *   }
     * })
    **/
    count<T extends orderDetailsCountArgs>(
      args?: Subset<T, orderDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderDetailsAggregateArgs>(args: Subset<T, OrderDetailsAggregateArgs>): Prisma.PrismaPromise<GetOrderDetailsAggregateType<T>>

    /**
     * Group by OrderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends orderDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: orderDetailsGroupByArgs['orderBy'] }
        : { orderBy?: orderDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, orderDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the orderDetails model
   */
  readonly fields: orderDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for orderDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__orderDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Order<T extends orderDetails$OrderArgs<ExtArgs> = {}>(args?: Subset<T, orderDetails$OrderArgs<ExtArgs>>): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the orderDetails model
   */ 
  interface orderDetailsFieldRefs {
    readonly ID: FieldRef<"orderDetails", 'String'>
    readonly Detail: FieldRef<"orderDetails", 'String'>
    readonly AmountX: FieldRef<"orderDetails", 'Float'>
    readonly AmountY: FieldRef<"orderDetails", 'Float'>
    readonly AmountH: FieldRef<"orderDetails", 'Float'>
    readonly AmountW: FieldRef<"orderDetails", 'Float'>
    readonly Amount: FieldRef<"orderDetails", 'Float'>
    readonly OrderID: FieldRef<"orderDetails", 'String'>
    readonly Status: FieldRef<"orderDetails", 'String'>
    readonly IsActive: FieldRef<"orderDetails", 'Boolean'>
    readonly CreatedAt: FieldRef<"orderDetails", 'DateTime'>
    readonly UpdatedAt: FieldRef<"orderDetails", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * orderDetails findUnique
   */
  export type orderDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderDetails
     */
    select?: orderDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which orderDetails to fetch.
     */
    where: orderDetailsWhereUniqueInput
  }

  /**
   * orderDetails findUniqueOrThrow
   */
  export type orderDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderDetails
     */
    select?: orderDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which orderDetails to fetch.
     */
    where: orderDetailsWhereUniqueInput
  }

  /**
   * orderDetails findFirst
   */
  export type orderDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderDetails
     */
    select?: orderDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which orderDetails to fetch.
     */
    where?: orderDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderDetails to fetch.
     */
    orderBy?: orderDetailsOrderByWithRelationInput | orderDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderDetails.
     */
    cursor?: orderDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderDetails.
     */
    distinct?: OrderDetailsScalarFieldEnum | OrderDetailsScalarFieldEnum[]
  }

  /**
   * orderDetails findFirstOrThrow
   */
  export type orderDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderDetails
     */
    select?: orderDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which orderDetails to fetch.
     */
    where?: orderDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderDetails to fetch.
     */
    orderBy?: orderDetailsOrderByWithRelationInput | orderDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderDetails.
     */
    cursor?: orderDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderDetails.
     */
    distinct?: OrderDetailsScalarFieldEnum | OrderDetailsScalarFieldEnum[]
  }

  /**
   * orderDetails findMany
   */
  export type orderDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderDetails
     */
    select?: orderDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which orderDetails to fetch.
     */
    where?: orderDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderDetails to fetch.
     */
    orderBy?: orderDetailsOrderByWithRelationInput | orderDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orderDetails.
     */
    cursor?: orderDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderDetails.
     */
    skip?: number
    distinct?: OrderDetailsScalarFieldEnum | OrderDetailsScalarFieldEnum[]
  }

  /**
   * orderDetails create
   */
  export type orderDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderDetails
     */
    select?: orderDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a orderDetails.
     */
    data?: XOR<orderDetailsCreateInput, orderDetailsUncheckedCreateInput>
  }

  /**
   * orderDetails createMany
   */
  export type orderDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orderDetails.
     */
    data: orderDetailsCreateManyInput | orderDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * orderDetails update
   */
  export type orderDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderDetails
     */
    select?: orderDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a orderDetails.
     */
    data: XOR<orderDetailsUpdateInput, orderDetailsUncheckedUpdateInput>
    /**
     * Choose, which orderDetails to update.
     */
    where: orderDetailsWhereUniqueInput
  }

  /**
   * orderDetails updateMany
   */
  export type orderDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orderDetails.
     */
    data: XOR<orderDetailsUpdateManyMutationInput, orderDetailsUncheckedUpdateManyInput>
    /**
     * Filter which orderDetails to update
     */
    where?: orderDetailsWhereInput
  }

  /**
   * orderDetails upsert
   */
  export type orderDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderDetails
     */
    select?: orderDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the orderDetails to update in case it exists.
     */
    where: orderDetailsWhereUniqueInput
    /**
     * In case the orderDetails found by the `where` argument doesn't exist, create a new orderDetails with this data.
     */
    create: XOR<orderDetailsCreateInput, orderDetailsUncheckedCreateInput>
    /**
     * In case the orderDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<orderDetailsUpdateInput, orderDetailsUncheckedUpdateInput>
  }

  /**
   * orderDetails delete
   */
  export type orderDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderDetails
     */
    select?: orderDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderDetailsInclude<ExtArgs> | null
    /**
     * Filter which orderDetails to delete.
     */
    where: orderDetailsWhereUniqueInput
  }

  /**
   * orderDetails deleteMany
   */
  export type orderDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderDetails to delete
     */
    where?: orderDetailsWhereInput
  }

  /**
   * orderDetails.Order
   */
  export type orderDetails$OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
  }

  /**
   * orderDetails without action
   */
  export type orderDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderDetails
     */
    select?: orderDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderDetailsInclude<ExtArgs> | null
  }


  /**
   * Model tackingStatus
   */

  export type AggregateTackingStatus = {
    _count: TackingStatusCountAggregateOutputType | null
    _min: TackingStatusMinAggregateOutputType | null
    _max: TackingStatusMaxAggregateOutputType | null
  }

  export type TackingStatusMinAggregateOutputType = {
    ID: string | null
    Status: string | null
    Description: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type TackingStatusMaxAggregateOutputType = {
    ID: string | null
    Status: string | null
    Description: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type TackingStatusCountAggregateOutputType = {
    ID: number
    Status: number
    Description: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type TackingStatusMinAggregateInputType = {
    ID?: true
    Status?: true
    Description?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type TackingStatusMaxAggregateInputType = {
    ID?: true
    Status?: true
    Description?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type TackingStatusCountAggregateInputType = {
    ID?: true
    Status?: true
    Description?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type TackingStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tackingStatus to aggregate.
     */
    where?: tackingStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tackingStatuses to fetch.
     */
    orderBy?: tackingStatusOrderByWithRelationInput | tackingStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tackingStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tackingStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tackingStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tackingStatuses
    **/
    _count?: true | TackingStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TackingStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TackingStatusMaxAggregateInputType
  }

  export type GetTackingStatusAggregateType<T extends TackingStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateTackingStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTackingStatus[P]>
      : GetScalarType<T[P], AggregateTackingStatus[P]>
  }




  export type tackingStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tackingStatusWhereInput
    orderBy?: tackingStatusOrderByWithAggregationInput | tackingStatusOrderByWithAggregationInput[]
    by: TackingStatusScalarFieldEnum[] | TackingStatusScalarFieldEnum
    having?: tackingStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TackingStatusCountAggregateInputType | true
    _min?: TackingStatusMinAggregateInputType
    _max?: TackingStatusMaxAggregateInputType
  }

  export type TackingStatusGroupByOutputType = {
    ID: string
    Status: string | null
    Description: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: TackingStatusCountAggregateOutputType | null
    _min: TackingStatusMinAggregateOutputType | null
    _max: TackingStatusMaxAggregateOutputType | null
  }

  type GetTackingStatusGroupByPayload<T extends tackingStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TackingStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TackingStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TackingStatusGroupByOutputType[P]>
            : GetScalarType<T[P], TackingStatusGroupByOutputType[P]>
        }
      >
    >


  export type tackingStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Status?: boolean
    Description?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Tracking?: boolean | tackingStatus$TrackingArgs<ExtArgs>
    _count?: boolean | TackingStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tackingStatus"]>

  export type tackingStatusSelectScalar = {
    ID?: boolean
    Status?: boolean
    Description?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type tackingStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tracking?: boolean | tackingStatus$TrackingArgs<ExtArgs>
    _count?: boolean | TackingStatusCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $tackingStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tackingStatus"
    objects: {
      Tracking: Prisma.$orderTackingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Status: string | null
      Description: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["tackingStatus"]>
    composites: {}
  }


  type tackingStatusGetPayload<S extends boolean | null | undefined | tackingStatusDefaultArgs> = $Result.GetResult<Prisma.$tackingStatusPayload, S>

  type tackingStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tackingStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TackingStatusCountAggregateInputType | true
    }

  export interface tackingStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tackingStatus'], meta: { name: 'tackingStatus' } }
    /**
     * Find zero or one TackingStatus that matches the filter.
     * @param {tackingStatusFindUniqueArgs} args - Arguments to find a TackingStatus
     * @example
     * // Get one TackingStatus
     * const tackingStatus = await prisma.tackingStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tackingStatusFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tackingStatusFindUniqueArgs<ExtArgs>>
    ): Prisma__tackingStatusClient<$Result.GetResult<Prisma.$tackingStatusPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TackingStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tackingStatusFindUniqueOrThrowArgs} args - Arguments to find a TackingStatus
     * @example
     * // Get one TackingStatus
     * const tackingStatus = await prisma.tackingStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tackingStatusFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tackingStatusFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tackingStatusClient<$Result.GetResult<Prisma.$tackingStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TackingStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tackingStatusFindFirstArgs} args - Arguments to find a TackingStatus
     * @example
     * // Get one TackingStatus
     * const tackingStatus = await prisma.tackingStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tackingStatusFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tackingStatusFindFirstArgs<ExtArgs>>
    ): Prisma__tackingStatusClient<$Result.GetResult<Prisma.$tackingStatusPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TackingStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tackingStatusFindFirstOrThrowArgs} args - Arguments to find a TackingStatus
     * @example
     * // Get one TackingStatus
     * const tackingStatus = await prisma.tackingStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tackingStatusFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tackingStatusFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tackingStatusClient<$Result.GetResult<Prisma.$tackingStatusPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TackingStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tackingStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TackingStatuses
     * const tackingStatuses = await prisma.tackingStatus.findMany()
     * 
     * // Get first 10 TackingStatuses
     * const tackingStatuses = await prisma.tackingStatus.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tackingStatusWithIDOnly = await prisma.tackingStatus.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends tackingStatusFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tackingStatusFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tackingStatusPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TackingStatus.
     * @param {tackingStatusCreateArgs} args - Arguments to create a TackingStatus.
     * @example
     * // Create one TackingStatus
     * const TackingStatus = await prisma.tackingStatus.create({
     *   data: {
     *     // ... data to create a TackingStatus
     *   }
     * })
     * 
    **/
    create<T extends tackingStatusCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tackingStatusCreateArgs<ExtArgs>>
    ): Prisma__tackingStatusClient<$Result.GetResult<Prisma.$tackingStatusPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TackingStatuses.
     * @param {tackingStatusCreateManyArgs} args - Arguments to create many TackingStatuses.
     * @example
     * // Create many TackingStatuses
     * const tackingStatus = await prisma.tackingStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends tackingStatusCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tackingStatusCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TackingStatus.
     * @param {tackingStatusDeleteArgs} args - Arguments to delete one TackingStatus.
     * @example
     * // Delete one TackingStatus
     * const TackingStatus = await prisma.tackingStatus.delete({
     *   where: {
     *     // ... filter to delete one TackingStatus
     *   }
     * })
     * 
    **/
    delete<T extends tackingStatusDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tackingStatusDeleteArgs<ExtArgs>>
    ): Prisma__tackingStatusClient<$Result.GetResult<Prisma.$tackingStatusPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TackingStatus.
     * @param {tackingStatusUpdateArgs} args - Arguments to update one TackingStatus.
     * @example
     * // Update one TackingStatus
     * const tackingStatus = await prisma.tackingStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tackingStatusUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tackingStatusUpdateArgs<ExtArgs>>
    ): Prisma__tackingStatusClient<$Result.GetResult<Prisma.$tackingStatusPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TackingStatuses.
     * @param {tackingStatusDeleteManyArgs} args - Arguments to filter TackingStatuses to delete.
     * @example
     * // Delete a few TackingStatuses
     * const { count } = await prisma.tackingStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tackingStatusDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tackingStatusDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TackingStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tackingStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TackingStatuses
     * const tackingStatus = await prisma.tackingStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tackingStatusUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tackingStatusUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TackingStatus.
     * @param {tackingStatusUpsertArgs} args - Arguments to update or create a TackingStatus.
     * @example
     * // Update or create a TackingStatus
     * const tackingStatus = await prisma.tackingStatus.upsert({
     *   create: {
     *     // ... data to create a TackingStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TackingStatus we want to update
     *   }
     * })
    **/
    upsert<T extends tackingStatusUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tackingStatusUpsertArgs<ExtArgs>>
    ): Prisma__tackingStatusClient<$Result.GetResult<Prisma.$tackingStatusPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TackingStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tackingStatusCountArgs} args - Arguments to filter TackingStatuses to count.
     * @example
     * // Count the number of TackingStatuses
     * const count = await prisma.tackingStatus.count({
     *   where: {
     *     // ... the filter for the TackingStatuses we want to count
     *   }
     * })
    **/
    count<T extends tackingStatusCountArgs>(
      args?: Subset<T, tackingStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TackingStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TackingStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TackingStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TackingStatusAggregateArgs>(args: Subset<T, TackingStatusAggregateArgs>): Prisma.PrismaPromise<GetTackingStatusAggregateType<T>>

    /**
     * Group by TackingStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tackingStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tackingStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tackingStatusGroupByArgs['orderBy'] }
        : { orderBy?: tackingStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tackingStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTackingStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tackingStatus model
   */
  readonly fields: tackingStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tackingStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tackingStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Tracking<T extends tackingStatus$TrackingArgs<ExtArgs> = {}>(args?: Subset<T, tackingStatus$TrackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderTackingPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tackingStatus model
   */ 
  interface tackingStatusFieldRefs {
    readonly ID: FieldRef<"tackingStatus", 'String'>
    readonly Status: FieldRef<"tackingStatus", 'String'>
    readonly Description: FieldRef<"tackingStatus", 'String'>
    readonly IsActive: FieldRef<"tackingStatus", 'Boolean'>
    readonly CreatedAt: FieldRef<"tackingStatus", 'DateTime'>
    readonly UpdatedAt: FieldRef<"tackingStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tackingStatus findUnique
   */
  export type tackingStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tackingStatus
     */
    select?: tackingStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tackingStatusInclude<ExtArgs> | null
    /**
     * Filter, which tackingStatus to fetch.
     */
    where: tackingStatusWhereUniqueInput
  }

  /**
   * tackingStatus findUniqueOrThrow
   */
  export type tackingStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tackingStatus
     */
    select?: tackingStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tackingStatusInclude<ExtArgs> | null
    /**
     * Filter, which tackingStatus to fetch.
     */
    where: tackingStatusWhereUniqueInput
  }

  /**
   * tackingStatus findFirst
   */
  export type tackingStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tackingStatus
     */
    select?: tackingStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tackingStatusInclude<ExtArgs> | null
    /**
     * Filter, which tackingStatus to fetch.
     */
    where?: tackingStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tackingStatuses to fetch.
     */
    orderBy?: tackingStatusOrderByWithRelationInput | tackingStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tackingStatuses.
     */
    cursor?: tackingStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tackingStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tackingStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tackingStatuses.
     */
    distinct?: TackingStatusScalarFieldEnum | TackingStatusScalarFieldEnum[]
  }

  /**
   * tackingStatus findFirstOrThrow
   */
  export type tackingStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tackingStatus
     */
    select?: tackingStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tackingStatusInclude<ExtArgs> | null
    /**
     * Filter, which tackingStatus to fetch.
     */
    where?: tackingStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tackingStatuses to fetch.
     */
    orderBy?: tackingStatusOrderByWithRelationInput | tackingStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tackingStatuses.
     */
    cursor?: tackingStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tackingStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tackingStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tackingStatuses.
     */
    distinct?: TackingStatusScalarFieldEnum | TackingStatusScalarFieldEnum[]
  }

  /**
   * tackingStatus findMany
   */
  export type tackingStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tackingStatus
     */
    select?: tackingStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tackingStatusInclude<ExtArgs> | null
    /**
     * Filter, which tackingStatuses to fetch.
     */
    where?: tackingStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tackingStatuses to fetch.
     */
    orderBy?: tackingStatusOrderByWithRelationInput | tackingStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tackingStatuses.
     */
    cursor?: tackingStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tackingStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tackingStatuses.
     */
    skip?: number
    distinct?: TackingStatusScalarFieldEnum | TackingStatusScalarFieldEnum[]
  }

  /**
   * tackingStatus create
   */
  export type tackingStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tackingStatus
     */
    select?: tackingStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tackingStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a tackingStatus.
     */
    data?: XOR<tackingStatusCreateInput, tackingStatusUncheckedCreateInput>
  }

  /**
   * tackingStatus createMany
   */
  export type tackingStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tackingStatuses.
     */
    data: tackingStatusCreateManyInput | tackingStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tackingStatus update
   */
  export type tackingStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tackingStatus
     */
    select?: tackingStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tackingStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a tackingStatus.
     */
    data: XOR<tackingStatusUpdateInput, tackingStatusUncheckedUpdateInput>
    /**
     * Choose, which tackingStatus to update.
     */
    where: tackingStatusWhereUniqueInput
  }

  /**
   * tackingStatus updateMany
   */
  export type tackingStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tackingStatuses.
     */
    data: XOR<tackingStatusUpdateManyMutationInput, tackingStatusUncheckedUpdateManyInput>
    /**
     * Filter which tackingStatuses to update
     */
    where?: tackingStatusWhereInput
  }

  /**
   * tackingStatus upsert
   */
  export type tackingStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tackingStatus
     */
    select?: tackingStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tackingStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the tackingStatus to update in case it exists.
     */
    where: tackingStatusWhereUniqueInput
    /**
     * In case the tackingStatus found by the `where` argument doesn't exist, create a new tackingStatus with this data.
     */
    create: XOR<tackingStatusCreateInput, tackingStatusUncheckedCreateInput>
    /**
     * In case the tackingStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tackingStatusUpdateInput, tackingStatusUncheckedUpdateInput>
  }

  /**
   * tackingStatus delete
   */
  export type tackingStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tackingStatus
     */
    select?: tackingStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tackingStatusInclude<ExtArgs> | null
    /**
     * Filter which tackingStatus to delete.
     */
    where: tackingStatusWhereUniqueInput
  }

  /**
   * tackingStatus deleteMany
   */
  export type tackingStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tackingStatuses to delete
     */
    where?: tackingStatusWhereInput
  }

  /**
   * tackingStatus.Tracking
   */
  export type tackingStatus$TrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderTacking
     */
    select?: orderTackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderTackingInclude<ExtArgs> | null
    where?: orderTackingWhereInput
    orderBy?: orderTackingOrderByWithRelationInput | orderTackingOrderByWithRelationInput[]
    cursor?: orderTackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderTackingScalarFieldEnum | OrderTackingScalarFieldEnum[]
  }

  /**
   * tackingStatus without action
   */
  export type tackingStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tackingStatus
     */
    select?: tackingStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tackingStatusInclude<ExtArgs> | null
  }


  /**
   * Model orderTacking
   */

  export type AggregateOrderTacking = {
    _count: OrderTackingCountAggregateOutputType | null
    _min: OrderTackingMinAggregateOutputType | null
    _max: OrderTackingMaxAggregateOutputType | null
  }

  export type OrderTackingMinAggregateOutputType = {
    ID: string | null
    Number: string | null
    PrimaryPhoneNumber: string | null
    SecondaryName: string | null
    SecondaryPhoneNumber: string | null
    OrderID: string | null
    BranchesID: string | null
    TrackingStatusID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OrderTackingMaxAggregateOutputType = {
    ID: string | null
    Number: string | null
    PrimaryPhoneNumber: string | null
    SecondaryName: string | null
    SecondaryPhoneNumber: string | null
    OrderID: string | null
    BranchesID: string | null
    TrackingStatusID: string | null
    Status: string | null
    IsActive: boolean | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type OrderTackingCountAggregateOutputType = {
    ID: number
    Number: number
    PrimaryPhoneNumber: number
    SecondaryName: number
    SecondaryPhoneNumber: number
    OrderID: number
    BranchesID: number
    TrackingStatusID: number
    Status: number
    IsActive: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type OrderTackingMinAggregateInputType = {
    ID?: true
    Number?: true
    PrimaryPhoneNumber?: true
    SecondaryName?: true
    SecondaryPhoneNumber?: true
    OrderID?: true
    BranchesID?: true
    TrackingStatusID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OrderTackingMaxAggregateInputType = {
    ID?: true
    Number?: true
    PrimaryPhoneNumber?: true
    SecondaryName?: true
    SecondaryPhoneNumber?: true
    OrderID?: true
    BranchesID?: true
    TrackingStatusID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type OrderTackingCountAggregateInputType = {
    ID?: true
    Number?: true
    PrimaryPhoneNumber?: true
    SecondaryName?: true
    SecondaryPhoneNumber?: true
    OrderID?: true
    BranchesID?: true
    TrackingStatusID?: true
    Status?: true
    IsActive?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type OrderTackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderTacking to aggregate.
     */
    where?: orderTackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderTackings to fetch.
     */
    orderBy?: orderTackingOrderByWithRelationInput | orderTackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: orderTackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderTackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderTackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orderTackings
    **/
    _count?: true | OrderTackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderTackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderTackingMaxAggregateInputType
  }

  export type GetOrderTackingAggregateType<T extends OrderTackingAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderTacking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderTacking[P]>
      : GetScalarType<T[P], AggregateOrderTacking[P]>
  }




  export type orderTackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderTackingWhereInput
    orderBy?: orderTackingOrderByWithAggregationInput | orderTackingOrderByWithAggregationInput[]
    by: OrderTackingScalarFieldEnum[] | OrderTackingScalarFieldEnum
    having?: orderTackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderTackingCountAggregateInputType | true
    _min?: OrderTackingMinAggregateInputType
    _max?: OrderTackingMaxAggregateInputType
  }

  export type OrderTackingGroupByOutputType = {
    ID: string
    Number: string | null
    PrimaryPhoneNumber: string | null
    SecondaryName: string | null
    SecondaryPhoneNumber: string | null
    OrderID: string | null
    BranchesID: string | null
    TrackingStatusID: string | null
    Status: string | null
    IsActive: boolean
    CreatedAt: Date
    UpdatedAt: Date | null
    _count: OrderTackingCountAggregateOutputType | null
    _min: OrderTackingMinAggregateOutputType | null
    _max: OrderTackingMaxAggregateOutputType | null
  }

  type GetOrderTackingGroupByPayload<T extends orderTackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderTackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderTackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderTackingGroupByOutputType[P]>
            : GetScalarType<T[P], OrderTackingGroupByOutputType[P]>
        }
      >
    >


  export type orderTackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Number?: boolean
    PrimaryPhoneNumber?: boolean
    SecondaryName?: boolean
    SecondaryPhoneNumber?: boolean
    OrderID?: boolean
    BranchesID?: boolean
    TrackingStatusID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    Order?: boolean | orderTacking$OrderArgs<ExtArgs>
    Branches?: boolean | orderTacking$BranchesArgs<ExtArgs>
    TrackingStatus?: boolean | orderTacking$TrackingStatusArgs<ExtArgs>
  }, ExtArgs["result"]["orderTacking"]>

  export type orderTackingSelectScalar = {
    ID?: boolean
    Number?: boolean
    PrimaryPhoneNumber?: boolean
    SecondaryName?: boolean
    SecondaryPhoneNumber?: boolean
    OrderID?: boolean
    BranchesID?: boolean
    TrackingStatusID?: boolean
    Status?: boolean
    IsActive?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }


  export type orderTackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Order?: boolean | orderTacking$OrderArgs<ExtArgs>
    Branches?: boolean | orderTacking$BranchesArgs<ExtArgs>
    TrackingStatus?: boolean | orderTacking$TrackingStatusArgs<ExtArgs>
  }


  export type $orderTackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "orderTacking"
    objects: {
      Order: Prisma.$orderPayload<ExtArgs> | null
      Branches: Prisma.$branchesPayload<ExtArgs> | null
      TrackingStatus: Prisma.$tackingStatusPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Number: string | null
      PrimaryPhoneNumber: string | null
      SecondaryName: string | null
      SecondaryPhoneNumber: string | null
      OrderID: string | null
      BranchesID: string | null
      TrackingStatusID: string | null
      Status: string | null
      IsActive: boolean
      CreatedAt: Date
      UpdatedAt: Date | null
    }, ExtArgs["result"]["orderTacking"]>
    composites: {}
  }


  type orderTackingGetPayload<S extends boolean | null | undefined | orderTackingDefaultArgs> = $Result.GetResult<Prisma.$orderTackingPayload, S>

  type orderTackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<orderTackingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderTackingCountAggregateInputType | true
    }

  export interface orderTackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['orderTacking'], meta: { name: 'orderTacking' } }
    /**
     * Find zero or one OrderTacking that matches the filter.
     * @param {orderTackingFindUniqueArgs} args - Arguments to find a OrderTacking
     * @example
     * // Get one OrderTacking
     * const orderTacking = await prisma.orderTacking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends orderTackingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, orderTackingFindUniqueArgs<ExtArgs>>
    ): Prisma__orderTackingClient<$Result.GetResult<Prisma.$orderTackingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrderTacking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {orderTackingFindUniqueOrThrowArgs} args - Arguments to find a OrderTacking
     * @example
     * // Get one OrderTacking
     * const orderTacking = await prisma.orderTacking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends orderTackingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderTackingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__orderTackingClient<$Result.GetResult<Prisma.$orderTackingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrderTacking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderTackingFindFirstArgs} args - Arguments to find a OrderTacking
     * @example
     * // Get one OrderTacking
     * const orderTacking = await prisma.orderTacking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends orderTackingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, orderTackingFindFirstArgs<ExtArgs>>
    ): Prisma__orderTackingClient<$Result.GetResult<Prisma.$orderTackingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrderTacking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderTackingFindFirstOrThrowArgs} args - Arguments to find a OrderTacking
     * @example
     * // Get one OrderTacking
     * const orderTacking = await prisma.orderTacking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends orderTackingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderTackingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__orderTackingClient<$Result.GetResult<Prisma.$orderTackingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrderTackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderTackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderTackings
     * const orderTackings = await prisma.orderTacking.findMany()
     * 
     * // Get first 10 OrderTackings
     * const orderTackings = await prisma.orderTacking.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const orderTackingWithIDOnly = await prisma.orderTacking.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends orderTackingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderTackingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderTackingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrderTacking.
     * @param {orderTackingCreateArgs} args - Arguments to create a OrderTacking.
     * @example
     * // Create one OrderTacking
     * const OrderTacking = await prisma.orderTacking.create({
     *   data: {
     *     // ... data to create a OrderTacking
     *   }
     * })
     * 
    **/
    create<T extends orderTackingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, orderTackingCreateArgs<ExtArgs>>
    ): Prisma__orderTackingClient<$Result.GetResult<Prisma.$orderTackingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrderTackings.
     * @param {orderTackingCreateManyArgs} args - Arguments to create many OrderTackings.
     * @example
     * // Create many OrderTackings
     * const orderTacking = await prisma.orderTacking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends orderTackingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderTackingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderTacking.
     * @param {orderTackingDeleteArgs} args - Arguments to delete one OrderTacking.
     * @example
     * // Delete one OrderTacking
     * const OrderTacking = await prisma.orderTacking.delete({
     *   where: {
     *     // ... filter to delete one OrderTacking
     *   }
     * })
     * 
    **/
    delete<T extends orderTackingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, orderTackingDeleteArgs<ExtArgs>>
    ): Prisma__orderTackingClient<$Result.GetResult<Prisma.$orderTackingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrderTacking.
     * @param {orderTackingUpdateArgs} args - Arguments to update one OrderTacking.
     * @example
     * // Update one OrderTacking
     * const orderTacking = await prisma.orderTacking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends orderTackingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, orderTackingUpdateArgs<ExtArgs>>
    ): Prisma__orderTackingClient<$Result.GetResult<Prisma.$orderTackingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrderTackings.
     * @param {orderTackingDeleteManyArgs} args - Arguments to filter OrderTackings to delete.
     * @example
     * // Delete a few OrderTackings
     * const { count } = await prisma.orderTacking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends orderTackingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderTackingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderTackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderTackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderTackings
     * const orderTacking = await prisma.orderTacking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends orderTackingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, orderTackingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderTacking.
     * @param {orderTackingUpsertArgs} args - Arguments to update or create a OrderTacking.
     * @example
     * // Update or create a OrderTacking
     * const orderTacking = await prisma.orderTacking.upsert({
     *   create: {
     *     // ... data to create a OrderTacking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderTacking we want to update
     *   }
     * })
    **/
    upsert<T extends orderTackingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, orderTackingUpsertArgs<ExtArgs>>
    ): Prisma__orderTackingClient<$Result.GetResult<Prisma.$orderTackingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrderTackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderTackingCountArgs} args - Arguments to filter OrderTackings to count.
     * @example
     * // Count the number of OrderTackings
     * const count = await prisma.orderTacking.count({
     *   where: {
     *     // ... the filter for the OrderTackings we want to count
     *   }
     * })
    **/
    count<T extends orderTackingCountArgs>(
      args?: Subset<T, orderTackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderTackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderTacking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderTackingAggregateArgs>(args: Subset<T, OrderTackingAggregateArgs>): Prisma.PrismaPromise<GetOrderTackingAggregateType<T>>

    /**
     * Group by OrderTacking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderTackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends orderTackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: orderTackingGroupByArgs['orderBy'] }
        : { orderBy?: orderTackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, orderTackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderTackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the orderTacking model
   */
  readonly fields: orderTackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for orderTacking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__orderTackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Order<T extends orderTacking$OrderArgs<ExtArgs> = {}>(args?: Subset<T, orderTacking$OrderArgs<ExtArgs>>): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Branches<T extends orderTacking$BranchesArgs<ExtArgs> = {}>(args?: Subset<T, orderTacking$BranchesArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    TrackingStatus<T extends orderTacking$TrackingStatusArgs<ExtArgs> = {}>(args?: Subset<T, orderTacking$TrackingStatusArgs<ExtArgs>>): Prisma__tackingStatusClient<$Result.GetResult<Prisma.$tackingStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the orderTacking model
   */ 
  interface orderTackingFieldRefs {
    readonly ID: FieldRef<"orderTacking", 'String'>
    readonly Number: FieldRef<"orderTacking", 'String'>
    readonly PrimaryPhoneNumber: FieldRef<"orderTacking", 'String'>
    readonly SecondaryName: FieldRef<"orderTacking", 'String'>
    readonly SecondaryPhoneNumber: FieldRef<"orderTacking", 'String'>
    readonly OrderID: FieldRef<"orderTacking", 'String'>
    readonly BranchesID: FieldRef<"orderTacking", 'String'>
    readonly TrackingStatusID: FieldRef<"orderTacking", 'String'>
    readonly Status: FieldRef<"orderTacking", 'String'>
    readonly IsActive: FieldRef<"orderTacking", 'Boolean'>
    readonly CreatedAt: FieldRef<"orderTacking", 'DateTime'>
    readonly UpdatedAt: FieldRef<"orderTacking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * orderTacking findUnique
   */
  export type orderTackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderTacking
     */
    select?: orderTackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderTackingInclude<ExtArgs> | null
    /**
     * Filter, which orderTacking to fetch.
     */
    where: orderTackingWhereUniqueInput
  }

  /**
   * orderTacking findUniqueOrThrow
   */
  export type orderTackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderTacking
     */
    select?: orderTackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderTackingInclude<ExtArgs> | null
    /**
     * Filter, which orderTacking to fetch.
     */
    where: orderTackingWhereUniqueInput
  }

  /**
   * orderTacking findFirst
   */
  export type orderTackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderTacking
     */
    select?: orderTackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderTackingInclude<ExtArgs> | null
    /**
     * Filter, which orderTacking to fetch.
     */
    where?: orderTackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderTackings to fetch.
     */
    orderBy?: orderTackingOrderByWithRelationInput | orderTackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderTackings.
     */
    cursor?: orderTackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderTackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderTackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderTackings.
     */
    distinct?: OrderTackingScalarFieldEnum | OrderTackingScalarFieldEnum[]
  }

  /**
   * orderTacking findFirstOrThrow
   */
  export type orderTackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderTacking
     */
    select?: orderTackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderTackingInclude<ExtArgs> | null
    /**
     * Filter, which orderTacking to fetch.
     */
    where?: orderTackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderTackings to fetch.
     */
    orderBy?: orderTackingOrderByWithRelationInput | orderTackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderTackings.
     */
    cursor?: orderTackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderTackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderTackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderTackings.
     */
    distinct?: OrderTackingScalarFieldEnum | OrderTackingScalarFieldEnum[]
  }

  /**
   * orderTacking findMany
   */
  export type orderTackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderTacking
     */
    select?: orderTackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderTackingInclude<ExtArgs> | null
    /**
     * Filter, which orderTackings to fetch.
     */
    where?: orderTackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderTackings to fetch.
     */
    orderBy?: orderTackingOrderByWithRelationInput | orderTackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orderTackings.
     */
    cursor?: orderTackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderTackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderTackings.
     */
    skip?: number
    distinct?: OrderTackingScalarFieldEnum | OrderTackingScalarFieldEnum[]
  }

  /**
   * orderTacking create
   */
  export type orderTackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderTacking
     */
    select?: orderTackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderTackingInclude<ExtArgs> | null
    /**
     * The data needed to create a orderTacking.
     */
    data?: XOR<orderTackingCreateInput, orderTackingUncheckedCreateInput>
  }

  /**
   * orderTacking createMany
   */
  export type orderTackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orderTackings.
     */
    data: orderTackingCreateManyInput | orderTackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * orderTacking update
   */
  export type orderTackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderTacking
     */
    select?: orderTackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderTackingInclude<ExtArgs> | null
    /**
     * The data needed to update a orderTacking.
     */
    data: XOR<orderTackingUpdateInput, orderTackingUncheckedUpdateInput>
    /**
     * Choose, which orderTacking to update.
     */
    where: orderTackingWhereUniqueInput
  }

  /**
   * orderTacking updateMany
   */
  export type orderTackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orderTackings.
     */
    data: XOR<orderTackingUpdateManyMutationInput, orderTackingUncheckedUpdateManyInput>
    /**
     * Filter which orderTackings to update
     */
    where?: orderTackingWhereInput
  }

  /**
   * orderTacking upsert
   */
  export type orderTackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderTacking
     */
    select?: orderTackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderTackingInclude<ExtArgs> | null
    /**
     * The filter to search for the orderTacking to update in case it exists.
     */
    where: orderTackingWhereUniqueInput
    /**
     * In case the orderTacking found by the `where` argument doesn't exist, create a new orderTacking with this data.
     */
    create: XOR<orderTackingCreateInput, orderTackingUncheckedCreateInput>
    /**
     * In case the orderTacking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<orderTackingUpdateInput, orderTackingUncheckedUpdateInput>
  }

  /**
   * orderTacking delete
   */
  export type orderTackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderTacking
     */
    select?: orderTackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderTackingInclude<ExtArgs> | null
    /**
     * Filter which orderTacking to delete.
     */
    where: orderTackingWhereUniqueInput
  }

  /**
   * orderTacking deleteMany
   */
  export type orderTackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderTackings to delete
     */
    where?: orderTackingWhereInput
  }

  /**
   * orderTacking.Order
   */
  export type orderTacking$OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
  }

  /**
   * orderTacking.Branches
   */
  export type orderTacking$BranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * orderTacking.TrackingStatus
   */
  export type orderTacking$TrackingStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tackingStatus
     */
    select?: tackingStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tackingStatusInclude<ExtArgs> | null
    where?: tackingStatusWhereInput
  }

  /**
   * orderTacking without action
   */
  export type orderTackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderTacking
     */
    select?: orderTackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderTackingInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProvinceScalarFieldEnum: {
    ID: 'ID',
    Name: 'Name',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type ProvinceScalarFieldEnum = (typeof ProvinceScalarFieldEnum)[keyof typeof ProvinceScalarFieldEnum]


  export const DistrictScalarFieldEnum: {
    ID: 'ID',
    Name: 'Name',
    ProvinceID: 'ProvinceID',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type DistrictScalarFieldEnum = (typeof DistrictScalarFieldEnum)[keyof typeof DistrictScalarFieldEnum]


  export const VillageScalarFieldEnum: {
    ID: 'ID',
    Name: 'Name',
    ProvinceID: 'ProvinceID',
    DistrictID: 'DistrictID',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type VillageScalarFieldEnum = (typeof VillageScalarFieldEnum)[keyof typeof VillageScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    ID: 'ID',
    Address: 'Address',
    ProvinceID: 'ProvinceID',
    DistrictID: 'DistrictID',
    ProfileID: 'ProfileID',
    BranchesID: 'BranchesID',
    IsDefault: 'IsDefault',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const BranchesScalarFieldEnum: {
    ID: 'ID',
    CompanyId: 'CompanyId',
    Name: 'Name',
    Address1: 'Address1',
    Address2: 'Address2',
    Address3: 'Address3',
    Status: 'Status',
    Lat: 'Lat',
    Long: 'Long',
    Zone: 'Zone',
    IsMain: 'IsMain',
    UploadURL: 'UploadURL',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type BranchesScalarFieldEnum = (typeof BranchesScalarFieldEnum)[keyof typeof BranchesScalarFieldEnum]


  export const BranchesKeyScalarFieldEnum: {
    ID: 'ID',
    Key: 'Key',
    Secret: 'Secret',
    Remask: 'Remask',
    BranchesID: 'BranchesID',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type BranchesKeyScalarFieldEnum = (typeof BranchesKeyScalarFieldEnum)[keyof typeof BranchesKeyScalarFieldEnum]


  export const BranchesSettingsScalarFieldEnum: {
    ID: 'ID',
    Titel: 'Titel',
    Setting: 'Setting',
    Remask: 'Remask',
    BranchesID: 'BranchesID',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type BranchesSettingsScalarFieldEnum = (typeof BranchesSettingsScalarFieldEnum)[keyof typeof BranchesSettingsScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    ID: 'ID',
    Balance: 'Balance',
    Title: 'Title',
    Description: 'Description',
    IsReal: 'IsReal',
    UserID: 'UserID',
    Status: 'Status',
    Remask: 'Remask',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    ID: 'ID',
    Type: 'Type',
    Info: 'Info',
    Status: 'Status',
    Result: 'Result',
    Balance: 'Balance',
    IsPayment: 'IsPayment',
    IsReceived: 'IsReceived',
    OrderPaymentID: 'OrderPaymentID',
    PaidByID: 'PaidByID',
    PaidToID: 'PaidToID',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    ID: 'ID',
    UserName: 'UserName',
    Password: 'Password',
    URL: 'URL',
    PhoneNumber: 'PhoneNumber',
    Email: 'Email',
    Pin: 'Pin',
    IsRemember: 'IsRemember',
    IsPin: 'IsPin',
    IsBiometric: 'IsBiometric',
    Status: 'Status',
    Remask: 'Remask',
    LastActive: 'LastActive',
    BranchesID: 'BranchesID',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    ID: 'ID',
    Gender: 'Gender',
    Name: 'Name',
    SurName: 'SurName',
    ProfileURL: 'ProfileURL',
    UserID: 'UserID',
    AdminID: 'AdminID',
    AdminPin: 'AdminPin',
    Remask: 'Remask',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    ID: 'ID',
    OTP: 'OTP',
    IsVerify: 'IsVerify',
    UserName: 'UserName',
    Type: 'Type',
    Remask: 'Remask',
    UsersID: 'UsersID',
    BranchesID: 'BranchesID',
    SmsGatewayUUID: 'SmsGatewayUUID',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    ID: 'ID',
    Titel: 'Titel',
    Details: 'Details',
    Type: 'Type',
    Provider: 'Provider',
    Remask: 'Remask',
    UsersID: 'UsersID',
    BranchesID: 'BranchesID',
    SmsGatewayUUID: 'SmsGatewayUUID',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const ForgotPasswordScalarFieldEnum: {
    ID: 'ID',
    Titel: 'Titel',
    Token: 'Token',
    OldPassword: 'OldPassword',
    OtpID: 'OtpID',
    Provider: 'Provider',
    Remask: 'Remask',
    UsersID: 'UsersID',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type ForgotPasswordScalarFieldEnum = (typeof ForgotPasswordScalarFieldEnum)[keyof typeof ForgotPasswordScalarFieldEnum]


  export const UsersRolesScalarFieldEnum: {
    ID: 'ID',
    Titel: 'Titel',
    Type: 'Type',
    Role: 'Role',
    Permission: 'Permission',
    Remask: 'Remask',
    UsersID: 'UsersID',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type UsersRolesScalarFieldEnum = (typeof UsersRolesScalarFieldEnum)[keyof typeof UsersRolesScalarFieldEnum]


  export const UsersActivitiesScalarFieldEnum: {
    ID: 'ID',
    Activity: 'Activity',
    IP: 'IP',
    MacAddress: 'MacAddress',
    UDID: 'UDID',
    Remask: 'Remask',
    Log: 'Log',
    Error: 'Error',
    Messages: 'Messages',
    UsersID: 'UsersID',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type UsersActivitiesScalarFieldEnum = (typeof UsersActivitiesScalarFieldEnum)[keyof typeof UsersActivitiesScalarFieldEnum]


  export const OrderTypeScalarFieldEnum: {
    ID: 'ID',
    TypeCode: 'TypeCode',
    TypeNmae: 'TypeNmae',
    Remask: 'Remask',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type OrderTypeScalarFieldEnum = (typeof OrderTypeScalarFieldEnum)[keyof typeof OrderTypeScalarFieldEnum]


  export const OrderCategoryScalarFieldEnum: {
    ID: 'ID',
    TypeCode: 'TypeCode',
    TypeNmae: 'TypeNmae',
    Remask: 'Remask',
    BranchesID: 'BranchesID',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type OrderCategoryScalarFieldEnum = (typeof OrderCategoryScalarFieldEnum)[keyof typeof OrderCategoryScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    ID: 'ID',
    Code: 'Code',
    PrimaryCode: 'PrimaryCode',
    SecondaryCode: 'SecondaryCode',
    OrderDate: 'OrderDate',
    Name: 'Name',
    UplaodURL: 'UplaodURL',
    CategoryID: 'CategoryID',
    BranchesID: 'BranchesID',
    CreateByID: 'CreateByID',
    Remask: 'Remask',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderThreadingScalarFieldEnum: {
    ID: 'ID',
    Tasks: 'Tasks',
    ActivitieID: 'ActivitieID',
    OrderID: 'OrderID',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type OrderThreadingScalarFieldEnum = (typeof OrderThreadingScalarFieldEnum)[keyof typeof OrderThreadingScalarFieldEnum]


  export const OrderPersonalScalarFieldEnum: {
    ID: 'ID',
    SenderName: 'SenderName',
    SenderPhoneNumber: 'SenderPhoneNumber',
    SenderUserID: 'SenderUserID',
    RecipientName: 'RecipientName',
    RecipientPhoneNumber: 'RecipientPhoneNumber',
    RecipientID: 'RecipientID',
    OrderID: 'OrderID',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type OrderPersonalScalarFieldEnum = (typeof OrderPersonalScalarFieldEnum)[keyof typeof OrderPersonalScalarFieldEnum]


  export const OrderPaymentScalarFieldEnum: {
    ID: 'ID',
    PaymentStatus: 'PaymentStatus',
    AmountDeliver: 'AmountDeliver',
    IsPaid: 'IsPaid',
    OrderID: 'OrderID',
    PaidToID: 'PaidToID',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type OrderPaymentScalarFieldEnum = (typeof OrderPaymentScalarFieldEnum)[keyof typeof OrderPaymentScalarFieldEnum]


  export const OrderDetailsScalarFieldEnum: {
    ID: 'ID',
    Detail: 'Detail',
    AmountX: 'AmountX',
    AmountY: 'AmountY',
    AmountH: 'AmountH',
    AmountW: 'AmountW',
    Amount: 'Amount',
    OrderID: 'OrderID',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type OrderDetailsScalarFieldEnum = (typeof OrderDetailsScalarFieldEnum)[keyof typeof OrderDetailsScalarFieldEnum]


  export const TackingStatusScalarFieldEnum: {
    ID: 'ID',
    Status: 'Status',
    Description: 'Description',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type TackingStatusScalarFieldEnum = (typeof TackingStatusScalarFieldEnum)[keyof typeof TackingStatusScalarFieldEnum]


  export const OrderTackingScalarFieldEnum: {
    ID: 'ID',
    Number: 'Number',
    PrimaryPhoneNumber: 'PrimaryPhoneNumber',
    SecondaryName: 'SecondaryName',
    SecondaryPhoneNumber: 'SecondaryPhoneNumber',
    OrderID: 'OrderID',
    BranchesID: 'BranchesID',
    TrackingStatusID: 'TrackingStatusID',
    Status: 'Status',
    IsActive: 'IsActive',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type OrderTackingScalarFieldEnum = (typeof OrderTackingScalarFieldEnum)[keyof typeof OrderTackingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    
  /**
   * Deep Input Types
   */


  export type provinceWhereInput = {
    AND?: provinceWhereInput | provinceWhereInput[]
    OR?: provinceWhereInput[]
    NOT?: provinceWhereInput | provinceWhereInput[]
    ID?: StringFilter<"province"> | string
    Name?: StringFilter<"province"> | string
    Status?: StringNullableFilter<"province"> | string | null
    IsActive?: BoolFilter<"province"> | boolean
    CreatedAt?: DateTimeFilter<"province"> | Date | string
    UpdatedAt?: DateTimeFilter<"province"> | Date | string
    District?: DistrictListRelationFilter
    Village?: VillageListRelationFilter
    Address?: AddressListRelationFilter
  }

  export type provinceOrderByWithRelationInput = {
    ID?: SortOrder
    Name?: SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    District?: districtOrderByRelationAggregateInput
    Village?: villageOrderByRelationAggregateInput
    Address?: addressOrderByRelationAggregateInput
  }

  export type provinceWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    Name?: string
    AND?: provinceWhereInput | provinceWhereInput[]
    OR?: provinceWhereInput[]
    NOT?: provinceWhereInput | provinceWhereInput[]
    Status?: StringNullableFilter<"province"> | string | null
    IsActive?: BoolFilter<"province"> | boolean
    CreatedAt?: DateTimeFilter<"province"> | Date | string
    UpdatedAt?: DateTimeFilter<"province"> | Date | string
    District?: DistrictListRelationFilter
    Village?: VillageListRelationFilter
    Address?: AddressListRelationFilter
  }, "ID" | "ID" | "Name">

  export type provinceOrderByWithAggregationInput = {
    ID?: SortOrder
    Name?: SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    _count?: provinceCountOrderByAggregateInput
    _max?: provinceMaxOrderByAggregateInput
    _min?: provinceMinOrderByAggregateInput
  }

  export type provinceScalarWhereWithAggregatesInput = {
    AND?: provinceScalarWhereWithAggregatesInput | provinceScalarWhereWithAggregatesInput[]
    OR?: provinceScalarWhereWithAggregatesInput[]
    NOT?: provinceScalarWhereWithAggregatesInput | provinceScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"province"> | string
    Name?: StringWithAggregatesFilter<"province"> | string
    Status?: StringNullableWithAggregatesFilter<"province"> | string | null
    IsActive?: BoolWithAggregatesFilter<"province"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"province"> | Date | string
    UpdatedAt?: DateTimeWithAggregatesFilter<"province"> | Date | string
  }

  export type districtWhereInput = {
    AND?: districtWhereInput | districtWhereInput[]
    OR?: districtWhereInput[]
    NOT?: districtWhereInput | districtWhereInput[]
    ID?: StringFilter<"district"> | string
    Name?: StringFilter<"district"> | string
    ProvinceID?: StringNullableFilter<"district"> | string | null
    Status?: StringNullableFilter<"district"> | string | null
    IsActive?: BoolFilter<"district"> | boolean
    CreatedAt?: DateTimeFilter<"district"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"district"> | Date | string | null
    Province?: XOR<ProvinceNullableRelationFilter, provinceWhereInput> | null
    Address?: AddressListRelationFilter
    Village?: VillageListRelationFilter
  }

  export type districtOrderByWithRelationInput = {
    ID?: SortOrder
    Name?: SortOrder
    ProvinceID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Province?: provinceOrderByWithRelationInput
    Address?: addressOrderByRelationAggregateInput
    Village?: villageOrderByRelationAggregateInput
  }

  export type districtWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    AND?: districtWhereInput | districtWhereInput[]
    OR?: districtWhereInput[]
    NOT?: districtWhereInput | districtWhereInput[]
    Name?: StringFilter<"district"> | string
    ProvinceID?: StringNullableFilter<"district"> | string | null
    Status?: StringNullableFilter<"district"> | string | null
    IsActive?: BoolFilter<"district"> | boolean
    CreatedAt?: DateTimeFilter<"district"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"district"> | Date | string | null
    Province?: XOR<ProvinceNullableRelationFilter, provinceWhereInput> | null
    Address?: AddressListRelationFilter
    Village?: VillageListRelationFilter
  }, "ID" | "ID">

  export type districtOrderByWithAggregationInput = {
    ID?: SortOrder
    Name?: SortOrder
    ProvinceID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: districtCountOrderByAggregateInput
    _max?: districtMaxOrderByAggregateInput
    _min?: districtMinOrderByAggregateInput
  }

  export type districtScalarWhereWithAggregatesInput = {
    AND?: districtScalarWhereWithAggregatesInput | districtScalarWhereWithAggregatesInput[]
    OR?: districtScalarWhereWithAggregatesInput[]
    NOT?: districtScalarWhereWithAggregatesInput | districtScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"district"> | string
    Name?: StringWithAggregatesFilter<"district"> | string
    ProvinceID?: StringNullableWithAggregatesFilter<"district"> | string | null
    Status?: StringNullableWithAggregatesFilter<"district"> | string | null
    IsActive?: BoolWithAggregatesFilter<"district"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"district"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"district"> | Date | string | null
  }

  export type villageWhereInput = {
    AND?: villageWhereInput | villageWhereInput[]
    OR?: villageWhereInput[]
    NOT?: villageWhereInput | villageWhereInput[]
    ID?: StringFilter<"village"> | string
    Name?: StringFilter<"village"> | string
    ProvinceID?: StringNullableFilter<"village"> | string | null
    DistrictID?: StringNullableFilter<"village"> | string | null
    Status?: StringNullableFilter<"village"> | string | null
    IsActive?: BoolFilter<"village"> | boolean
    CreatedAt?: DateTimeFilter<"village"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"village"> | Date | string | null
    Province?: XOR<ProvinceNullableRelationFilter, provinceWhereInput> | null
    District?: XOR<DistrictNullableRelationFilter, districtWhereInput> | null
  }

  export type villageOrderByWithRelationInput = {
    ID?: SortOrder
    Name?: SortOrder
    ProvinceID?: SortOrderInput | SortOrder
    DistrictID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Province?: provinceOrderByWithRelationInput
    District?: districtOrderByWithRelationInput
  }

  export type villageWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    AND?: villageWhereInput | villageWhereInput[]
    OR?: villageWhereInput[]
    NOT?: villageWhereInput | villageWhereInput[]
    Name?: StringFilter<"village"> | string
    ProvinceID?: StringNullableFilter<"village"> | string | null
    DistrictID?: StringNullableFilter<"village"> | string | null
    Status?: StringNullableFilter<"village"> | string | null
    IsActive?: BoolFilter<"village"> | boolean
    CreatedAt?: DateTimeFilter<"village"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"village"> | Date | string | null
    Province?: XOR<ProvinceNullableRelationFilter, provinceWhereInput> | null
    District?: XOR<DistrictNullableRelationFilter, districtWhereInput> | null
  }, "ID" | "ID">

  export type villageOrderByWithAggregationInput = {
    ID?: SortOrder
    Name?: SortOrder
    ProvinceID?: SortOrderInput | SortOrder
    DistrictID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: villageCountOrderByAggregateInput
    _max?: villageMaxOrderByAggregateInput
    _min?: villageMinOrderByAggregateInput
  }

  export type villageScalarWhereWithAggregatesInput = {
    AND?: villageScalarWhereWithAggregatesInput | villageScalarWhereWithAggregatesInput[]
    OR?: villageScalarWhereWithAggregatesInput[]
    NOT?: villageScalarWhereWithAggregatesInput | villageScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"village"> | string
    Name?: StringWithAggregatesFilter<"village"> | string
    ProvinceID?: StringNullableWithAggregatesFilter<"village"> | string | null
    DistrictID?: StringNullableWithAggregatesFilter<"village"> | string | null
    Status?: StringNullableWithAggregatesFilter<"village"> | string | null
    IsActive?: BoolWithAggregatesFilter<"village"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"village"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"village"> | Date | string | null
  }

  export type addressWhereInput = {
    AND?: addressWhereInput | addressWhereInput[]
    OR?: addressWhereInput[]
    NOT?: addressWhereInput | addressWhereInput[]
    ID?: StringFilter<"address"> | string
    Address?: StringFilter<"address"> | string
    ProvinceID?: StringNullableFilter<"address"> | string | null
    DistrictID?: StringNullableFilter<"address"> | string | null
    ProfileID?: StringNullableFilter<"address"> | string | null
    BranchesID?: StringNullableFilter<"address"> | string | null
    IsDefault?: BoolNullableFilter<"address"> | boolean | null
    Status?: StringNullableFilter<"address"> | string | null
    IsActive?: BoolFilter<"address"> | boolean
    CreatedAt?: DateTimeFilter<"address"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"address"> | Date | string | null
    Province?: XOR<ProvinceNullableRelationFilter, provinceWhereInput> | null
    District?: XOR<DistrictNullableRelationFilter, districtWhereInput> | null
    Profile?: XOR<ProfileNullableRelationFilter, profileWhereInput> | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
  }

  export type addressOrderByWithRelationInput = {
    ID?: SortOrder
    Address?: SortOrder
    ProvinceID?: SortOrderInput | SortOrder
    DistrictID?: SortOrderInput | SortOrder
    ProfileID?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    IsDefault?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Province?: provinceOrderByWithRelationInput
    District?: districtOrderByWithRelationInput
    Profile?: profileOrderByWithRelationInput
    Branches?: branchesOrderByWithRelationInput
  }

  export type addressWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    BranchesID?: string
    AND?: addressWhereInput | addressWhereInput[]
    OR?: addressWhereInput[]
    NOT?: addressWhereInput | addressWhereInput[]
    Address?: StringFilter<"address"> | string
    ProvinceID?: StringNullableFilter<"address"> | string | null
    DistrictID?: StringNullableFilter<"address"> | string | null
    ProfileID?: StringNullableFilter<"address"> | string | null
    IsDefault?: BoolNullableFilter<"address"> | boolean | null
    Status?: StringNullableFilter<"address"> | string | null
    IsActive?: BoolFilter<"address"> | boolean
    CreatedAt?: DateTimeFilter<"address"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"address"> | Date | string | null
    Province?: XOR<ProvinceNullableRelationFilter, provinceWhereInput> | null
    District?: XOR<DistrictNullableRelationFilter, districtWhereInput> | null
    Profile?: XOR<ProfileNullableRelationFilter, profileWhereInput> | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
  }, "ID" | "ID" | "BranchesID">

  export type addressOrderByWithAggregationInput = {
    ID?: SortOrder
    Address?: SortOrder
    ProvinceID?: SortOrderInput | SortOrder
    DistrictID?: SortOrderInput | SortOrder
    ProfileID?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    IsDefault?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: addressCountOrderByAggregateInput
    _max?: addressMaxOrderByAggregateInput
    _min?: addressMinOrderByAggregateInput
  }

  export type addressScalarWhereWithAggregatesInput = {
    AND?: addressScalarWhereWithAggregatesInput | addressScalarWhereWithAggregatesInput[]
    OR?: addressScalarWhereWithAggregatesInput[]
    NOT?: addressScalarWhereWithAggregatesInput | addressScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"address"> | string
    Address?: StringWithAggregatesFilter<"address"> | string
    ProvinceID?: StringNullableWithAggregatesFilter<"address"> | string | null
    DistrictID?: StringNullableWithAggregatesFilter<"address"> | string | null
    ProfileID?: StringNullableWithAggregatesFilter<"address"> | string | null
    BranchesID?: StringNullableWithAggregatesFilter<"address"> | string | null
    IsDefault?: BoolNullableWithAggregatesFilter<"address"> | boolean | null
    Status?: StringNullableWithAggregatesFilter<"address"> | string | null
    IsActive?: BoolWithAggregatesFilter<"address"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"address"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"address"> | Date | string | null
  }

  export type branchesWhereInput = {
    AND?: branchesWhereInput | branchesWhereInput[]
    OR?: branchesWhereInput[]
    NOT?: branchesWhereInput | branchesWhereInput[]
    ID?: StringFilter<"branches"> | string
    CompanyId?: StringFilter<"branches"> | string
    Name?: StringFilter<"branches"> | string
    Address1?: StringNullableFilter<"branches"> | string | null
    Address2?: StringNullableFilter<"branches"> | string | null
    Address3?: StringNullableFilter<"branches"> | string | null
    Status?: StringNullableFilter<"branches"> | string | null
    Lat?: FloatNullableFilter<"branches"> | number | null
    Long?: FloatNullableFilter<"branches"> | number | null
    Zone?: StringNullableFilter<"branches"> | string | null
    IsMain?: BoolNullableFilter<"branches"> | boolean | null
    UploadURL?: StringNullableFilter<"branches"> | string | null
    IsActive?: BoolFilter<"branches"> | boolean
    CreatedAt?: DateTimeFilter<"branches"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"branches"> | Date | string | null
    Address?: XOR<AddressNullableRelationFilter, addressWhereInput> | null
    User?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    BranchesKey?: BranchesKeyListRelationFilter
    BranchesSettings?: BranchesSettingsListRelationFilter
    Otp?: OtpListRelationFilter
    Notifications?: NotificationsListRelationFilter
    OrderCategory?: OrderCategoryListRelationFilter
    Order?: OrderListRelationFilter
    Tracking?: OrderTackingListRelationFilter
  }

  export type branchesOrderByWithRelationInput = {
    ID?: SortOrder
    CompanyId?: SortOrder
    Name?: SortOrder
    Address1?: SortOrderInput | SortOrder
    Address2?: SortOrderInput | SortOrder
    Address3?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Lat?: SortOrderInput | SortOrder
    Long?: SortOrderInput | SortOrder
    Zone?: SortOrderInput | SortOrder
    IsMain?: SortOrderInput | SortOrder
    UploadURL?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Address?: addressOrderByWithRelationInput
    User?: usersOrderByWithRelationInput
    BranchesKey?: branchesKeyOrderByRelationAggregateInput
    BranchesSettings?: branchesSettingsOrderByRelationAggregateInput
    Otp?: otpOrderByRelationAggregateInput
    Notifications?: notificationsOrderByRelationAggregateInput
    OrderCategory?: orderCategoryOrderByRelationAggregateInput
    Order?: orderOrderByRelationAggregateInput
    Tracking?: orderTackingOrderByRelationAggregateInput
  }

  export type branchesWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    Name?: string
    AND?: branchesWhereInput | branchesWhereInput[]
    OR?: branchesWhereInput[]
    NOT?: branchesWhereInput | branchesWhereInput[]
    CompanyId?: StringFilter<"branches"> | string
    Address1?: StringNullableFilter<"branches"> | string | null
    Address2?: StringNullableFilter<"branches"> | string | null
    Address3?: StringNullableFilter<"branches"> | string | null
    Status?: StringNullableFilter<"branches"> | string | null
    Lat?: FloatNullableFilter<"branches"> | number | null
    Long?: FloatNullableFilter<"branches"> | number | null
    Zone?: StringNullableFilter<"branches"> | string | null
    IsMain?: BoolNullableFilter<"branches"> | boolean | null
    UploadURL?: StringNullableFilter<"branches"> | string | null
    IsActive?: BoolFilter<"branches"> | boolean
    CreatedAt?: DateTimeFilter<"branches"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"branches"> | Date | string | null
    Address?: XOR<AddressNullableRelationFilter, addressWhereInput> | null
    User?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    BranchesKey?: BranchesKeyListRelationFilter
    BranchesSettings?: BranchesSettingsListRelationFilter
    Otp?: OtpListRelationFilter
    Notifications?: NotificationsListRelationFilter
    OrderCategory?: OrderCategoryListRelationFilter
    Order?: OrderListRelationFilter
    Tracking?: OrderTackingListRelationFilter
  }, "ID" | "ID" | "Name">

  export type branchesOrderByWithAggregationInput = {
    ID?: SortOrder
    CompanyId?: SortOrder
    Name?: SortOrder
    Address1?: SortOrderInput | SortOrder
    Address2?: SortOrderInput | SortOrder
    Address3?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Lat?: SortOrderInput | SortOrder
    Long?: SortOrderInput | SortOrder
    Zone?: SortOrderInput | SortOrder
    IsMain?: SortOrderInput | SortOrder
    UploadURL?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: branchesCountOrderByAggregateInput
    _avg?: branchesAvgOrderByAggregateInput
    _max?: branchesMaxOrderByAggregateInput
    _min?: branchesMinOrderByAggregateInput
    _sum?: branchesSumOrderByAggregateInput
  }

  export type branchesScalarWhereWithAggregatesInput = {
    AND?: branchesScalarWhereWithAggregatesInput | branchesScalarWhereWithAggregatesInput[]
    OR?: branchesScalarWhereWithAggregatesInput[]
    NOT?: branchesScalarWhereWithAggregatesInput | branchesScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"branches"> | string
    CompanyId?: StringWithAggregatesFilter<"branches"> | string
    Name?: StringWithAggregatesFilter<"branches"> | string
    Address1?: StringNullableWithAggregatesFilter<"branches"> | string | null
    Address2?: StringNullableWithAggregatesFilter<"branches"> | string | null
    Address3?: StringNullableWithAggregatesFilter<"branches"> | string | null
    Status?: StringNullableWithAggregatesFilter<"branches"> | string | null
    Lat?: FloatNullableWithAggregatesFilter<"branches"> | number | null
    Long?: FloatNullableWithAggregatesFilter<"branches"> | number | null
    Zone?: StringNullableWithAggregatesFilter<"branches"> | string | null
    IsMain?: BoolNullableWithAggregatesFilter<"branches"> | boolean | null
    UploadURL?: StringNullableWithAggregatesFilter<"branches"> | string | null
    IsActive?: BoolWithAggregatesFilter<"branches"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"branches"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"branches"> | Date | string | null
  }

  export type branchesKeyWhereInput = {
    AND?: branchesKeyWhereInput | branchesKeyWhereInput[]
    OR?: branchesKeyWhereInput[]
    NOT?: branchesKeyWhereInput | branchesKeyWhereInput[]
    ID?: StringFilter<"branchesKey"> | string
    Key?: StringFilter<"branchesKey"> | string
    Secret?: StringFilter<"branchesKey"> | string
    Remask?: StringNullableFilter<"branchesKey"> | string | null
    BranchesID?: StringNullableFilter<"branchesKey"> | string | null
    Status?: StringFilter<"branchesKey"> | string
    IsActive?: BoolFilter<"branchesKey"> | boolean
    CreatedAt?: DateTimeFilter<"branchesKey"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"branchesKey"> | Date | string | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
  }

  export type branchesKeyOrderByWithRelationInput = {
    ID?: SortOrder
    Key?: SortOrder
    Secret?: SortOrder
    Remask?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Branches?: branchesOrderByWithRelationInput
  }

  export type branchesKeyWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    Key?: string
    AND?: branchesKeyWhereInput | branchesKeyWhereInput[]
    OR?: branchesKeyWhereInput[]
    NOT?: branchesKeyWhereInput | branchesKeyWhereInput[]
    Secret?: StringFilter<"branchesKey"> | string
    Remask?: StringNullableFilter<"branchesKey"> | string | null
    BranchesID?: StringNullableFilter<"branchesKey"> | string | null
    Status?: StringFilter<"branchesKey"> | string
    IsActive?: BoolFilter<"branchesKey"> | boolean
    CreatedAt?: DateTimeFilter<"branchesKey"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"branchesKey"> | Date | string | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
  }, "ID" | "ID" | "Key">

  export type branchesKeyOrderByWithAggregationInput = {
    ID?: SortOrder
    Key?: SortOrder
    Secret?: SortOrder
    Remask?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: branchesKeyCountOrderByAggregateInput
    _max?: branchesKeyMaxOrderByAggregateInput
    _min?: branchesKeyMinOrderByAggregateInput
  }

  export type branchesKeyScalarWhereWithAggregatesInput = {
    AND?: branchesKeyScalarWhereWithAggregatesInput | branchesKeyScalarWhereWithAggregatesInput[]
    OR?: branchesKeyScalarWhereWithAggregatesInput[]
    NOT?: branchesKeyScalarWhereWithAggregatesInput | branchesKeyScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"branchesKey"> | string
    Key?: StringWithAggregatesFilter<"branchesKey"> | string
    Secret?: StringWithAggregatesFilter<"branchesKey"> | string
    Remask?: StringNullableWithAggregatesFilter<"branchesKey"> | string | null
    BranchesID?: StringNullableWithAggregatesFilter<"branchesKey"> | string | null
    Status?: StringWithAggregatesFilter<"branchesKey"> | string
    IsActive?: BoolWithAggregatesFilter<"branchesKey"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"branchesKey"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"branchesKey"> | Date | string | null
  }

  export type branchesSettingsWhereInput = {
    AND?: branchesSettingsWhereInput | branchesSettingsWhereInput[]
    OR?: branchesSettingsWhereInput[]
    NOT?: branchesSettingsWhereInput | branchesSettingsWhereInput[]
    ID?: StringFilter<"branchesSettings"> | string
    Titel?: StringFilter<"branchesSettings"> | string
    Setting?: StringFilter<"branchesSettings"> | string
    Remask?: StringNullableFilter<"branchesSettings"> | string | null
    BranchesID?: StringNullableFilter<"branchesSettings"> | string | null
    Status?: StringFilter<"branchesSettings"> | string
    IsActive?: BoolFilter<"branchesSettings"> | boolean
    CreatedAt?: DateTimeFilter<"branchesSettings"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"branchesSettings"> | Date | string | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
  }

  export type branchesSettingsOrderByWithRelationInput = {
    ID?: SortOrder
    Titel?: SortOrder
    Setting?: SortOrder
    Remask?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Branches?: branchesOrderByWithRelationInput
  }

  export type branchesSettingsWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    AND?: branchesSettingsWhereInput | branchesSettingsWhereInput[]
    OR?: branchesSettingsWhereInput[]
    NOT?: branchesSettingsWhereInput | branchesSettingsWhereInput[]
    Titel?: StringFilter<"branchesSettings"> | string
    Setting?: StringFilter<"branchesSettings"> | string
    Remask?: StringNullableFilter<"branchesSettings"> | string | null
    BranchesID?: StringNullableFilter<"branchesSettings"> | string | null
    Status?: StringFilter<"branchesSettings"> | string
    IsActive?: BoolFilter<"branchesSettings"> | boolean
    CreatedAt?: DateTimeFilter<"branchesSettings"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"branchesSettings"> | Date | string | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
  }, "ID" | "ID">

  export type branchesSettingsOrderByWithAggregationInput = {
    ID?: SortOrder
    Titel?: SortOrder
    Setting?: SortOrder
    Remask?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: branchesSettingsCountOrderByAggregateInput
    _max?: branchesSettingsMaxOrderByAggregateInput
    _min?: branchesSettingsMinOrderByAggregateInput
  }

  export type branchesSettingsScalarWhereWithAggregatesInput = {
    AND?: branchesSettingsScalarWhereWithAggregatesInput | branchesSettingsScalarWhereWithAggregatesInput[]
    OR?: branchesSettingsScalarWhereWithAggregatesInput[]
    NOT?: branchesSettingsScalarWhereWithAggregatesInput | branchesSettingsScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"branchesSettings"> | string
    Titel?: StringWithAggregatesFilter<"branchesSettings"> | string
    Setting?: StringWithAggregatesFilter<"branchesSettings"> | string
    Remask?: StringNullableWithAggregatesFilter<"branchesSettings"> | string | null
    BranchesID?: StringNullableWithAggregatesFilter<"branchesSettings"> | string | null
    Status?: StringWithAggregatesFilter<"branchesSettings"> | string
    IsActive?: BoolWithAggregatesFilter<"branchesSettings"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"branchesSettings"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"branchesSettings"> | Date | string | null
  }

  export type walletWhereInput = {
    AND?: walletWhereInput | walletWhereInput[]
    OR?: walletWhereInput[]
    NOT?: walletWhereInput | walletWhereInput[]
    ID?: StringFilter<"wallet"> | string
    Balance?: FloatNullableFilter<"wallet"> | number | null
    Title?: StringNullableFilter<"wallet"> | string | null
    Description?: StringNullableFilter<"wallet"> | string | null
    IsReal?: BoolNullableFilter<"wallet"> | boolean | null
    UserID?: StringNullableFilter<"wallet"> | string | null
    Status?: StringNullableFilter<"wallet"> | string | null
    Remask?: StringNullableFilter<"wallet"> | string | null
    IsActive?: BoolFilter<"wallet"> | boolean
    CreatedAt?: DateTimeFilter<"wallet"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"wallet"> | Date | string | null
    User?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    Receive?: TransactionListRelationFilter
    Payment?: TransactionListRelationFilter
  }

  export type walletOrderByWithRelationInput = {
    ID?: SortOrder
    Balance?: SortOrderInput | SortOrder
    Title?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    IsReal?: SortOrderInput | SortOrder
    UserID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    User?: usersOrderByWithRelationInput
    Receive?: transactionOrderByRelationAggregateInput
    Payment?: transactionOrderByRelationAggregateInput
  }

  export type walletWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    AND?: walletWhereInput | walletWhereInput[]
    OR?: walletWhereInput[]
    NOT?: walletWhereInput | walletWhereInput[]
    Balance?: FloatNullableFilter<"wallet"> | number | null
    Title?: StringNullableFilter<"wallet"> | string | null
    Description?: StringNullableFilter<"wallet"> | string | null
    IsReal?: BoolNullableFilter<"wallet"> | boolean | null
    UserID?: StringNullableFilter<"wallet"> | string | null
    Status?: StringNullableFilter<"wallet"> | string | null
    Remask?: StringNullableFilter<"wallet"> | string | null
    IsActive?: BoolFilter<"wallet"> | boolean
    CreatedAt?: DateTimeFilter<"wallet"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"wallet"> | Date | string | null
    User?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    Receive?: TransactionListRelationFilter
    Payment?: TransactionListRelationFilter
  }, "ID" | "ID">

  export type walletOrderByWithAggregationInput = {
    ID?: SortOrder
    Balance?: SortOrderInput | SortOrder
    Title?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    IsReal?: SortOrderInput | SortOrder
    UserID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: walletCountOrderByAggregateInput
    _avg?: walletAvgOrderByAggregateInput
    _max?: walletMaxOrderByAggregateInput
    _min?: walletMinOrderByAggregateInput
    _sum?: walletSumOrderByAggregateInput
  }

  export type walletScalarWhereWithAggregatesInput = {
    AND?: walletScalarWhereWithAggregatesInput | walletScalarWhereWithAggregatesInput[]
    OR?: walletScalarWhereWithAggregatesInput[]
    NOT?: walletScalarWhereWithAggregatesInput | walletScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"wallet"> | string
    Balance?: FloatNullableWithAggregatesFilter<"wallet"> | number | null
    Title?: StringNullableWithAggregatesFilter<"wallet"> | string | null
    Description?: StringNullableWithAggregatesFilter<"wallet"> | string | null
    IsReal?: BoolNullableWithAggregatesFilter<"wallet"> | boolean | null
    UserID?: StringNullableWithAggregatesFilter<"wallet"> | string | null
    Status?: StringNullableWithAggregatesFilter<"wallet"> | string | null
    Remask?: StringNullableWithAggregatesFilter<"wallet"> | string | null
    IsActive?: BoolWithAggregatesFilter<"wallet"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"wallet"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"wallet"> | Date | string | null
  }

  export type transactionWhereInput = {
    AND?: transactionWhereInput | transactionWhereInput[]
    OR?: transactionWhereInput[]
    NOT?: transactionWhereInput | transactionWhereInput[]
    ID?: StringFilter<"transaction"> | string
    Type?: StringNullableFilter<"transaction"> | string | null
    Info?: StringNullableFilter<"transaction"> | string | null
    Status?: StringNullableFilter<"transaction"> | string | null
    Result?: FloatNullableFilter<"transaction"> | number | null
    Balance?: FloatNullableFilter<"transaction"> | number | null
    IsPayment?: BoolNullableFilter<"transaction"> | boolean | null
    IsReceived?: BoolNullableFilter<"transaction"> | boolean | null
    OrderPaymentID?: StringNullableFilter<"transaction"> | string | null
    PaidByID?: StringNullableFilter<"transaction"> | string | null
    PaidToID?: StringNullableFilter<"transaction"> | string | null
    IsActive?: BoolFilter<"transaction"> | boolean
    CreatedAt?: DateTimeFilter<"transaction"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"transaction"> | Date | string | null
    OrderPayment?: XOR<OrderPaymentNullableRelationFilter, orderPaymentWhereInput> | null
    PaidBy?: XOR<WalletNullableRelationFilter, walletWhereInput> | null
    PaidTo?: XOR<WalletNullableRelationFilter, walletWhereInput> | null
  }

  export type transactionOrderByWithRelationInput = {
    ID?: SortOrder
    Type?: SortOrderInput | SortOrder
    Info?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Result?: SortOrderInput | SortOrder
    Balance?: SortOrderInput | SortOrder
    IsPayment?: SortOrderInput | SortOrder
    IsReceived?: SortOrderInput | SortOrder
    OrderPaymentID?: SortOrderInput | SortOrder
    PaidByID?: SortOrderInput | SortOrder
    PaidToID?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    OrderPayment?: orderPaymentOrderByWithRelationInput
    PaidBy?: walletOrderByWithRelationInput
    PaidTo?: walletOrderByWithRelationInput
  }

  export type transactionWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    OrderPaymentID?: string
    AND?: transactionWhereInput | transactionWhereInput[]
    OR?: transactionWhereInput[]
    NOT?: transactionWhereInput | transactionWhereInput[]
    Type?: StringNullableFilter<"transaction"> | string | null
    Info?: StringNullableFilter<"transaction"> | string | null
    Status?: StringNullableFilter<"transaction"> | string | null
    Result?: FloatNullableFilter<"transaction"> | number | null
    Balance?: FloatNullableFilter<"transaction"> | number | null
    IsPayment?: BoolNullableFilter<"transaction"> | boolean | null
    IsReceived?: BoolNullableFilter<"transaction"> | boolean | null
    PaidByID?: StringNullableFilter<"transaction"> | string | null
    PaidToID?: StringNullableFilter<"transaction"> | string | null
    IsActive?: BoolFilter<"transaction"> | boolean
    CreatedAt?: DateTimeFilter<"transaction"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"transaction"> | Date | string | null
    OrderPayment?: XOR<OrderPaymentNullableRelationFilter, orderPaymentWhereInput> | null
    PaidBy?: XOR<WalletNullableRelationFilter, walletWhereInput> | null
    PaidTo?: XOR<WalletNullableRelationFilter, walletWhereInput> | null
  }, "ID" | "ID" | "OrderPaymentID">

  export type transactionOrderByWithAggregationInput = {
    ID?: SortOrder
    Type?: SortOrderInput | SortOrder
    Info?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Result?: SortOrderInput | SortOrder
    Balance?: SortOrderInput | SortOrder
    IsPayment?: SortOrderInput | SortOrder
    IsReceived?: SortOrderInput | SortOrder
    OrderPaymentID?: SortOrderInput | SortOrder
    PaidByID?: SortOrderInput | SortOrder
    PaidToID?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: transactionCountOrderByAggregateInput
    _avg?: transactionAvgOrderByAggregateInput
    _max?: transactionMaxOrderByAggregateInput
    _min?: transactionMinOrderByAggregateInput
    _sum?: transactionSumOrderByAggregateInput
  }

  export type transactionScalarWhereWithAggregatesInput = {
    AND?: transactionScalarWhereWithAggregatesInput | transactionScalarWhereWithAggregatesInput[]
    OR?: transactionScalarWhereWithAggregatesInput[]
    NOT?: transactionScalarWhereWithAggregatesInput | transactionScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"transaction"> | string
    Type?: StringNullableWithAggregatesFilter<"transaction"> | string | null
    Info?: StringNullableWithAggregatesFilter<"transaction"> | string | null
    Status?: StringNullableWithAggregatesFilter<"transaction"> | string | null
    Result?: FloatNullableWithAggregatesFilter<"transaction"> | number | null
    Balance?: FloatNullableWithAggregatesFilter<"transaction"> | number | null
    IsPayment?: BoolNullableWithAggregatesFilter<"transaction"> | boolean | null
    IsReceived?: BoolNullableWithAggregatesFilter<"transaction"> | boolean | null
    OrderPaymentID?: StringNullableWithAggregatesFilter<"transaction"> | string | null
    PaidByID?: StringNullableWithAggregatesFilter<"transaction"> | string | null
    PaidToID?: StringNullableWithAggregatesFilter<"transaction"> | string | null
    IsActive?: BoolWithAggregatesFilter<"transaction"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"transaction"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"transaction"> | Date | string | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    ID?: StringFilter<"users"> | string
    UserName?: StringFilter<"users"> | string
    Password?: StringFilter<"users"> | string
    URL?: StringNullableFilter<"users"> | string | null
    PhoneNumber?: StringFilter<"users"> | string
    Email?: StringNullableFilter<"users"> | string | null
    Pin?: StringNullableFilter<"users"> | string | null
    IsRemember?: BoolNullableFilter<"users"> | boolean | null
    IsPin?: BoolNullableFilter<"users"> | boolean | null
    IsBiometric?: BoolNullableFilter<"users"> | boolean | null
    Status?: StringNullableFilter<"users"> | string | null
    Remask?: StringNullableFilter<"users"> | string | null
    LastActive?: DateTimeNullableFilter<"users"> | Date | string | null
    BranchesID?: StringNullableFilter<"users"> | string | null
    IsActive?: BoolFilter<"users"> | boolean
    CreatedAt?: DateTimeFilter<"users"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"users"> | Date | string | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
    Wallet?: WalletListRelationFilter
    RecipientPayment?: OrderPaymentListRelationFilter
    AdminProfile?: ProfileListRelationFilter
    UserProfile?: XOR<ProfileNullableRelationFilter, profileWhereInput> | null
    OTP?: OtpListRelationFilter
    Roles?: UsersRolesListRelationFilter
    Forgot?: ForgotPasswordListRelationFilter
    Notifications?: NotificationsListRelationFilter
    Activities?: UsersActivitiesListRelationFilter
    Order?: OrderListRelationFilter
    SenderOrder?: OrderPersonalListRelationFilter
    RecipientOrder?: OrderPersonalListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    ID?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    URL?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrder
    Email?: SortOrderInput | SortOrder
    Pin?: SortOrderInput | SortOrder
    IsRemember?: SortOrderInput | SortOrder
    IsPin?: SortOrderInput | SortOrder
    IsBiometric?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    LastActive?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Branches?: branchesOrderByWithRelationInput
    Wallet?: walletOrderByRelationAggregateInput
    RecipientPayment?: orderPaymentOrderByRelationAggregateInput
    AdminProfile?: profileOrderByRelationAggregateInput
    UserProfile?: profileOrderByWithRelationInput
    OTP?: otpOrderByRelationAggregateInput
    Roles?: usersRolesOrderByRelationAggregateInput
    Forgot?: forgotPasswordOrderByRelationAggregateInput
    Notifications?: notificationsOrderByRelationAggregateInput
    Activities?: usersActivitiesOrderByRelationAggregateInput
    Order?: orderOrderByRelationAggregateInput
    SenderOrder?: orderPersonalOrderByRelationAggregateInput
    RecipientOrder?: orderPersonalOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    UserName?: string
    BranchesID?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    Password?: StringFilter<"users"> | string
    URL?: StringNullableFilter<"users"> | string | null
    PhoneNumber?: StringFilter<"users"> | string
    Email?: StringNullableFilter<"users"> | string | null
    Pin?: StringNullableFilter<"users"> | string | null
    IsRemember?: BoolNullableFilter<"users"> | boolean | null
    IsPin?: BoolNullableFilter<"users"> | boolean | null
    IsBiometric?: BoolNullableFilter<"users"> | boolean | null
    Status?: StringNullableFilter<"users"> | string | null
    Remask?: StringNullableFilter<"users"> | string | null
    LastActive?: DateTimeNullableFilter<"users"> | Date | string | null
    IsActive?: BoolFilter<"users"> | boolean
    CreatedAt?: DateTimeFilter<"users"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"users"> | Date | string | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
    Wallet?: WalletListRelationFilter
    RecipientPayment?: OrderPaymentListRelationFilter
    AdminProfile?: ProfileListRelationFilter
    UserProfile?: XOR<ProfileNullableRelationFilter, profileWhereInput> | null
    OTP?: OtpListRelationFilter
    Roles?: UsersRolesListRelationFilter
    Forgot?: ForgotPasswordListRelationFilter
    Notifications?: NotificationsListRelationFilter
    Activities?: UsersActivitiesListRelationFilter
    Order?: OrderListRelationFilter
    SenderOrder?: OrderPersonalListRelationFilter
    RecipientOrder?: OrderPersonalListRelationFilter
  }, "ID" | "ID" | "UserName" | "BranchesID">

  export type usersOrderByWithAggregationInput = {
    ID?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    URL?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrder
    Email?: SortOrderInput | SortOrder
    Pin?: SortOrderInput | SortOrder
    IsRemember?: SortOrderInput | SortOrder
    IsPin?: SortOrderInput | SortOrder
    IsBiometric?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    LastActive?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"users"> | string
    UserName?: StringWithAggregatesFilter<"users"> | string
    Password?: StringWithAggregatesFilter<"users"> | string
    URL?: StringNullableWithAggregatesFilter<"users"> | string | null
    PhoneNumber?: StringWithAggregatesFilter<"users"> | string
    Email?: StringNullableWithAggregatesFilter<"users"> | string | null
    Pin?: StringNullableWithAggregatesFilter<"users"> | string | null
    IsRemember?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    IsPin?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    IsBiometric?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    Status?: StringNullableWithAggregatesFilter<"users"> | string | null
    Remask?: StringNullableWithAggregatesFilter<"users"> | string | null
    LastActive?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    BranchesID?: StringNullableWithAggregatesFilter<"users"> | string | null
    IsActive?: BoolWithAggregatesFilter<"users"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type profileWhereInput = {
    AND?: profileWhereInput | profileWhereInput[]
    OR?: profileWhereInput[]
    NOT?: profileWhereInput | profileWhereInput[]
    ID?: StringFilter<"profile"> | string
    Gender?: StringNullableFilter<"profile"> | string | null
    Name?: StringFilter<"profile"> | string
    SurName?: StringFilter<"profile"> | string
    ProfileURL?: StringNullableFilter<"profile"> | string | null
    UserID?: StringNullableFilter<"profile"> | string | null
    AdminID?: StringNullableFilter<"profile"> | string | null
    AdminPin?: StringNullableFilter<"profile"> | string | null
    Remask?: StringNullableFilter<"profile"> | string | null
    Status?: StringNullableFilter<"profile"> | string | null
    IsActive?: BoolFilter<"profile"> | boolean
    CreatedAt?: DateTimeFilter<"profile"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"profile"> | Date | string | null
    User?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    Admin?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    Address?: AddressListRelationFilter
  }

  export type profileOrderByWithRelationInput = {
    ID?: SortOrder
    Gender?: SortOrderInput | SortOrder
    Name?: SortOrder
    SurName?: SortOrder
    ProfileURL?: SortOrderInput | SortOrder
    UserID?: SortOrderInput | SortOrder
    AdminID?: SortOrderInput | SortOrder
    AdminPin?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    User?: usersOrderByWithRelationInput
    Admin?: usersOrderByWithRelationInput
    Address?: addressOrderByRelationAggregateInput
  }

  export type profileWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    UserID?: string
    AND?: profileWhereInput | profileWhereInput[]
    OR?: profileWhereInput[]
    NOT?: profileWhereInput | profileWhereInput[]
    Gender?: StringNullableFilter<"profile"> | string | null
    Name?: StringFilter<"profile"> | string
    SurName?: StringFilter<"profile"> | string
    ProfileURL?: StringNullableFilter<"profile"> | string | null
    AdminID?: StringNullableFilter<"profile"> | string | null
    AdminPin?: StringNullableFilter<"profile"> | string | null
    Remask?: StringNullableFilter<"profile"> | string | null
    Status?: StringNullableFilter<"profile"> | string | null
    IsActive?: BoolFilter<"profile"> | boolean
    CreatedAt?: DateTimeFilter<"profile"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"profile"> | Date | string | null
    User?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    Admin?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    Address?: AddressListRelationFilter
  }, "ID" | "ID" | "UserID">

  export type profileOrderByWithAggregationInput = {
    ID?: SortOrder
    Gender?: SortOrderInput | SortOrder
    Name?: SortOrder
    SurName?: SortOrder
    ProfileURL?: SortOrderInput | SortOrder
    UserID?: SortOrderInput | SortOrder
    AdminID?: SortOrderInput | SortOrder
    AdminPin?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: profileCountOrderByAggregateInput
    _max?: profileMaxOrderByAggregateInput
    _min?: profileMinOrderByAggregateInput
  }

  export type profileScalarWhereWithAggregatesInput = {
    AND?: profileScalarWhereWithAggregatesInput | profileScalarWhereWithAggregatesInput[]
    OR?: profileScalarWhereWithAggregatesInput[]
    NOT?: profileScalarWhereWithAggregatesInput | profileScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"profile"> | string
    Gender?: StringNullableWithAggregatesFilter<"profile"> | string | null
    Name?: StringWithAggregatesFilter<"profile"> | string
    SurName?: StringWithAggregatesFilter<"profile"> | string
    ProfileURL?: StringNullableWithAggregatesFilter<"profile"> | string | null
    UserID?: StringNullableWithAggregatesFilter<"profile"> | string | null
    AdminID?: StringNullableWithAggregatesFilter<"profile"> | string | null
    AdminPin?: StringNullableWithAggregatesFilter<"profile"> | string | null
    Remask?: StringNullableWithAggregatesFilter<"profile"> | string | null
    Status?: StringNullableWithAggregatesFilter<"profile"> | string | null
    IsActive?: BoolWithAggregatesFilter<"profile"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"profile"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"profile"> | Date | string | null
  }

  export type otpWhereInput = {
    AND?: otpWhereInput | otpWhereInput[]
    OR?: otpWhereInput[]
    NOT?: otpWhereInput | otpWhereInput[]
    ID?: StringFilter<"otp"> | string
    OTP?: StringNullableFilter<"otp"> | string | null
    IsVerify?: BoolFilter<"otp"> | boolean
    UserName?: StringFilter<"otp"> | string
    Type?: StringNullableFilter<"otp"> | string | null
    Remask?: StringNullableFilter<"otp"> | string | null
    UsersID?: StringNullableFilter<"otp"> | string | null
    BranchesID?: StringNullableFilter<"otp"> | string | null
    SmsGatewayUUID?: StringNullableFilter<"otp"> | string | null
    Status?: StringNullableFilter<"otp"> | string | null
    IsActive?: BoolFilter<"otp"> | boolean
    CreatedAt?: DateTimeFilter<"otp"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"otp"> | Date | string | null
    Users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
  }

  export type otpOrderByWithRelationInput = {
    ID?: SortOrder
    OTP?: SortOrderInput | SortOrder
    IsVerify?: SortOrder
    UserName?: SortOrder
    Type?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    UsersID?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    SmsGatewayUUID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Users?: usersOrderByWithRelationInput
    Branches?: branchesOrderByWithRelationInput
  }

  export type otpWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    AND?: otpWhereInput | otpWhereInput[]
    OR?: otpWhereInput[]
    NOT?: otpWhereInput | otpWhereInput[]
    OTP?: StringNullableFilter<"otp"> | string | null
    IsVerify?: BoolFilter<"otp"> | boolean
    UserName?: StringFilter<"otp"> | string
    Type?: StringNullableFilter<"otp"> | string | null
    Remask?: StringNullableFilter<"otp"> | string | null
    UsersID?: StringNullableFilter<"otp"> | string | null
    BranchesID?: StringNullableFilter<"otp"> | string | null
    SmsGatewayUUID?: StringNullableFilter<"otp"> | string | null
    Status?: StringNullableFilter<"otp"> | string | null
    IsActive?: BoolFilter<"otp"> | boolean
    CreatedAt?: DateTimeFilter<"otp"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"otp"> | Date | string | null
    Users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
  }, "ID" | "ID">

  export type otpOrderByWithAggregationInput = {
    ID?: SortOrder
    OTP?: SortOrderInput | SortOrder
    IsVerify?: SortOrder
    UserName?: SortOrder
    Type?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    UsersID?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    SmsGatewayUUID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: otpCountOrderByAggregateInput
    _max?: otpMaxOrderByAggregateInput
    _min?: otpMinOrderByAggregateInput
  }

  export type otpScalarWhereWithAggregatesInput = {
    AND?: otpScalarWhereWithAggregatesInput | otpScalarWhereWithAggregatesInput[]
    OR?: otpScalarWhereWithAggregatesInput[]
    NOT?: otpScalarWhereWithAggregatesInput | otpScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"otp"> | string
    OTP?: StringNullableWithAggregatesFilter<"otp"> | string | null
    IsVerify?: BoolWithAggregatesFilter<"otp"> | boolean
    UserName?: StringWithAggregatesFilter<"otp"> | string
    Type?: StringNullableWithAggregatesFilter<"otp"> | string | null
    Remask?: StringNullableWithAggregatesFilter<"otp"> | string | null
    UsersID?: StringNullableWithAggregatesFilter<"otp"> | string | null
    BranchesID?: StringNullableWithAggregatesFilter<"otp"> | string | null
    SmsGatewayUUID?: StringNullableWithAggregatesFilter<"otp"> | string | null
    Status?: StringNullableWithAggregatesFilter<"otp"> | string | null
    IsActive?: BoolWithAggregatesFilter<"otp"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"otp"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"otp"> | Date | string | null
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    ID?: StringFilter<"notifications"> | string
    Titel?: StringNullableFilter<"notifications"> | string | null
    Details?: StringNullableFilter<"notifications"> | string | null
    Type?: StringNullableFilter<"notifications"> | string | null
    Provider?: StringNullableFilter<"notifications"> | string | null
    Remask?: StringNullableFilter<"notifications"> | string | null
    UsersID?: StringNullableFilter<"notifications"> | string | null
    BranchesID?: StringNullableFilter<"notifications"> | string | null
    SmsGatewayUUID?: StringNullableFilter<"notifications"> | string | null
    Status?: StringNullableFilter<"notifications"> | string | null
    IsActive?: BoolFilter<"notifications"> | boolean
    CreatedAt?: DateTimeFilter<"notifications"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"notifications"> | Date | string | null
    Users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
  }

  export type notificationsOrderByWithRelationInput = {
    ID?: SortOrder
    Titel?: SortOrderInput | SortOrder
    Details?: SortOrderInput | SortOrder
    Type?: SortOrderInput | SortOrder
    Provider?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    UsersID?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    SmsGatewayUUID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Users?: usersOrderByWithRelationInput
    Branches?: branchesOrderByWithRelationInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    Titel?: StringNullableFilter<"notifications"> | string | null
    Details?: StringNullableFilter<"notifications"> | string | null
    Type?: StringNullableFilter<"notifications"> | string | null
    Provider?: StringNullableFilter<"notifications"> | string | null
    Remask?: StringNullableFilter<"notifications"> | string | null
    UsersID?: StringNullableFilter<"notifications"> | string | null
    BranchesID?: StringNullableFilter<"notifications"> | string | null
    SmsGatewayUUID?: StringNullableFilter<"notifications"> | string | null
    Status?: StringNullableFilter<"notifications"> | string | null
    IsActive?: BoolFilter<"notifications"> | boolean
    CreatedAt?: DateTimeFilter<"notifications"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"notifications"> | Date | string | null
    Users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
  }, "ID" | "ID">

  export type notificationsOrderByWithAggregationInput = {
    ID?: SortOrder
    Titel?: SortOrderInput | SortOrder
    Details?: SortOrderInput | SortOrder
    Type?: SortOrderInput | SortOrder
    Provider?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    UsersID?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    SmsGatewayUUID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"notifications"> | string
    Titel?: StringNullableWithAggregatesFilter<"notifications"> | string | null
    Details?: StringNullableWithAggregatesFilter<"notifications"> | string | null
    Type?: StringNullableWithAggregatesFilter<"notifications"> | string | null
    Provider?: StringNullableWithAggregatesFilter<"notifications"> | string | null
    Remask?: StringNullableWithAggregatesFilter<"notifications"> | string | null
    UsersID?: StringNullableWithAggregatesFilter<"notifications"> | string | null
    BranchesID?: StringNullableWithAggregatesFilter<"notifications"> | string | null
    SmsGatewayUUID?: StringNullableWithAggregatesFilter<"notifications"> | string | null
    Status?: StringNullableWithAggregatesFilter<"notifications"> | string | null
    IsActive?: BoolWithAggregatesFilter<"notifications"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"notifications"> | Date | string | null
  }

  export type forgotPasswordWhereInput = {
    AND?: forgotPasswordWhereInput | forgotPasswordWhereInput[]
    OR?: forgotPasswordWhereInput[]
    NOT?: forgotPasswordWhereInput | forgotPasswordWhereInput[]
    ID?: StringFilter<"forgotPassword"> | string
    Titel?: StringNullableFilter<"forgotPassword"> | string | null
    Token?: StringNullableFilter<"forgotPassword"> | string | null
    OldPassword?: StringNullableFilter<"forgotPassword"> | string | null
    OtpID?: StringNullableFilter<"forgotPassword"> | string | null
    Provider?: StringNullableFilter<"forgotPassword"> | string | null
    Remask?: StringNullableFilter<"forgotPassword"> | string | null
    UsersID?: StringNullableFilter<"forgotPassword"> | string | null
    Status?: StringNullableFilter<"forgotPassword"> | string | null
    IsActive?: BoolFilter<"forgotPassword"> | boolean
    CreatedAt?: DateTimeFilter<"forgotPassword"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"forgotPassword"> | Date | string | null
    Users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type forgotPasswordOrderByWithRelationInput = {
    ID?: SortOrder
    Titel?: SortOrderInput | SortOrder
    Token?: SortOrderInput | SortOrder
    OldPassword?: SortOrderInput | SortOrder
    OtpID?: SortOrderInput | SortOrder
    Provider?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    UsersID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Users?: usersOrderByWithRelationInput
  }

  export type forgotPasswordWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    AND?: forgotPasswordWhereInput | forgotPasswordWhereInput[]
    OR?: forgotPasswordWhereInput[]
    NOT?: forgotPasswordWhereInput | forgotPasswordWhereInput[]
    Titel?: StringNullableFilter<"forgotPassword"> | string | null
    Token?: StringNullableFilter<"forgotPassword"> | string | null
    OldPassword?: StringNullableFilter<"forgotPassword"> | string | null
    OtpID?: StringNullableFilter<"forgotPassword"> | string | null
    Provider?: StringNullableFilter<"forgotPassword"> | string | null
    Remask?: StringNullableFilter<"forgotPassword"> | string | null
    UsersID?: StringNullableFilter<"forgotPassword"> | string | null
    Status?: StringNullableFilter<"forgotPassword"> | string | null
    IsActive?: BoolFilter<"forgotPassword"> | boolean
    CreatedAt?: DateTimeFilter<"forgotPassword"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"forgotPassword"> | Date | string | null
    Users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "ID" | "ID">

  export type forgotPasswordOrderByWithAggregationInput = {
    ID?: SortOrder
    Titel?: SortOrderInput | SortOrder
    Token?: SortOrderInput | SortOrder
    OldPassword?: SortOrderInput | SortOrder
    OtpID?: SortOrderInput | SortOrder
    Provider?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    UsersID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: forgotPasswordCountOrderByAggregateInput
    _max?: forgotPasswordMaxOrderByAggregateInput
    _min?: forgotPasswordMinOrderByAggregateInput
  }

  export type forgotPasswordScalarWhereWithAggregatesInput = {
    AND?: forgotPasswordScalarWhereWithAggregatesInput | forgotPasswordScalarWhereWithAggregatesInput[]
    OR?: forgotPasswordScalarWhereWithAggregatesInput[]
    NOT?: forgotPasswordScalarWhereWithAggregatesInput | forgotPasswordScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"forgotPassword"> | string
    Titel?: StringNullableWithAggregatesFilter<"forgotPassword"> | string | null
    Token?: StringNullableWithAggregatesFilter<"forgotPassword"> | string | null
    OldPassword?: StringNullableWithAggregatesFilter<"forgotPassword"> | string | null
    OtpID?: StringNullableWithAggregatesFilter<"forgotPassword"> | string | null
    Provider?: StringNullableWithAggregatesFilter<"forgotPassword"> | string | null
    Remask?: StringNullableWithAggregatesFilter<"forgotPassword"> | string | null
    UsersID?: StringNullableWithAggregatesFilter<"forgotPassword"> | string | null
    Status?: StringNullableWithAggregatesFilter<"forgotPassword"> | string | null
    IsActive?: BoolWithAggregatesFilter<"forgotPassword"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"forgotPassword"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"forgotPassword"> | Date | string | null
  }

  export type usersRolesWhereInput = {
    AND?: usersRolesWhereInput | usersRolesWhereInput[]
    OR?: usersRolesWhereInput[]
    NOT?: usersRolesWhereInput | usersRolesWhereInput[]
    ID?: StringFilter<"usersRoles"> | string
    Titel?: StringNullableFilter<"usersRoles"> | string | null
    Type?: StringNullableFilter<"usersRoles"> | string | null
    Role?: StringFilter<"usersRoles"> | string
    Permission?: StringFilter<"usersRoles"> | string
    Remask?: StringNullableFilter<"usersRoles"> | string | null
    UsersID?: StringNullableFilter<"usersRoles"> | string | null
    Status?: StringNullableFilter<"usersRoles"> | string | null
    IsActive?: BoolFilter<"usersRoles"> | boolean
    CreatedAt?: DateTimeFilter<"usersRoles"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"usersRoles"> | Date | string | null
    Users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type usersRolesOrderByWithRelationInput = {
    ID?: SortOrder
    Titel?: SortOrderInput | SortOrder
    Type?: SortOrderInput | SortOrder
    Role?: SortOrder
    Permission?: SortOrder
    Remask?: SortOrderInput | SortOrder
    UsersID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Users?: usersOrderByWithRelationInput
  }

  export type usersRolesWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    AND?: usersRolesWhereInput | usersRolesWhereInput[]
    OR?: usersRolesWhereInput[]
    NOT?: usersRolesWhereInput | usersRolesWhereInput[]
    Titel?: StringNullableFilter<"usersRoles"> | string | null
    Type?: StringNullableFilter<"usersRoles"> | string | null
    Role?: StringFilter<"usersRoles"> | string
    Permission?: StringFilter<"usersRoles"> | string
    Remask?: StringNullableFilter<"usersRoles"> | string | null
    UsersID?: StringNullableFilter<"usersRoles"> | string | null
    Status?: StringNullableFilter<"usersRoles"> | string | null
    IsActive?: BoolFilter<"usersRoles"> | boolean
    CreatedAt?: DateTimeFilter<"usersRoles"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"usersRoles"> | Date | string | null
    Users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "ID" | "ID">

  export type usersRolesOrderByWithAggregationInput = {
    ID?: SortOrder
    Titel?: SortOrderInput | SortOrder
    Type?: SortOrderInput | SortOrder
    Role?: SortOrder
    Permission?: SortOrder
    Remask?: SortOrderInput | SortOrder
    UsersID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: usersRolesCountOrderByAggregateInput
    _max?: usersRolesMaxOrderByAggregateInput
    _min?: usersRolesMinOrderByAggregateInput
  }

  export type usersRolesScalarWhereWithAggregatesInput = {
    AND?: usersRolesScalarWhereWithAggregatesInput | usersRolesScalarWhereWithAggregatesInput[]
    OR?: usersRolesScalarWhereWithAggregatesInput[]
    NOT?: usersRolesScalarWhereWithAggregatesInput | usersRolesScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"usersRoles"> | string
    Titel?: StringNullableWithAggregatesFilter<"usersRoles"> | string | null
    Type?: StringNullableWithAggregatesFilter<"usersRoles"> | string | null
    Role?: StringWithAggregatesFilter<"usersRoles"> | string
    Permission?: StringWithAggregatesFilter<"usersRoles"> | string
    Remask?: StringNullableWithAggregatesFilter<"usersRoles"> | string | null
    UsersID?: StringNullableWithAggregatesFilter<"usersRoles"> | string | null
    Status?: StringNullableWithAggregatesFilter<"usersRoles"> | string | null
    IsActive?: BoolWithAggregatesFilter<"usersRoles"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"usersRoles"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"usersRoles"> | Date | string | null
  }

  export type usersActivitiesWhereInput = {
    AND?: usersActivitiesWhereInput | usersActivitiesWhereInput[]
    OR?: usersActivitiesWhereInput[]
    NOT?: usersActivitiesWhereInput | usersActivitiesWhereInput[]
    ID?: StringFilter<"usersActivities"> | string
    Activity?: StringNullableFilter<"usersActivities"> | string | null
    IP?: StringNullableFilter<"usersActivities"> | string | null
    MacAddress?: StringNullableFilter<"usersActivities"> | string | null
    UDID?: StringNullableFilter<"usersActivities"> | string | null
    Remask?: StringNullableFilter<"usersActivities"> | string | null
    Log?: StringNullableFilter<"usersActivities"> | string | null
    Error?: StringNullableFilter<"usersActivities"> | string | null
    Messages?: StringNullableFilter<"usersActivities"> | string | null
    UsersID?: StringNullableFilter<"usersActivities"> | string | null
    Status?: StringNullableFilter<"usersActivities"> | string | null
    IsActive?: BoolFilter<"usersActivities"> | boolean
    CreatedAt?: DateTimeFilter<"usersActivities"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"usersActivities"> | Date | string | null
    Users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    ThreadingOrder?: XOR<OrderThreadingNullableRelationFilter, orderThreadingWhereInput> | null
  }

  export type usersActivitiesOrderByWithRelationInput = {
    ID?: SortOrder
    Activity?: SortOrderInput | SortOrder
    IP?: SortOrderInput | SortOrder
    MacAddress?: SortOrderInput | SortOrder
    UDID?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    Log?: SortOrderInput | SortOrder
    Error?: SortOrderInput | SortOrder
    Messages?: SortOrderInput | SortOrder
    UsersID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Users?: usersOrderByWithRelationInput
    ThreadingOrder?: orderThreadingOrderByWithRelationInput
  }

  export type usersActivitiesWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    AND?: usersActivitiesWhereInput | usersActivitiesWhereInput[]
    OR?: usersActivitiesWhereInput[]
    NOT?: usersActivitiesWhereInput | usersActivitiesWhereInput[]
    Activity?: StringNullableFilter<"usersActivities"> | string | null
    IP?: StringNullableFilter<"usersActivities"> | string | null
    MacAddress?: StringNullableFilter<"usersActivities"> | string | null
    UDID?: StringNullableFilter<"usersActivities"> | string | null
    Remask?: StringNullableFilter<"usersActivities"> | string | null
    Log?: StringNullableFilter<"usersActivities"> | string | null
    Error?: StringNullableFilter<"usersActivities"> | string | null
    Messages?: StringNullableFilter<"usersActivities"> | string | null
    UsersID?: StringNullableFilter<"usersActivities"> | string | null
    Status?: StringNullableFilter<"usersActivities"> | string | null
    IsActive?: BoolFilter<"usersActivities"> | boolean
    CreatedAt?: DateTimeFilter<"usersActivities"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"usersActivities"> | Date | string | null
    Users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    ThreadingOrder?: XOR<OrderThreadingNullableRelationFilter, orderThreadingWhereInput> | null
  }, "ID" | "ID">

  export type usersActivitiesOrderByWithAggregationInput = {
    ID?: SortOrder
    Activity?: SortOrderInput | SortOrder
    IP?: SortOrderInput | SortOrder
    MacAddress?: SortOrderInput | SortOrder
    UDID?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    Log?: SortOrderInput | SortOrder
    Error?: SortOrderInput | SortOrder
    Messages?: SortOrderInput | SortOrder
    UsersID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: usersActivitiesCountOrderByAggregateInput
    _max?: usersActivitiesMaxOrderByAggregateInput
    _min?: usersActivitiesMinOrderByAggregateInput
  }

  export type usersActivitiesScalarWhereWithAggregatesInput = {
    AND?: usersActivitiesScalarWhereWithAggregatesInput | usersActivitiesScalarWhereWithAggregatesInput[]
    OR?: usersActivitiesScalarWhereWithAggregatesInput[]
    NOT?: usersActivitiesScalarWhereWithAggregatesInput | usersActivitiesScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"usersActivities"> | string
    Activity?: StringNullableWithAggregatesFilter<"usersActivities"> | string | null
    IP?: StringNullableWithAggregatesFilter<"usersActivities"> | string | null
    MacAddress?: StringNullableWithAggregatesFilter<"usersActivities"> | string | null
    UDID?: StringNullableWithAggregatesFilter<"usersActivities"> | string | null
    Remask?: StringNullableWithAggregatesFilter<"usersActivities"> | string | null
    Log?: StringNullableWithAggregatesFilter<"usersActivities"> | string | null
    Error?: StringNullableWithAggregatesFilter<"usersActivities"> | string | null
    Messages?: StringNullableWithAggregatesFilter<"usersActivities"> | string | null
    UsersID?: StringNullableWithAggregatesFilter<"usersActivities"> | string | null
    Status?: StringNullableWithAggregatesFilter<"usersActivities"> | string | null
    IsActive?: BoolWithAggregatesFilter<"usersActivities"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"usersActivities"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"usersActivities"> | Date | string | null
  }

  export type orderTypeWhereInput = {
    AND?: orderTypeWhereInput | orderTypeWhereInput[]
    OR?: orderTypeWhereInput[]
    NOT?: orderTypeWhereInput | orderTypeWhereInput[]
    ID?: StringFilter<"orderType"> | string
    TypeCode?: StringNullableFilter<"orderType"> | string | null
    TypeNmae?: StringNullableFilter<"orderType"> | string | null
    Remask?: StringNullableFilter<"orderType"> | string | null
    Status?: StringNullableFilter<"orderType"> | string | null
    IsActive?: BoolFilter<"orderType"> | boolean
    CreatedAt?: DateTimeFilter<"orderType"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderType"> | Date | string | null
  }

  export type orderTypeOrderByWithRelationInput = {
    ID?: SortOrder
    TypeCode?: SortOrderInput | SortOrder
    TypeNmae?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
  }

  export type orderTypeWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    AND?: orderTypeWhereInput | orderTypeWhereInput[]
    OR?: orderTypeWhereInput[]
    NOT?: orderTypeWhereInput | orderTypeWhereInput[]
    TypeCode?: StringNullableFilter<"orderType"> | string | null
    TypeNmae?: StringNullableFilter<"orderType"> | string | null
    Remask?: StringNullableFilter<"orderType"> | string | null
    Status?: StringNullableFilter<"orderType"> | string | null
    IsActive?: BoolFilter<"orderType"> | boolean
    CreatedAt?: DateTimeFilter<"orderType"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderType"> | Date | string | null
  }, "ID" | "ID">

  export type orderTypeOrderByWithAggregationInput = {
    ID?: SortOrder
    TypeCode?: SortOrderInput | SortOrder
    TypeNmae?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: orderTypeCountOrderByAggregateInput
    _max?: orderTypeMaxOrderByAggregateInput
    _min?: orderTypeMinOrderByAggregateInput
  }

  export type orderTypeScalarWhereWithAggregatesInput = {
    AND?: orderTypeScalarWhereWithAggregatesInput | orderTypeScalarWhereWithAggregatesInput[]
    OR?: orderTypeScalarWhereWithAggregatesInput[]
    NOT?: orderTypeScalarWhereWithAggregatesInput | orderTypeScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"orderType"> | string
    TypeCode?: StringNullableWithAggregatesFilter<"orderType"> | string | null
    TypeNmae?: StringNullableWithAggregatesFilter<"orderType"> | string | null
    Remask?: StringNullableWithAggregatesFilter<"orderType"> | string | null
    Status?: StringNullableWithAggregatesFilter<"orderType"> | string | null
    IsActive?: BoolWithAggregatesFilter<"orderType"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"orderType"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"orderType"> | Date | string | null
  }

  export type orderCategoryWhereInput = {
    AND?: orderCategoryWhereInput | orderCategoryWhereInput[]
    OR?: orderCategoryWhereInput[]
    NOT?: orderCategoryWhereInput | orderCategoryWhereInput[]
    ID?: StringFilter<"orderCategory"> | string
    TypeCode?: StringNullableFilter<"orderCategory"> | string | null
    TypeNmae?: StringNullableFilter<"orderCategory"> | string | null
    Remask?: StringNullableFilter<"orderCategory"> | string | null
    BranchesID?: StringNullableFilter<"orderCategory"> | string | null
    Status?: StringNullableFilter<"orderCategory"> | string | null
    IsActive?: BoolFilter<"orderCategory"> | boolean
    CreatedAt?: DateTimeFilter<"orderCategory"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderCategory"> | Date | string | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
    Order?: OrderListRelationFilter
  }

  export type orderCategoryOrderByWithRelationInput = {
    ID?: SortOrder
    TypeCode?: SortOrderInput | SortOrder
    TypeNmae?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Branches?: branchesOrderByWithRelationInput
    Order?: orderOrderByRelationAggregateInput
  }

  export type orderCategoryWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    AND?: orderCategoryWhereInput | orderCategoryWhereInput[]
    OR?: orderCategoryWhereInput[]
    NOT?: orderCategoryWhereInput | orderCategoryWhereInput[]
    TypeCode?: StringNullableFilter<"orderCategory"> | string | null
    TypeNmae?: StringNullableFilter<"orderCategory"> | string | null
    Remask?: StringNullableFilter<"orderCategory"> | string | null
    BranchesID?: StringNullableFilter<"orderCategory"> | string | null
    Status?: StringNullableFilter<"orderCategory"> | string | null
    IsActive?: BoolFilter<"orderCategory"> | boolean
    CreatedAt?: DateTimeFilter<"orderCategory"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderCategory"> | Date | string | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
    Order?: OrderListRelationFilter
  }, "ID" | "ID">

  export type orderCategoryOrderByWithAggregationInput = {
    ID?: SortOrder
    TypeCode?: SortOrderInput | SortOrder
    TypeNmae?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: orderCategoryCountOrderByAggregateInput
    _max?: orderCategoryMaxOrderByAggregateInput
    _min?: orderCategoryMinOrderByAggregateInput
  }

  export type orderCategoryScalarWhereWithAggregatesInput = {
    AND?: orderCategoryScalarWhereWithAggregatesInput | orderCategoryScalarWhereWithAggregatesInput[]
    OR?: orderCategoryScalarWhereWithAggregatesInput[]
    NOT?: orderCategoryScalarWhereWithAggregatesInput | orderCategoryScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"orderCategory"> | string
    TypeCode?: StringNullableWithAggregatesFilter<"orderCategory"> | string | null
    TypeNmae?: StringNullableWithAggregatesFilter<"orderCategory"> | string | null
    Remask?: StringNullableWithAggregatesFilter<"orderCategory"> | string | null
    BranchesID?: StringNullableWithAggregatesFilter<"orderCategory"> | string | null
    Status?: StringNullableWithAggregatesFilter<"orderCategory"> | string | null
    IsActive?: BoolWithAggregatesFilter<"orderCategory"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"orderCategory"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"orderCategory"> | Date | string | null
  }

  export type orderWhereInput = {
    AND?: orderWhereInput | orderWhereInput[]
    OR?: orderWhereInput[]
    NOT?: orderWhereInput | orderWhereInput[]
    ID?: StringFilter<"order"> | string
    Code?: StringNullableFilter<"order"> | string | null
    PrimaryCode?: StringNullableFilter<"order"> | string | null
    SecondaryCode?: StringNullableFilter<"order"> | string | null
    OrderDate?: DateTimeNullableFilter<"order"> | Date | string | null
    Name?: StringNullableFilter<"order"> | string | null
    UplaodURL?: StringNullableFilter<"order"> | string | null
    CategoryID?: StringNullableFilter<"order"> | string | null
    BranchesID?: StringNullableFilter<"order"> | string | null
    CreateByID?: StringNullableFilter<"order"> | string | null
    Remask?: StringNullableFilter<"order"> | string | null
    Status?: StringNullableFilter<"order"> | string | null
    IsActive?: BoolFilter<"order"> | boolean
    CreatedAt?: DateTimeFilter<"order"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"order"> | Date | string | null
    Category?: XOR<OrderCategoryNullableRelationFilter, orderCategoryWhereInput> | null
    Personal?: XOR<OrderPersonalNullableRelationFilter, orderPersonalWhereInput> | null
    Details?: XOR<OrderDetailsNullableRelationFilter, orderDetailsWhereInput> | null
    Payment?: XOR<OrderPaymentNullableRelationFilter, orderPaymentWhereInput> | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
    CreateBy?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    Tacking?: OrderTackingListRelationFilter
    Threading?: OrderThreadingListRelationFilter
  }

  export type orderOrderByWithRelationInput = {
    ID?: SortOrder
    Code?: SortOrderInput | SortOrder
    PrimaryCode?: SortOrderInput | SortOrder
    SecondaryCode?: SortOrderInput | SortOrder
    OrderDate?: SortOrderInput | SortOrder
    Name?: SortOrderInput | SortOrder
    UplaodURL?: SortOrderInput | SortOrder
    CategoryID?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    CreateByID?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Category?: orderCategoryOrderByWithRelationInput
    Personal?: orderPersonalOrderByWithRelationInput
    Details?: orderDetailsOrderByWithRelationInput
    Payment?: orderPaymentOrderByWithRelationInput
    Branches?: branchesOrderByWithRelationInput
    CreateBy?: usersOrderByWithRelationInput
    Tacking?: orderTackingOrderByRelationAggregateInput
    Threading?: orderThreadingOrderByRelationAggregateInput
  }

  export type orderWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    BranchesID?: string
    CreateByID?: string
    AND?: orderWhereInput | orderWhereInput[]
    OR?: orderWhereInput[]
    NOT?: orderWhereInput | orderWhereInput[]
    Code?: StringNullableFilter<"order"> | string | null
    PrimaryCode?: StringNullableFilter<"order"> | string | null
    SecondaryCode?: StringNullableFilter<"order"> | string | null
    OrderDate?: DateTimeNullableFilter<"order"> | Date | string | null
    Name?: StringNullableFilter<"order"> | string | null
    UplaodURL?: StringNullableFilter<"order"> | string | null
    CategoryID?: StringNullableFilter<"order"> | string | null
    Remask?: StringNullableFilter<"order"> | string | null
    Status?: StringNullableFilter<"order"> | string | null
    IsActive?: BoolFilter<"order"> | boolean
    CreatedAt?: DateTimeFilter<"order"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"order"> | Date | string | null
    Category?: XOR<OrderCategoryNullableRelationFilter, orderCategoryWhereInput> | null
    Personal?: XOR<OrderPersonalNullableRelationFilter, orderPersonalWhereInput> | null
    Details?: XOR<OrderDetailsNullableRelationFilter, orderDetailsWhereInput> | null
    Payment?: XOR<OrderPaymentNullableRelationFilter, orderPaymentWhereInput> | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
    CreateBy?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    Tacking?: OrderTackingListRelationFilter
    Threading?: OrderThreadingListRelationFilter
  }, "ID" | "ID" | "BranchesID" | "CreateByID">

  export type orderOrderByWithAggregationInput = {
    ID?: SortOrder
    Code?: SortOrderInput | SortOrder
    PrimaryCode?: SortOrderInput | SortOrder
    SecondaryCode?: SortOrderInput | SortOrder
    OrderDate?: SortOrderInput | SortOrder
    Name?: SortOrderInput | SortOrder
    UplaodURL?: SortOrderInput | SortOrder
    CategoryID?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    CreateByID?: SortOrderInput | SortOrder
    Remask?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: orderCountOrderByAggregateInput
    _max?: orderMaxOrderByAggregateInput
    _min?: orderMinOrderByAggregateInput
  }

  export type orderScalarWhereWithAggregatesInput = {
    AND?: orderScalarWhereWithAggregatesInput | orderScalarWhereWithAggregatesInput[]
    OR?: orderScalarWhereWithAggregatesInput[]
    NOT?: orderScalarWhereWithAggregatesInput | orderScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"order"> | string
    Code?: StringNullableWithAggregatesFilter<"order"> | string | null
    PrimaryCode?: StringNullableWithAggregatesFilter<"order"> | string | null
    SecondaryCode?: StringNullableWithAggregatesFilter<"order"> | string | null
    OrderDate?: DateTimeNullableWithAggregatesFilter<"order"> | Date | string | null
    Name?: StringNullableWithAggregatesFilter<"order"> | string | null
    UplaodURL?: StringNullableWithAggregatesFilter<"order"> | string | null
    CategoryID?: StringNullableWithAggregatesFilter<"order"> | string | null
    BranchesID?: StringNullableWithAggregatesFilter<"order"> | string | null
    CreateByID?: StringNullableWithAggregatesFilter<"order"> | string | null
    Remask?: StringNullableWithAggregatesFilter<"order"> | string | null
    Status?: StringNullableWithAggregatesFilter<"order"> | string | null
    IsActive?: BoolWithAggregatesFilter<"order"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"order"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"order"> | Date | string | null
  }

  export type orderThreadingWhereInput = {
    AND?: orderThreadingWhereInput | orderThreadingWhereInput[]
    OR?: orderThreadingWhereInput[]
    NOT?: orderThreadingWhereInput | orderThreadingWhereInput[]
    ID?: StringFilter<"orderThreading"> | string
    Tasks?: StringNullableFilter<"orderThreading"> | string | null
    ActivitieID?: StringNullableFilter<"orderThreading"> | string | null
    OrderID?: StringNullableFilter<"orderThreading"> | string | null
    Status?: StringNullableFilter<"orderThreading"> | string | null
    IsActive?: BoolFilter<"orderThreading"> | boolean
    CreatedAt?: DateTimeFilter<"orderThreading"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderThreading"> | Date | string | null
    Activitie?: XOR<UsersActivitiesNullableRelationFilter, usersActivitiesWhereInput> | null
    Order?: XOR<OrderNullableRelationFilter, orderWhereInput> | null
  }

  export type orderThreadingOrderByWithRelationInput = {
    ID?: SortOrder
    Tasks?: SortOrderInput | SortOrder
    ActivitieID?: SortOrderInput | SortOrder
    OrderID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Activitie?: usersActivitiesOrderByWithRelationInput
    Order?: orderOrderByWithRelationInput
  }

  export type orderThreadingWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    ActivitieID?: string
    AND?: orderThreadingWhereInput | orderThreadingWhereInput[]
    OR?: orderThreadingWhereInput[]
    NOT?: orderThreadingWhereInput | orderThreadingWhereInput[]
    Tasks?: StringNullableFilter<"orderThreading"> | string | null
    OrderID?: StringNullableFilter<"orderThreading"> | string | null
    Status?: StringNullableFilter<"orderThreading"> | string | null
    IsActive?: BoolFilter<"orderThreading"> | boolean
    CreatedAt?: DateTimeFilter<"orderThreading"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderThreading"> | Date | string | null
    Activitie?: XOR<UsersActivitiesNullableRelationFilter, usersActivitiesWhereInput> | null
    Order?: XOR<OrderNullableRelationFilter, orderWhereInput> | null
  }, "ID" | "ID" | "ActivitieID">

  export type orderThreadingOrderByWithAggregationInput = {
    ID?: SortOrder
    Tasks?: SortOrderInput | SortOrder
    ActivitieID?: SortOrderInput | SortOrder
    OrderID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: orderThreadingCountOrderByAggregateInput
    _max?: orderThreadingMaxOrderByAggregateInput
    _min?: orderThreadingMinOrderByAggregateInput
  }

  export type orderThreadingScalarWhereWithAggregatesInput = {
    AND?: orderThreadingScalarWhereWithAggregatesInput | orderThreadingScalarWhereWithAggregatesInput[]
    OR?: orderThreadingScalarWhereWithAggregatesInput[]
    NOT?: orderThreadingScalarWhereWithAggregatesInput | orderThreadingScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"orderThreading"> | string
    Tasks?: StringNullableWithAggregatesFilter<"orderThreading"> | string | null
    ActivitieID?: StringNullableWithAggregatesFilter<"orderThreading"> | string | null
    OrderID?: StringNullableWithAggregatesFilter<"orderThreading"> | string | null
    Status?: StringNullableWithAggregatesFilter<"orderThreading"> | string | null
    IsActive?: BoolWithAggregatesFilter<"orderThreading"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"orderThreading"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"orderThreading"> | Date | string | null
  }

  export type orderPersonalWhereInput = {
    AND?: orderPersonalWhereInput | orderPersonalWhereInput[]
    OR?: orderPersonalWhereInput[]
    NOT?: orderPersonalWhereInput | orderPersonalWhereInput[]
    ID?: StringFilter<"orderPersonal"> | string
    SenderName?: StringNullableFilter<"orderPersonal"> | string | null
    SenderPhoneNumber?: StringNullableFilter<"orderPersonal"> | string | null
    SenderUserID?: StringNullableFilter<"orderPersonal"> | string | null
    RecipientName?: StringNullableFilter<"orderPersonal"> | string | null
    RecipientPhoneNumber?: StringNullableFilter<"orderPersonal"> | string | null
    RecipientID?: StringNullableFilter<"orderPersonal"> | string | null
    OrderID?: StringNullableFilter<"orderPersonal"> | string | null
    Status?: StringNullableFilter<"orderPersonal"> | string | null
    IsActive?: BoolFilter<"orderPersonal"> | boolean
    CreatedAt?: DateTimeFilter<"orderPersonal"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderPersonal"> | Date | string | null
    SenderUser?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    RecipientUser?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    Order?: XOR<OrderNullableRelationFilter, orderWhereInput> | null
  }

  export type orderPersonalOrderByWithRelationInput = {
    ID?: SortOrder
    SenderName?: SortOrderInput | SortOrder
    SenderPhoneNumber?: SortOrderInput | SortOrder
    SenderUserID?: SortOrderInput | SortOrder
    RecipientName?: SortOrderInput | SortOrder
    RecipientPhoneNumber?: SortOrderInput | SortOrder
    RecipientID?: SortOrderInput | SortOrder
    OrderID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    SenderUser?: usersOrderByWithRelationInput
    RecipientUser?: usersOrderByWithRelationInput
    Order?: orderOrderByWithRelationInput
  }

  export type orderPersonalWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    SenderUserID?: string
    RecipientID?: string
    OrderID?: string
    AND?: orderPersonalWhereInput | orderPersonalWhereInput[]
    OR?: orderPersonalWhereInput[]
    NOT?: orderPersonalWhereInput | orderPersonalWhereInput[]
    SenderName?: StringNullableFilter<"orderPersonal"> | string | null
    SenderPhoneNumber?: StringNullableFilter<"orderPersonal"> | string | null
    RecipientName?: StringNullableFilter<"orderPersonal"> | string | null
    RecipientPhoneNumber?: StringNullableFilter<"orderPersonal"> | string | null
    Status?: StringNullableFilter<"orderPersonal"> | string | null
    IsActive?: BoolFilter<"orderPersonal"> | boolean
    CreatedAt?: DateTimeFilter<"orderPersonal"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderPersonal"> | Date | string | null
    SenderUser?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    RecipientUser?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    Order?: XOR<OrderNullableRelationFilter, orderWhereInput> | null
  }, "ID" | "ID" | "SenderUserID" | "RecipientID" | "OrderID">

  export type orderPersonalOrderByWithAggregationInput = {
    ID?: SortOrder
    SenderName?: SortOrderInput | SortOrder
    SenderPhoneNumber?: SortOrderInput | SortOrder
    SenderUserID?: SortOrderInput | SortOrder
    RecipientName?: SortOrderInput | SortOrder
    RecipientPhoneNumber?: SortOrderInput | SortOrder
    RecipientID?: SortOrderInput | SortOrder
    OrderID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: orderPersonalCountOrderByAggregateInput
    _max?: orderPersonalMaxOrderByAggregateInput
    _min?: orderPersonalMinOrderByAggregateInput
  }

  export type orderPersonalScalarWhereWithAggregatesInput = {
    AND?: orderPersonalScalarWhereWithAggregatesInput | orderPersonalScalarWhereWithAggregatesInput[]
    OR?: orderPersonalScalarWhereWithAggregatesInput[]
    NOT?: orderPersonalScalarWhereWithAggregatesInput | orderPersonalScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"orderPersonal"> | string
    SenderName?: StringNullableWithAggregatesFilter<"orderPersonal"> | string | null
    SenderPhoneNumber?: StringNullableWithAggregatesFilter<"orderPersonal"> | string | null
    SenderUserID?: StringNullableWithAggregatesFilter<"orderPersonal"> | string | null
    RecipientName?: StringNullableWithAggregatesFilter<"orderPersonal"> | string | null
    RecipientPhoneNumber?: StringNullableWithAggregatesFilter<"orderPersonal"> | string | null
    RecipientID?: StringNullableWithAggregatesFilter<"orderPersonal"> | string | null
    OrderID?: StringNullableWithAggregatesFilter<"orderPersonal"> | string | null
    Status?: StringNullableWithAggregatesFilter<"orderPersonal"> | string | null
    IsActive?: BoolWithAggregatesFilter<"orderPersonal"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"orderPersonal"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"orderPersonal"> | Date | string | null
  }

  export type orderPaymentWhereInput = {
    AND?: orderPaymentWhereInput | orderPaymentWhereInput[]
    OR?: orderPaymentWhereInput[]
    NOT?: orderPaymentWhereInput | orderPaymentWhereInput[]
    ID?: StringFilter<"orderPayment"> | string
    PaymentStatus?: StringNullableFilter<"orderPayment"> | string | null
    AmountDeliver?: FloatNullableFilter<"orderPayment"> | number | null
    IsPaid?: BoolFilter<"orderPayment"> | boolean
    OrderID?: StringNullableFilter<"orderPayment"> | string | null
    PaidToID?: StringNullableFilter<"orderPayment"> | string | null
    Status?: StringNullableFilter<"orderPayment"> | string | null
    IsActive?: BoolFilter<"orderPayment"> | boolean
    CreatedAt?: DateTimeFilter<"orderPayment"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderPayment"> | Date | string | null
    Order?: XOR<OrderNullableRelationFilter, orderWhereInput> | null
    PaidTo?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    Transaction?: XOR<TransactionNullableRelationFilter, transactionWhereInput> | null
  }

  export type orderPaymentOrderByWithRelationInput = {
    ID?: SortOrder
    PaymentStatus?: SortOrderInput | SortOrder
    AmountDeliver?: SortOrderInput | SortOrder
    IsPaid?: SortOrder
    OrderID?: SortOrderInput | SortOrder
    PaidToID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Order?: orderOrderByWithRelationInput
    PaidTo?: usersOrderByWithRelationInput
    Transaction?: transactionOrderByWithRelationInput
  }

  export type orderPaymentWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    OrderID?: string
    AND?: orderPaymentWhereInput | orderPaymentWhereInput[]
    OR?: orderPaymentWhereInput[]
    NOT?: orderPaymentWhereInput | orderPaymentWhereInput[]
    PaymentStatus?: StringNullableFilter<"orderPayment"> | string | null
    AmountDeliver?: FloatNullableFilter<"orderPayment"> | number | null
    IsPaid?: BoolFilter<"orderPayment"> | boolean
    PaidToID?: StringNullableFilter<"orderPayment"> | string | null
    Status?: StringNullableFilter<"orderPayment"> | string | null
    IsActive?: BoolFilter<"orderPayment"> | boolean
    CreatedAt?: DateTimeFilter<"orderPayment"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderPayment"> | Date | string | null
    Order?: XOR<OrderNullableRelationFilter, orderWhereInput> | null
    PaidTo?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    Transaction?: XOR<TransactionNullableRelationFilter, transactionWhereInput> | null
  }, "ID" | "ID" | "OrderID">

  export type orderPaymentOrderByWithAggregationInput = {
    ID?: SortOrder
    PaymentStatus?: SortOrderInput | SortOrder
    AmountDeliver?: SortOrderInput | SortOrder
    IsPaid?: SortOrder
    OrderID?: SortOrderInput | SortOrder
    PaidToID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: orderPaymentCountOrderByAggregateInput
    _avg?: orderPaymentAvgOrderByAggregateInput
    _max?: orderPaymentMaxOrderByAggregateInput
    _min?: orderPaymentMinOrderByAggregateInput
    _sum?: orderPaymentSumOrderByAggregateInput
  }

  export type orderPaymentScalarWhereWithAggregatesInput = {
    AND?: orderPaymentScalarWhereWithAggregatesInput | orderPaymentScalarWhereWithAggregatesInput[]
    OR?: orderPaymentScalarWhereWithAggregatesInput[]
    NOT?: orderPaymentScalarWhereWithAggregatesInput | orderPaymentScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"orderPayment"> | string
    PaymentStatus?: StringNullableWithAggregatesFilter<"orderPayment"> | string | null
    AmountDeliver?: FloatNullableWithAggregatesFilter<"orderPayment"> | number | null
    IsPaid?: BoolWithAggregatesFilter<"orderPayment"> | boolean
    OrderID?: StringNullableWithAggregatesFilter<"orderPayment"> | string | null
    PaidToID?: StringNullableWithAggregatesFilter<"orderPayment"> | string | null
    Status?: StringNullableWithAggregatesFilter<"orderPayment"> | string | null
    IsActive?: BoolWithAggregatesFilter<"orderPayment"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"orderPayment"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"orderPayment"> | Date | string | null
  }

  export type orderDetailsWhereInput = {
    AND?: orderDetailsWhereInput | orderDetailsWhereInput[]
    OR?: orderDetailsWhereInput[]
    NOT?: orderDetailsWhereInput | orderDetailsWhereInput[]
    ID?: StringFilter<"orderDetails"> | string
    Detail?: StringNullableFilter<"orderDetails"> | string | null
    AmountX?: FloatNullableFilter<"orderDetails"> | number | null
    AmountY?: FloatNullableFilter<"orderDetails"> | number | null
    AmountH?: FloatNullableFilter<"orderDetails"> | number | null
    AmountW?: FloatNullableFilter<"orderDetails"> | number | null
    Amount?: FloatNullableFilter<"orderDetails"> | number | null
    OrderID?: StringNullableFilter<"orderDetails"> | string | null
    Status?: StringNullableFilter<"orderDetails"> | string | null
    IsActive?: BoolFilter<"orderDetails"> | boolean
    CreatedAt?: DateTimeFilter<"orderDetails"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderDetails"> | Date | string | null
    Order?: XOR<OrderNullableRelationFilter, orderWhereInput> | null
  }

  export type orderDetailsOrderByWithRelationInput = {
    ID?: SortOrder
    Detail?: SortOrderInput | SortOrder
    AmountX?: SortOrderInput | SortOrder
    AmountY?: SortOrderInput | SortOrder
    AmountH?: SortOrderInput | SortOrder
    AmountW?: SortOrderInput | SortOrder
    Amount?: SortOrderInput | SortOrder
    OrderID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Order?: orderOrderByWithRelationInput
  }

  export type orderDetailsWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    OrderID?: string
    AND?: orderDetailsWhereInput | orderDetailsWhereInput[]
    OR?: orderDetailsWhereInput[]
    NOT?: orderDetailsWhereInput | orderDetailsWhereInput[]
    Detail?: StringNullableFilter<"orderDetails"> | string | null
    AmountX?: FloatNullableFilter<"orderDetails"> | number | null
    AmountY?: FloatNullableFilter<"orderDetails"> | number | null
    AmountH?: FloatNullableFilter<"orderDetails"> | number | null
    AmountW?: FloatNullableFilter<"orderDetails"> | number | null
    Amount?: FloatNullableFilter<"orderDetails"> | number | null
    Status?: StringNullableFilter<"orderDetails"> | string | null
    IsActive?: BoolFilter<"orderDetails"> | boolean
    CreatedAt?: DateTimeFilter<"orderDetails"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderDetails"> | Date | string | null
    Order?: XOR<OrderNullableRelationFilter, orderWhereInput> | null
  }, "ID" | "ID" | "OrderID">

  export type orderDetailsOrderByWithAggregationInput = {
    ID?: SortOrder
    Detail?: SortOrderInput | SortOrder
    AmountX?: SortOrderInput | SortOrder
    AmountY?: SortOrderInput | SortOrder
    AmountH?: SortOrderInput | SortOrder
    AmountW?: SortOrderInput | SortOrder
    Amount?: SortOrderInput | SortOrder
    OrderID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: orderDetailsCountOrderByAggregateInput
    _avg?: orderDetailsAvgOrderByAggregateInput
    _max?: orderDetailsMaxOrderByAggregateInput
    _min?: orderDetailsMinOrderByAggregateInput
    _sum?: orderDetailsSumOrderByAggregateInput
  }

  export type orderDetailsScalarWhereWithAggregatesInput = {
    AND?: orderDetailsScalarWhereWithAggregatesInput | orderDetailsScalarWhereWithAggregatesInput[]
    OR?: orderDetailsScalarWhereWithAggregatesInput[]
    NOT?: orderDetailsScalarWhereWithAggregatesInput | orderDetailsScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"orderDetails"> | string
    Detail?: StringNullableWithAggregatesFilter<"orderDetails"> | string | null
    AmountX?: FloatNullableWithAggregatesFilter<"orderDetails"> | number | null
    AmountY?: FloatNullableWithAggregatesFilter<"orderDetails"> | number | null
    AmountH?: FloatNullableWithAggregatesFilter<"orderDetails"> | number | null
    AmountW?: FloatNullableWithAggregatesFilter<"orderDetails"> | number | null
    Amount?: FloatNullableWithAggregatesFilter<"orderDetails"> | number | null
    OrderID?: StringNullableWithAggregatesFilter<"orderDetails"> | string | null
    Status?: StringNullableWithAggregatesFilter<"orderDetails"> | string | null
    IsActive?: BoolWithAggregatesFilter<"orderDetails"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"orderDetails"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"orderDetails"> | Date | string | null
  }

  export type tackingStatusWhereInput = {
    AND?: tackingStatusWhereInput | tackingStatusWhereInput[]
    OR?: tackingStatusWhereInput[]
    NOT?: tackingStatusWhereInput | tackingStatusWhereInput[]
    ID?: StringFilter<"tackingStatus"> | string
    Status?: StringNullableFilter<"tackingStatus"> | string | null
    Description?: StringNullableFilter<"tackingStatus"> | string | null
    IsActive?: BoolFilter<"tackingStatus"> | boolean
    CreatedAt?: DateTimeFilter<"tackingStatus"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"tackingStatus"> | Date | string | null
    Tracking?: OrderTackingListRelationFilter
  }

  export type tackingStatusOrderByWithRelationInput = {
    ID?: SortOrder
    Status?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Tracking?: orderTackingOrderByRelationAggregateInput
  }

  export type tackingStatusWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    AND?: tackingStatusWhereInput | tackingStatusWhereInput[]
    OR?: tackingStatusWhereInput[]
    NOT?: tackingStatusWhereInput | tackingStatusWhereInput[]
    Status?: StringNullableFilter<"tackingStatus"> | string | null
    Description?: StringNullableFilter<"tackingStatus"> | string | null
    IsActive?: BoolFilter<"tackingStatus"> | boolean
    CreatedAt?: DateTimeFilter<"tackingStatus"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"tackingStatus"> | Date | string | null
    Tracking?: OrderTackingListRelationFilter
  }, "ID" | "ID">

  export type tackingStatusOrderByWithAggregationInput = {
    ID?: SortOrder
    Status?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: tackingStatusCountOrderByAggregateInput
    _max?: tackingStatusMaxOrderByAggregateInput
    _min?: tackingStatusMinOrderByAggregateInput
  }

  export type tackingStatusScalarWhereWithAggregatesInput = {
    AND?: tackingStatusScalarWhereWithAggregatesInput | tackingStatusScalarWhereWithAggregatesInput[]
    OR?: tackingStatusScalarWhereWithAggregatesInput[]
    NOT?: tackingStatusScalarWhereWithAggregatesInput | tackingStatusScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"tackingStatus"> | string
    Status?: StringNullableWithAggregatesFilter<"tackingStatus"> | string | null
    Description?: StringNullableWithAggregatesFilter<"tackingStatus"> | string | null
    IsActive?: BoolWithAggregatesFilter<"tackingStatus"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"tackingStatus"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"tackingStatus"> | Date | string | null
  }

  export type orderTackingWhereInput = {
    AND?: orderTackingWhereInput | orderTackingWhereInput[]
    OR?: orderTackingWhereInput[]
    NOT?: orderTackingWhereInput | orderTackingWhereInput[]
    ID?: StringFilter<"orderTacking"> | string
    Number?: StringNullableFilter<"orderTacking"> | string | null
    PrimaryPhoneNumber?: StringNullableFilter<"orderTacking"> | string | null
    SecondaryName?: StringNullableFilter<"orderTacking"> | string | null
    SecondaryPhoneNumber?: StringNullableFilter<"orderTacking"> | string | null
    OrderID?: StringNullableFilter<"orderTacking"> | string | null
    BranchesID?: StringNullableFilter<"orderTacking"> | string | null
    TrackingStatusID?: StringNullableFilter<"orderTacking"> | string | null
    Status?: StringNullableFilter<"orderTacking"> | string | null
    IsActive?: BoolFilter<"orderTacking"> | boolean
    CreatedAt?: DateTimeFilter<"orderTacking"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderTacking"> | Date | string | null
    Order?: XOR<OrderNullableRelationFilter, orderWhereInput> | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
    TrackingStatus?: XOR<TackingStatusNullableRelationFilter, tackingStatusWhereInput> | null
  }

  export type orderTackingOrderByWithRelationInput = {
    ID?: SortOrder
    Number?: SortOrderInput | SortOrder
    PrimaryPhoneNumber?: SortOrderInput | SortOrder
    SecondaryName?: SortOrderInput | SortOrder
    SecondaryPhoneNumber?: SortOrderInput | SortOrder
    OrderID?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    TrackingStatusID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    Order?: orderOrderByWithRelationInput
    Branches?: branchesOrderByWithRelationInput
    TrackingStatus?: tackingStatusOrderByWithRelationInput
  }

  export type orderTackingWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    BranchesID?: string
    TrackingStatusID?: string
    AND?: orderTackingWhereInput | orderTackingWhereInput[]
    OR?: orderTackingWhereInput[]
    NOT?: orderTackingWhereInput | orderTackingWhereInput[]
    Number?: StringNullableFilter<"orderTacking"> | string | null
    PrimaryPhoneNumber?: StringNullableFilter<"orderTacking"> | string | null
    SecondaryName?: StringNullableFilter<"orderTacking"> | string | null
    SecondaryPhoneNumber?: StringNullableFilter<"orderTacking"> | string | null
    OrderID?: StringNullableFilter<"orderTacking"> | string | null
    Status?: StringNullableFilter<"orderTacking"> | string | null
    IsActive?: BoolFilter<"orderTacking"> | boolean
    CreatedAt?: DateTimeFilter<"orderTacking"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderTacking"> | Date | string | null
    Order?: XOR<OrderNullableRelationFilter, orderWhereInput> | null
    Branches?: XOR<BranchesNullableRelationFilter, branchesWhereInput> | null
    TrackingStatus?: XOR<TackingStatusNullableRelationFilter, tackingStatusWhereInput> | null
  }, "ID" | "ID" | "BranchesID" | "TrackingStatusID">

  export type orderTackingOrderByWithAggregationInput = {
    ID?: SortOrder
    Number?: SortOrderInput | SortOrder
    PrimaryPhoneNumber?: SortOrderInput | SortOrder
    SecondaryName?: SortOrderInput | SortOrder
    SecondaryPhoneNumber?: SortOrderInput | SortOrder
    OrderID?: SortOrderInput | SortOrder
    BranchesID?: SortOrderInput | SortOrder
    TrackingStatusID?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: orderTackingCountOrderByAggregateInput
    _max?: orderTackingMaxOrderByAggregateInput
    _min?: orderTackingMinOrderByAggregateInput
  }

  export type orderTackingScalarWhereWithAggregatesInput = {
    AND?: orderTackingScalarWhereWithAggregatesInput | orderTackingScalarWhereWithAggregatesInput[]
    OR?: orderTackingScalarWhereWithAggregatesInput[]
    NOT?: orderTackingScalarWhereWithAggregatesInput | orderTackingScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"orderTacking"> | string
    Number?: StringNullableWithAggregatesFilter<"orderTacking"> | string | null
    PrimaryPhoneNumber?: StringNullableWithAggregatesFilter<"orderTacking"> | string | null
    SecondaryName?: StringNullableWithAggregatesFilter<"orderTacking"> | string | null
    SecondaryPhoneNumber?: StringNullableWithAggregatesFilter<"orderTacking"> | string | null
    OrderID?: StringNullableWithAggregatesFilter<"orderTacking"> | string | null
    BranchesID?: StringNullableWithAggregatesFilter<"orderTacking"> | string | null
    TrackingStatusID?: StringNullableWithAggregatesFilter<"orderTacking"> | string | null
    Status?: StringNullableWithAggregatesFilter<"orderTacking"> | string | null
    IsActive?: BoolWithAggregatesFilter<"orderTacking"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"orderTacking"> | Date | string
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"orderTacking"> | Date | string | null
  }

  export type provinceCreateInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
    District?: districtCreateNestedManyWithoutProvinceInput
    Village?: villageCreateNestedManyWithoutProvinceInput
    Address?: addressCreateNestedManyWithoutProvinceInput
  }

  export type provinceUncheckedCreateInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
    District?: districtUncheckedCreateNestedManyWithoutProvinceInput
    Village?: villageUncheckedCreateNestedManyWithoutProvinceInput
    Address?: addressUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type provinceUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    District?: districtUpdateManyWithoutProvinceNestedInput
    Village?: villageUpdateManyWithoutProvinceNestedInput
    Address?: addressUpdateManyWithoutProvinceNestedInput
  }

  export type provinceUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    District?: districtUncheckedUpdateManyWithoutProvinceNestedInput
    Village?: villageUncheckedUpdateManyWithoutProvinceNestedInput
    Address?: addressUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type provinceCreateManyInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type provinceUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type provinceUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type districtCreateInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Province?: provinceCreateNestedOneWithoutDistrictInput
    Address?: addressCreateNestedManyWithoutDistrictInput
    Village?: villageCreateNestedManyWithoutDistrictInput
  }

  export type districtUncheckedCreateInput = {
    ID?: string
    Name: string
    ProvinceID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressUncheckedCreateNestedManyWithoutDistrictInput
    Village?: villageUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type districtUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Province?: provinceUpdateOneWithoutDistrictNestedInput
    Address?: addressUpdateManyWithoutDistrictNestedInput
    Village?: villageUpdateManyWithoutDistrictNestedInput
  }

  export type districtUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    ProvinceID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUncheckedUpdateManyWithoutDistrictNestedInput
    Village?: villageUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type districtCreateManyInput = {
    ID?: string
    Name: string
    ProvinceID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type districtUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type districtUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    ProvinceID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type villageCreateInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Province?: provinceCreateNestedOneWithoutVillageInput
    District?: districtCreateNestedOneWithoutVillageInput
  }

  export type villageUncheckedCreateInput = {
    ID?: string
    Name: string
    ProvinceID?: string | null
    DistrictID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type villageUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Province?: provinceUpdateOneWithoutVillageNestedInput
    District?: districtUpdateOneWithoutVillageNestedInput
  }

  export type villageUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    ProvinceID?: NullableStringFieldUpdateOperationsInput | string | null
    DistrictID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type villageCreateManyInput = {
    ID?: string
    Name: string
    ProvinceID?: string | null
    DistrictID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type villageUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type villageUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    ProvinceID?: NullableStringFieldUpdateOperationsInput | string | null
    DistrictID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type addressCreateInput = {
    ID?: string
    Address: string
    IsDefault?: boolean | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Province?: provinceCreateNestedOneWithoutAddressInput
    District?: districtCreateNestedOneWithoutAddressInput
    Profile?: profileCreateNestedOneWithoutAddressInput
    Branches?: branchesCreateNestedOneWithoutAddressInput
  }

  export type addressUncheckedCreateInput = {
    ID?: string
    Address: string
    ProvinceID?: string | null
    DistrictID?: string | null
    ProfileID?: string | null
    BranchesID?: string | null
    IsDefault?: boolean | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type addressUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    IsDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Province?: provinceUpdateOneWithoutAddressNestedInput
    District?: districtUpdateOneWithoutAddressNestedInput
    Profile?: profileUpdateOneWithoutAddressNestedInput
    Branches?: branchesUpdateOneWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    ProvinceID?: NullableStringFieldUpdateOperationsInput | string | null
    DistrictID?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type addressCreateManyInput = {
    ID?: string
    Address: string
    ProvinceID?: string | null
    DistrictID?: string | null
    ProfileID?: string | null
    BranchesID?: string | null
    IsDefault?: boolean | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type addressUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    IsDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type addressUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    ProvinceID?: NullableStringFieldUpdateOperationsInput | string | null
    DistrictID?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type branchesCreateInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressCreateNestedOneWithoutBranchesInput
    User?: usersCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyCreateNestedManyWithoutBranchesInput
    BranchesSettings?: branchesSettingsCreateNestedManyWithoutBranchesInput
    Otp?: otpCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryCreateNestedManyWithoutBranchesInput
    Order?: orderCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressUncheckedCreateNestedOneWithoutBranchesInput
    User?: usersUncheckedCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyUncheckedCreateNestedManyWithoutBranchesInput
    BranchesSettings?: branchesSettingsUncheckedCreateNestedManyWithoutBranchesInput
    Otp?: otpUncheckedCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryUncheckedCreateNestedManyWithoutBranchesInput
    Order?: orderUncheckedCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUpdateOneWithoutBranchesNestedInput
    User?: usersUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUpdateManyWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUpdateManyWithoutBranchesNestedInput
    Otp?: otpUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUpdateManyWithoutBranchesNestedInput
    Order?: orderUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUncheckedUpdateOneWithoutBranchesNestedInput
    User?: usersUncheckedUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUncheckedUpdateManyWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUncheckedUpdateManyWithoutBranchesNestedInput
    Otp?: otpUncheckedUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUncheckedUpdateManyWithoutBranchesNestedInput
    Order?: orderUncheckedUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type branchesCreateManyInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type branchesUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type branchesUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type branchesKeyCreateInput = {
    ID?: string
    Key: string
    Secret: string
    Remask?: string | null
    Status: string
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutBranchesKeyInput
  }

  export type branchesKeyUncheckedCreateInput = {
    ID?: string
    Key: string
    Secret: string
    Remask?: string | null
    BranchesID?: string | null
    Status: string
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type branchesKeyUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Key?: StringFieldUpdateOperationsInput | string
    Secret?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutBranchesKeyNestedInput
  }

  export type branchesKeyUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Key?: StringFieldUpdateOperationsInput | string
    Secret?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type branchesKeyCreateManyInput = {
    ID?: string
    Key: string
    Secret: string
    Remask?: string | null
    BranchesID?: string | null
    Status: string
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type branchesKeyUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Key?: StringFieldUpdateOperationsInput | string
    Secret?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type branchesKeyUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Key?: StringFieldUpdateOperationsInput | string
    Secret?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type branchesSettingsCreateInput = {
    ID?: string
    Titel: string
    Setting: string
    Remask?: string | null
    Status: string
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutBranchesSettingsInput
  }

  export type branchesSettingsUncheckedCreateInput = {
    ID?: string
    Titel: string
    Setting: string
    Remask?: string | null
    BranchesID?: string | null
    Status: string
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type branchesSettingsUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: StringFieldUpdateOperationsInput | string
    Setting?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutBranchesSettingsNestedInput
  }

  export type branchesSettingsUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: StringFieldUpdateOperationsInput | string
    Setting?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type branchesSettingsCreateManyInput = {
    ID?: string
    Titel: string
    Setting: string
    Remask?: string | null
    BranchesID?: string | null
    Status: string
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type branchesSettingsUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: StringFieldUpdateOperationsInput | string
    Setting?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type branchesSettingsUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: StringFieldUpdateOperationsInput | string
    Setting?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type walletCreateInput = {
    ID?: string
    Balance?: number | null
    Title?: string | null
    Description?: string | null
    IsReal?: boolean | null
    Status?: string | null
    Remask?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    User?: usersCreateNestedOneWithoutWalletInput
    Receive?: transactionCreateNestedManyWithoutPaidToInput
    Payment?: transactionCreateNestedManyWithoutPaidByInput
  }

  export type walletUncheckedCreateInput = {
    ID?: string
    Balance?: number | null
    Title?: string | null
    Description?: string | null
    IsReal?: boolean | null
    UserID?: string | null
    Status?: string | null
    Remask?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Receive?: transactionUncheckedCreateNestedManyWithoutPaidToInput
    Payment?: transactionUncheckedCreateNestedManyWithoutPaidByInput
  }

  export type walletUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsReal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: usersUpdateOneWithoutWalletNestedInput
    Receive?: transactionUpdateManyWithoutPaidToNestedInput
    Payment?: transactionUpdateManyWithoutPaidByNestedInput
  }

  export type walletUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsReal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Receive?: transactionUncheckedUpdateManyWithoutPaidToNestedInput
    Payment?: transactionUncheckedUpdateManyWithoutPaidByNestedInput
  }

  export type walletCreateManyInput = {
    ID?: string
    Balance?: number | null
    Title?: string | null
    Description?: string | null
    IsReal?: boolean | null
    UserID?: string | null
    Status?: string | null
    Remask?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type walletUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsReal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type walletUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsReal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionCreateInput = {
    ID?: string
    Type?: string | null
    Info?: string | null
    Status?: string | null
    Result?: number | null
    Balance?: number | null
    IsPayment?: boolean | null
    IsReceived?: boolean | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    OrderPayment?: orderPaymentCreateNestedOneWithoutTransactionInput
    PaidBy?: walletCreateNestedOneWithoutPaymentInput
    PaidTo?: walletCreateNestedOneWithoutReceiveInput
  }

  export type transactionUncheckedCreateInput = {
    ID?: string
    Type?: string | null
    Info?: string | null
    Status?: string | null
    Result?: number | null
    Balance?: number | null
    IsPayment?: boolean | null
    IsReceived?: boolean | null
    OrderPaymentID?: string | null
    PaidByID?: string | null
    PaidToID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type transactionUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Info?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Result?: NullableFloatFieldUpdateOperationsInput | number | null
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsReceived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderPayment?: orderPaymentUpdateOneWithoutTransactionNestedInput
    PaidBy?: walletUpdateOneWithoutPaymentNestedInput
    PaidTo?: walletUpdateOneWithoutReceiveNestedInput
  }

  export type transactionUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Info?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Result?: NullableFloatFieldUpdateOperationsInput | number | null
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsReceived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    OrderPaymentID?: NullableStringFieldUpdateOperationsInput | string | null
    PaidByID?: NullableStringFieldUpdateOperationsInput | string | null
    PaidToID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionCreateManyInput = {
    ID?: string
    Type?: string | null
    Info?: string | null
    Status?: string | null
    Result?: number | null
    Balance?: number | null
    IsPayment?: boolean | null
    IsReceived?: boolean | null
    OrderPaymentID?: string | null
    PaidByID?: string | null
    PaidToID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type transactionUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Info?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Result?: NullableFloatFieldUpdateOperationsInput | number | null
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsReceived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Info?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Result?: NullableFloatFieldUpdateOperationsInput | number | null
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsReceived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    OrderPaymentID?: NullableStringFieldUpdateOperationsInput | string | null
    PaidByID?: NullableStringFieldUpdateOperationsInput | string | null
    PaidToID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutUserInput
    Wallet?: walletCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileCreateNestedManyWithoutAdminInput
    UserProfile?: profileCreateNestedOneWithoutUserInput
    OTP?: otpCreateNestedManyWithoutUsersInput
    Roles?: usersRolesCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordCreateNestedManyWithoutUsersInput
    Notifications?: notificationsCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesCreateNestedManyWithoutUsersInput
    Order?: orderCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalCreateNestedManyWithoutRecipientUserInput
  }

  export type usersUncheckedCreateInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    BranchesID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Wallet?: walletUncheckedCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentUncheckedCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileUncheckedCreateNestedManyWithoutAdminInput
    UserProfile?: profileUncheckedCreateNestedOneWithoutUserInput
    OTP?: otpUncheckedCreateNestedManyWithoutUsersInput
    Roles?: usersRolesUncheckedCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesUncheckedCreateNestedManyWithoutUsersInput
    Order?: orderUncheckedCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalUncheckedCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalUncheckedCreateNestedManyWithoutRecipientUserInput
  }

  export type usersUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutUserNestedInput
    Wallet?: walletUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUpdateOneWithoutUserNestedInput
    OTP?: otpUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUpdateManyWithoutUsersNestedInput
    Order?: orderUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Wallet?: walletUncheckedUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUncheckedUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUncheckedUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUncheckedUpdateOneWithoutUserNestedInput
    OTP?: otpUncheckedUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUncheckedUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUncheckedUpdateManyWithoutUsersNestedInput
    Order?: orderUncheckedUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUncheckedUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUncheckedUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersCreateManyInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    BranchesID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type profileCreateInput = {
    ID?: string
    Gender?: string | null
    Name: string
    SurName: string
    ProfileURL?: string | null
    AdminPin?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    User?: usersCreateNestedOneWithoutUserProfileInput
    Admin?: usersCreateNestedOneWithoutAdminProfileInput
    Address?: addressCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateInput = {
    ID?: string
    Gender?: string | null
    Name: string
    SurName: string
    ProfileURL?: string | null
    UserID?: string | null
    AdminID?: string | null
    AdminPin?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    SurName?: StringFieldUpdateOperationsInput | string
    ProfileURL?: NullableStringFieldUpdateOperationsInput | string | null
    AdminPin?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: usersUpdateOneWithoutUserProfileNestedInput
    Admin?: usersUpdateOneWithoutAdminProfileNestedInput
    Address?: addressUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    SurName?: StringFieldUpdateOperationsInput | string
    ProfileURL?: NullableStringFieldUpdateOperationsInput | string | null
    UserID?: NullableStringFieldUpdateOperationsInput | string | null
    AdminID?: NullableStringFieldUpdateOperationsInput | string | null
    AdminPin?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type profileCreateManyInput = {
    ID?: string
    Gender?: string | null
    Name: string
    SurName: string
    ProfileURL?: string | null
    UserID?: string | null
    AdminID?: string | null
    AdminPin?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type profileUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    SurName?: StringFieldUpdateOperationsInput | string
    ProfileURL?: NullableStringFieldUpdateOperationsInput | string | null
    AdminPin?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type profileUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    SurName?: StringFieldUpdateOperationsInput | string
    ProfileURL?: NullableStringFieldUpdateOperationsInput | string | null
    UserID?: NullableStringFieldUpdateOperationsInput | string | null
    AdminID?: NullableStringFieldUpdateOperationsInput | string | null
    AdminPin?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type otpCreateInput = {
    ID?: string
    OTP?: string | null
    IsVerify?: boolean
    UserName: string
    Type?: string | null
    Remask?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Users?: usersCreateNestedOneWithoutOTPInput
    Branches?: branchesCreateNestedOneWithoutOtpInput
  }

  export type otpUncheckedCreateInput = {
    ID?: string
    OTP?: string | null
    IsVerify?: boolean
    UserName: string
    Type?: string | null
    Remask?: string | null
    UsersID?: string | null
    BranchesID?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type otpUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    OTP?: NullableStringFieldUpdateOperationsInput | string | null
    IsVerify?: BoolFieldUpdateOperationsInput | boolean
    UserName?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: usersUpdateOneWithoutOTPNestedInput
    Branches?: branchesUpdateOneWithoutOtpNestedInput
  }

  export type otpUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    OTP?: NullableStringFieldUpdateOperationsInput | string | null
    IsVerify?: BoolFieldUpdateOperationsInput | boolean
    UserName?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    UsersID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type otpCreateManyInput = {
    ID?: string
    OTP?: string | null
    IsVerify?: boolean
    UserName: string
    Type?: string | null
    Remask?: string | null
    UsersID?: string | null
    BranchesID?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type otpUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    OTP?: NullableStringFieldUpdateOperationsInput | string | null
    IsVerify?: BoolFieldUpdateOperationsInput | boolean
    UserName?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type otpUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    OTP?: NullableStringFieldUpdateOperationsInput | string | null
    IsVerify?: BoolFieldUpdateOperationsInput | boolean
    UserName?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    UsersID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationsCreateInput = {
    ID?: string
    Titel?: string | null
    Details?: string | null
    Type?: string | null
    Provider?: string | null
    Remask?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Users?: usersCreateNestedOneWithoutNotificationsInput
    Branches?: branchesCreateNestedOneWithoutNotificationsInput
  }

  export type notificationsUncheckedCreateInput = {
    ID?: string
    Titel?: string | null
    Details?: string | null
    Type?: string | null
    Provider?: string | null
    Remask?: string | null
    UsersID?: string | null
    BranchesID?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type notificationsUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: usersUpdateOneWithoutNotificationsNestedInput
    Branches?: branchesUpdateOneWithoutNotificationsNestedInput
  }

  export type notificationsUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    UsersID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationsCreateManyInput = {
    ID?: string
    Titel?: string | null
    Details?: string | null
    Type?: string | null
    Provider?: string | null
    Remask?: string | null
    UsersID?: string | null
    BranchesID?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type notificationsUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationsUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    UsersID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forgotPasswordCreateInput = {
    ID?: string
    Titel?: string | null
    Token?: string | null
    OldPassword?: string | null
    OtpID?: string | null
    Provider?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Users?: usersCreateNestedOneWithoutForgotInput
  }

  export type forgotPasswordUncheckedCreateInput = {
    ID?: string
    Titel?: string | null
    Token?: string | null
    OldPassword?: string | null
    OtpID?: string | null
    Provider?: string | null
    Remask?: string | null
    UsersID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type forgotPasswordUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Token?: NullableStringFieldUpdateOperationsInput | string | null
    OldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    OtpID?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: usersUpdateOneWithoutForgotNestedInput
  }

  export type forgotPasswordUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Token?: NullableStringFieldUpdateOperationsInput | string | null
    OldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    OtpID?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    UsersID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forgotPasswordCreateManyInput = {
    ID?: string
    Titel?: string | null
    Token?: string | null
    OldPassword?: string | null
    OtpID?: string | null
    Provider?: string | null
    Remask?: string | null
    UsersID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type forgotPasswordUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Token?: NullableStringFieldUpdateOperationsInput | string | null
    OldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    OtpID?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forgotPasswordUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Token?: NullableStringFieldUpdateOperationsInput | string | null
    OldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    OtpID?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    UsersID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersRolesCreateInput = {
    ID?: string
    Titel?: string | null
    Type?: string | null
    Role: string
    Permission: string
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Users?: usersCreateNestedOneWithoutRolesInput
  }

  export type usersRolesUncheckedCreateInput = {
    ID?: string
    Titel?: string | null
    Type?: string | null
    Role: string
    Permission: string
    Remask?: string | null
    UsersID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type usersRolesUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: StringFieldUpdateOperationsInput | string
    Permission?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: usersUpdateOneWithoutRolesNestedInput
  }

  export type usersRolesUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: StringFieldUpdateOperationsInput | string
    Permission?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    UsersID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersRolesCreateManyInput = {
    ID?: string
    Titel?: string | null
    Type?: string | null
    Role: string
    Permission: string
    Remask?: string | null
    UsersID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type usersRolesUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: StringFieldUpdateOperationsInput | string
    Permission?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersRolesUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: StringFieldUpdateOperationsInput | string
    Permission?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    UsersID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersActivitiesCreateInput = {
    ID?: string
    Activity?: string | null
    IP?: string | null
    MacAddress?: string | null
    UDID?: string | null
    Remask?: string | null
    Log?: string | null
    Error?: string | null
    Messages?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Users?: usersCreateNestedOneWithoutActivitiesInput
    ThreadingOrder?: orderThreadingCreateNestedOneWithoutActivitieInput
  }

  export type usersActivitiesUncheckedCreateInput = {
    ID?: string
    Activity?: string | null
    IP?: string | null
    MacAddress?: string | null
    UDID?: string | null
    Remask?: string | null
    Log?: string | null
    Error?: string | null
    Messages?: string | null
    UsersID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    ThreadingOrder?: orderThreadingUncheckedCreateNestedOneWithoutActivitieInput
  }

  export type usersActivitiesUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Activity?: NullableStringFieldUpdateOperationsInput | string | null
    IP?: NullableStringFieldUpdateOperationsInput | string | null
    MacAddress?: NullableStringFieldUpdateOperationsInput | string | null
    UDID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Log?: NullableStringFieldUpdateOperationsInput | string | null
    Error?: NullableStringFieldUpdateOperationsInput | string | null
    Messages?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: usersUpdateOneWithoutActivitiesNestedInput
    ThreadingOrder?: orderThreadingUpdateOneWithoutActivitieNestedInput
  }

  export type usersActivitiesUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Activity?: NullableStringFieldUpdateOperationsInput | string | null
    IP?: NullableStringFieldUpdateOperationsInput | string | null
    MacAddress?: NullableStringFieldUpdateOperationsInput | string | null
    UDID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Log?: NullableStringFieldUpdateOperationsInput | string | null
    Error?: NullableStringFieldUpdateOperationsInput | string | null
    Messages?: NullableStringFieldUpdateOperationsInput | string | null
    UsersID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ThreadingOrder?: orderThreadingUncheckedUpdateOneWithoutActivitieNestedInput
  }

  export type usersActivitiesCreateManyInput = {
    ID?: string
    Activity?: string | null
    IP?: string | null
    MacAddress?: string | null
    UDID?: string | null
    Remask?: string | null
    Log?: string | null
    Error?: string | null
    Messages?: string | null
    UsersID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type usersActivitiesUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Activity?: NullableStringFieldUpdateOperationsInput | string | null
    IP?: NullableStringFieldUpdateOperationsInput | string | null
    MacAddress?: NullableStringFieldUpdateOperationsInput | string | null
    UDID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Log?: NullableStringFieldUpdateOperationsInput | string | null
    Error?: NullableStringFieldUpdateOperationsInput | string | null
    Messages?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersActivitiesUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Activity?: NullableStringFieldUpdateOperationsInput | string | null
    IP?: NullableStringFieldUpdateOperationsInput | string | null
    MacAddress?: NullableStringFieldUpdateOperationsInput | string | null
    UDID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Log?: NullableStringFieldUpdateOperationsInput | string | null
    Error?: NullableStringFieldUpdateOperationsInput | string | null
    Messages?: NullableStringFieldUpdateOperationsInput | string | null
    UsersID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderTypeCreateInput = {
    ID?: string
    TypeCode?: string | null
    TypeNmae?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderTypeUncheckedCreateInput = {
    ID?: string
    TypeCode?: string | null
    TypeNmae?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderTypeUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    TypeCode?: NullableStringFieldUpdateOperationsInput | string | null
    TypeNmae?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderTypeUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    TypeCode?: NullableStringFieldUpdateOperationsInput | string | null
    TypeNmae?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderTypeCreateManyInput = {
    ID?: string
    TypeCode?: string | null
    TypeNmae?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderTypeUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    TypeCode?: NullableStringFieldUpdateOperationsInput | string | null
    TypeNmae?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderTypeUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    TypeCode?: NullableStringFieldUpdateOperationsInput | string | null
    TypeNmae?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderCategoryCreateInput = {
    ID?: string
    TypeCode?: string | null
    TypeNmae?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutOrderCategoryInput
    Order?: orderCreateNestedManyWithoutCategoryInput
  }

  export type orderCategoryUncheckedCreateInput = {
    ID?: string
    TypeCode?: string | null
    TypeNmae?: string | null
    Remask?: string | null
    BranchesID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Order?: orderUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type orderCategoryUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    TypeCode?: NullableStringFieldUpdateOperationsInput | string | null
    TypeNmae?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutOrderCategoryNestedInput
    Order?: orderUpdateManyWithoutCategoryNestedInput
  }

  export type orderCategoryUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    TypeCode?: NullableStringFieldUpdateOperationsInput | string | null
    TypeNmae?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Order?: orderUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type orderCategoryCreateManyInput = {
    ID?: string
    TypeCode?: string | null
    TypeNmae?: string | null
    Remask?: string | null
    BranchesID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderCategoryUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    TypeCode?: NullableStringFieldUpdateOperationsInput | string | null
    TypeNmae?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderCategoryUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    TypeCode?: NullableStringFieldUpdateOperationsInput | string | null
    TypeNmae?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderCreateInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Category?: orderCategoryCreateNestedOneWithoutOrderInput
    Personal?: orderPersonalCreateNestedOneWithoutOrderInput
    Details?: orderDetailsCreateNestedOneWithoutOrderInput
    Payment?: orderPaymentCreateNestedOneWithoutOrderInput
    Branches?: branchesCreateNestedOneWithoutOrderInput
    CreateBy?: usersCreateNestedOneWithoutOrderInput
    Tacking?: orderTackingCreateNestedManyWithoutOrderInput
    Threading?: orderThreadingCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    CategoryID?: string | null
    BranchesID?: string | null
    CreateByID?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Personal?: orderPersonalUncheckedCreateNestedOneWithoutOrderInput
    Details?: orderDetailsUncheckedCreateNestedOneWithoutOrderInput
    Payment?: orderPaymentUncheckedCreateNestedOneWithoutOrderInput
    Tacking?: orderTackingUncheckedCreateNestedManyWithoutOrderInput
    Threading?: orderThreadingUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Category?: orderCategoryUpdateOneWithoutOrderNestedInput
    Personal?: orderPersonalUpdateOneWithoutOrderNestedInput
    Details?: orderDetailsUpdateOneWithoutOrderNestedInput
    Payment?: orderPaymentUpdateOneWithoutOrderNestedInput
    Branches?: branchesUpdateOneWithoutOrderNestedInput
    CreateBy?: usersUpdateOneWithoutOrderNestedInput
    Tacking?: orderTackingUpdateManyWithoutOrderNestedInput
    Threading?: orderThreadingUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    CategoryID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    CreateByID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Personal?: orderPersonalUncheckedUpdateOneWithoutOrderNestedInput
    Details?: orderDetailsUncheckedUpdateOneWithoutOrderNestedInput
    Payment?: orderPaymentUncheckedUpdateOneWithoutOrderNestedInput
    Tacking?: orderTackingUncheckedUpdateManyWithoutOrderNestedInput
    Threading?: orderThreadingUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type orderCreateManyInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    CategoryID?: string | null
    BranchesID?: string | null
    CreateByID?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    CategoryID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    CreateByID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderThreadingCreateInput = {
    ID?: string
    Tasks?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Activitie?: usersActivitiesCreateNestedOneWithoutThreadingOrderInput
    Order?: orderCreateNestedOneWithoutThreadingInput
  }

  export type orderThreadingUncheckedCreateInput = {
    ID?: string
    Tasks?: string | null
    ActivitieID?: string | null
    OrderID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderThreadingUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Tasks?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Activitie?: usersActivitiesUpdateOneWithoutThreadingOrderNestedInput
    Order?: orderUpdateOneWithoutThreadingNestedInput
  }

  export type orderThreadingUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Tasks?: NullableStringFieldUpdateOperationsInput | string | null
    ActivitieID?: NullableStringFieldUpdateOperationsInput | string | null
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderThreadingCreateManyInput = {
    ID?: string
    Tasks?: string | null
    ActivitieID?: string | null
    OrderID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderThreadingUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Tasks?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderThreadingUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Tasks?: NullableStringFieldUpdateOperationsInput | string | null
    ActivitieID?: NullableStringFieldUpdateOperationsInput | string | null
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderPersonalCreateInput = {
    ID?: string
    SenderName?: string | null
    SenderPhoneNumber?: string | null
    RecipientName?: string | null
    RecipientPhoneNumber?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    SenderUser?: usersCreateNestedOneWithoutSenderOrderInput
    RecipientUser?: usersCreateNestedOneWithoutRecipientOrderInput
    Order?: orderCreateNestedOneWithoutPersonalInput
  }

  export type orderPersonalUncheckedCreateInput = {
    ID?: string
    SenderName?: string | null
    SenderPhoneNumber?: string | null
    SenderUserID?: string | null
    RecipientName?: string | null
    RecipientPhoneNumber?: string | null
    RecipientID?: string | null
    OrderID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderPersonalUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    SenderPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientName?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SenderUser?: usersUpdateOneWithoutSenderOrderNestedInput
    RecipientUser?: usersUpdateOneWithoutRecipientOrderNestedInput
    Order?: orderUpdateOneWithoutPersonalNestedInput
  }

  export type orderPersonalUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    SenderPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SenderUserID?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientName?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientID?: NullableStringFieldUpdateOperationsInput | string | null
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderPersonalCreateManyInput = {
    ID?: string
    SenderName?: string | null
    SenderPhoneNumber?: string | null
    SenderUserID?: string | null
    RecipientName?: string | null
    RecipientPhoneNumber?: string | null
    RecipientID?: string | null
    OrderID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderPersonalUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    SenderPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientName?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderPersonalUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    SenderPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SenderUserID?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientName?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientID?: NullableStringFieldUpdateOperationsInput | string | null
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderPaymentCreateInput = {
    ID?: string
    PaymentStatus?: string | null
    AmountDeliver?: number | null
    IsPaid?: boolean
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Order?: orderCreateNestedOneWithoutPaymentInput
    PaidTo?: usersCreateNestedOneWithoutRecipientPaymentInput
    Transaction?: transactionCreateNestedOneWithoutOrderPaymentInput
  }

  export type orderPaymentUncheckedCreateInput = {
    ID?: string
    PaymentStatus?: string | null
    AmountDeliver?: number | null
    IsPaid?: boolean
    OrderID?: string | null
    PaidToID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Transaction?: transactionUncheckedCreateNestedOneWithoutOrderPaymentInput
  }

  export type orderPaymentUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    PaymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AmountDeliver?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPaid?: BoolFieldUpdateOperationsInput | boolean
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Order?: orderUpdateOneWithoutPaymentNestedInput
    PaidTo?: usersUpdateOneWithoutRecipientPaymentNestedInput
    Transaction?: transactionUpdateOneWithoutOrderPaymentNestedInput
  }

  export type orderPaymentUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    PaymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AmountDeliver?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPaid?: BoolFieldUpdateOperationsInput | boolean
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    PaidToID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Transaction?: transactionUncheckedUpdateOneWithoutOrderPaymentNestedInput
  }

  export type orderPaymentCreateManyInput = {
    ID?: string
    PaymentStatus?: string | null
    AmountDeliver?: number | null
    IsPaid?: boolean
    OrderID?: string | null
    PaidToID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderPaymentUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    PaymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AmountDeliver?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPaid?: BoolFieldUpdateOperationsInput | boolean
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderPaymentUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    PaymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AmountDeliver?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPaid?: BoolFieldUpdateOperationsInput | boolean
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    PaidToID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderDetailsCreateInput = {
    ID?: string
    Detail?: string | null
    AmountX?: number | null
    AmountY?: number | null
    AmountH?: number | null
    AmountW?: number | null
    Amount?: number | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Order?: orderCreateNestedOneWithoutDetailsInput
  }

  export type orderDetailsUncheckedCreateInput = {
    ID?: string
    Detail?: string | null
    AmountX?: number | null
    AmountY?: number | null
    AmountH?: number | null
    AmountW?: number | null
    Amount?: number | null
    OrderID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderDetailsUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Detail?: NullableStringFieldUpdateOperationsInput | string | null
    AmountX?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountY?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountH?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountW?: NullableFloatFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Order?: orderUpdateOneWithoutDetailsNestedInput
  }

  export type orderDetailsUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Detail?: NullableStringFieldUpdateOperationsInput | string | null
    AmountX?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountY?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountH?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountW?: NullableFloatFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderDetailsCreateManyInput = {
    ID?: string
    Detail?: string | null
    AmountX?: number | null
    AmountY?: number | null
    AmountH?: number | null
    AmountW?: number | null
    Amount?: number | null
    OrderID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderDetailsUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Detail?: NullableStringFieldUpdateOperationsInput | string | null
    AmountX?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountY?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountH?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountW?: NullableFloatFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderDetailsUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Detail?: NullableStringFieldUpdateOperationsInput | string | null
    AmountX?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountY?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountH?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountW?: NullableFloatFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tackingStatusCreateInput = {
    ID?: string
    Status?: string | null
    Description?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Tracking?: orderTackingCreateNestedManyWithoutTrackingStatusInput
  }

  export type tackingStatusUncheckedCreateInput = {
    ID?: string
    Status?: string | null
    Description?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Tracking?: orderTackingUncheckedCreateNestedManyWithoutTrackingStatusInput
  }

  export type tackingStatusUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Tracking?: orderTackingUpdateManyWithoutTrackingStatusNestedInput
  }

  export type tackingStatusUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Tracking?: orderTackingUncheckedUpdateManyWithoutTrackingStatusNestedInput
  }

  export type tackingStatusCreateManyInput = {
    ID?: string
    Status?: string | null
    Description?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type tackingStatusUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tackingStatusUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderTackingCreateInput = {
    ID?: string
    Number?: string | null
    PrimaryPhoneNumber?: string | null
    SecondaryName?: string | null
    SecondaryPhoneNumber?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Order?: orderCreateNestedOneWithoutTackingInput
    Branches?: branchesCreateNestedOneWithoutTrackingInput
    TrackingStatus?: tackingStatusCreateNestedOneWithoutTrackingInput
  }

  export type orderTackingUncheckedCreateInput = {
    ID?: string
    Number?: string | null
    PrimaryPhoneNumber?: string | null
    SecondaryName?: string | null
    SecondaryPhoneNumber?: string | null
    OrderID?: string | null
    BranchesID?: string | null
    TrackingStatusID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderTackingUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Number?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryName?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Order?: orderUpdateOneWithoutTackingNestedInput
    Branches?: branchesUpdateOneWithoutTrackingNestedInput
    TrackingStatus?: tackingStatusUpdateOneWithoutTrackingNestedInput
  }

  export type orderTackingUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Number?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryName?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    TrackingStatusID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderTackingCreateManyInput = {
    ID?: string
    Number?: string | null
    PrimaryPhoneNumber?: string | null
    SecondaryName?: string | null
    SecondaryPhoneNumber?: string | null
    OrderID?: string | null
    BranchesID?: string | null
    TrackingStatusID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderTackingUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Number?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryName?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderTackingUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Number?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryName?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    TrackingStatusID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DistrictListRelationFilter = {
    every?: districtWhereInput
    some?: districtWhereInput
    none?: districtWhereInput
  }

  export type VillageListRelationFilter = {
    every?: villageWhereInput
    some?: villageWhereInput
    none?: villageWhereInput
  }

  export type AddressListRelationFilter = {
    every?: addressWhereInput
    some?: addressWhereInput
    none?: addressWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type districtOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type villageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type addressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type provinceCountOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type provinceMaxOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type provinceMinOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ProvinceNullableRelationFilter = {
    is?: provinceWhereInput | null
    isNot?: provinceWhereInput | null
  }

  export type districtCountOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    ProvinceID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type districtMaxOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    ProvinceID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type districtMinOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    ProvinceID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DistrictNullableRelationFilter = {
    is?: districtWhereInput | null
    isNot?: districtWhereInput | null
  }

  export type villageCountOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    ProvinceID?: SortOrder
    DistrictID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type villageMaxOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    ProvinceID?: SortOrder
    DistrictID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type villageMinOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    ProvinceID?: SortOrder
    DistrictID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ProfileNullableRelationFilter = {
    is?: profileWhereInput | null
    isNot?: profileWhereInput | null
  }

  export type BranchesNullableRelationFilter = {
    is?: branchesWhereInput | null
    isNot?: branchesWhereInput | null
  }

  export type addressCountOrderByAggregateInput = {
    ID?: SortOrder
    Address?: SortOrder
    ProvinceID?: SortOrder
    DistrictID?: SortOrder
    ProfileID?: SortOrder
    BranchesID?: SortOrder
    IsDefault?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type addressMaxOrderByAggregateInput = {
    ID?: SortOrder
    Address?: SortOrder
    ProvinceID?: SortOrder
    DistrictID?: SortOrder
    ProfileID?: SortOrder
    BranchesID?: SortOrder
    IsDefault?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type addressMinOrderByAggregateInput = {
    ID?: SortOrder
    Address?: SortOrder
    ProvinceID?: SortOrder
    DistrictID?: SortOrder
    ProfileID?: SortOrder
    BranchesID?: SortOrder
    IsDefault?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AddressNullableRelationFilter = {
    is?: addressWhereInput | null
    isNot?: addressWhereInput | null
  }

  export type UsersNullableRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type BranchesKeyListRelationFilter = {
    every?: branchesKeyWhereInput
    some?: branchesKeyWhereInput
    none?: branchesKeyWhereInput
  }

  export type BranchesSettingsListRelationFilter = {
    every?: branchesSettingsWhereInput
    some?: branchesSettingsWhereInput
    none?: branchesSettingsWhereInput
  }

  export type OtpListRelationFilter = {
    every?: otpWhereInput
    some?: otpWhereInput
    none?: otpWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: notificationsWhereInput
    some?: notificationsWhereInput
    none?: notificationsWhereInput
  }

  export type OrderCategoryListRelationFilter = {
    every?: orderCategoryWhereInput
    some?: orderCategoryWhereInput
    none?: orderCategoryWhereInput
  }

  export type OrderListRelationFilter = {
    every?: orderWhereInput
    some?: orderWhereInput
    none?: orderWhereInput
  }

  export type OrderTackingListRelationFilter = {
    every?: orderTackingWhereInput
    some?: orderTackingWhereInput
    none?: orderTackingWhereInput
  }

  export type branchesKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type branchesSettingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type otpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type orderCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type orderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type orderTackingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type branchesCountOrderByAggregateInput = {
    ID?: SortOrder
    CompanyId?: SortOrder
    Name?: SortOrder
    Address1?: SortOrder
    Address2?: SortOrder
    Address3?: SortOrder
    Status?: SortOrder
    Lat?: SortOrder
    Long?: SortOrder
    Zone?: SortOrder
    IsMain?: SortOrder
    UploadURL?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type branchesAvgOrderByAggregateInput = {
    Lat?: SortOrder
    Long?: SortOrder
  }

  export type branchesMaxOrderByAggregateInput = {
    ID?: SortOrder
    CompanyId?: SortOrder
    Name?: SortOrder
    Address1?: SortOrder
    Address2?: SortOrder
    Address3?: SortOrder
    Status?: SortOrder
    Lat?: SortOrder
    Long?: SortOrder
    Zone?: SortOrder
    IsMain?: SortOrder
    UploadURL?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type branchesMinOrderByAggregateInput = {
    ID?: SortOrder
    CompanyId?: SortOrder
    Name?: SortOrder
    Address1?: SortOrder
    Address2?: SortOrder
    Address3?: SortOrder
    Status?: SortOrder
    Lat?: SortOrder
    Long?: SortOrder
    Zone?: SortOrder
    IsMain?: SortOrder
    UploadURL?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type branchesSumOrderByAggregateInput = {
    Lat?: SortOrder
    Long?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type branchesKeyCountOrderByAggregateInput = {
    ID?: SortOrder
    Key?: SortOrder
    Secret?: SortOrder
    Remask?: SortOrder
    BranchesID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type branchesKeyMaxOrderByAggregateInput = {
    ID?: SortOrder
    Key?: SortOrder
    Secret?: SortOrder
    Remask?: SortOrder
    BranchesID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type branchesKeyMinOrderByAggregateInput = {
    ID?: SortOrder
    Key?: SortOrder
    Secret?: SortOrder
    Remask?: SortOrder
    BranchesID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type branchesSettingsCountOrderByAggregateInput = {
    ID?: SortOrder
    Titel?: SortOrder
    Setting?: SortOrder
    Remask?: SortOrder
    BranchesID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type branchesSettingsMaxOrderByAggregateInput = {
    ID?: SortOrder
    Titel?: SortOrder
    Setting?: SortOrder
    Remask?: SortOrder
    BranchesID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type branchesSettingsMinOrderByAggregateInput = {
    ID?: SortOrder
    Titel?: SortOrder
    Setting?: SortOrder
    Remask?: SortOrder
    BranchesID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type TransactionListRelationFilter = {
    every?: transactionWhereInput
    some?: transactionWhereInput
    none?: transactionWhereInput
  }

  export type transactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type walletCountOrderByAggregateInput = {
    ID?: SortOrder
    Balance?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    IsReal?: SortOrder
    UserID?: SortOrder
    Status?: SortOrder
    Remask?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type walletAvgOrderByAggregateInput = {
    Balance?: SortOrder
  }

  export type walletMaxOrderByAggregateInput = {
    ID?: SortOrder
    Balance?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    IsReal?: SortOrder
    UserID?: SortOrder
    Status?: SortOrder
    Remask?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type walletMinOrderByAggregateInput = {
    ID?: SortOrder
    Balance?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    IsReal?: SortOrder
    UserID?: SortOrder
    Status?: SortOrder
    Remask?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type walletSumOrderByAggregateInput = {
    Balance?: SortOrder
  }

  export type OrderPaymentNullableRelationFilter = {
    is?: orderPaymentWhereInput | null
    isNot?: orderPaymentWhereInput | null
  }

  export type WalletNullableRelationFilter = {
    is?: walletWhereInput | null
    isNot?: walletWhereInput | null
  }

  export type transactionCountOrderByAggregateInput = {
    ID?: SortOrder
    Type?: SortOrder
    Info?: SortOrder
    Status?: SortOrder
    Result?: SortOrder
    Balance?: SortOrder
    IsPayment?: SortOrder
    IsReceived?: SortOrder
    OrderPaymentID?: SortOrder
    PaidByID?: SortOrder
    PaidToID?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type transactionAvgOrderByAggregateInput = {
    Result?: SortOrder
    Balance?: SortOrder
  }

  export type transactionMaxOrderByAggregateInput = {
    ID?: SortOrder
    Type?: SortOrder
    Info?: SortOrder
    Status?: SortOrder
    Result?: SortOrder
    Balance?: SortOrder
    IsPayment?: SortOrder
    IsReceived?: SortOrder
    OrderPaymentID?: SortOrder
    PaidByID?: SortOrder
    PaidToID?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type transactionMinOrderByAggregateInput = {
    ID?: SortOrder
    Type?: SortOrder
    Info?: SortOrder
    Status?: SortOrder
    Result?: SortOrder
    Balance?: SortOrder
    IsPayment?: SortOrder
    IsReceived?: SortOrder
    OrderPaymentID?: SortOrder
    PaidByID?: SortOrder
    PaidToID?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type transactionSumOrderByAggregateInput = {
    Result?: SortOrder
    Balance?: SortOrder
  }

  export type WalletListRelationFilter = {
    every?: walletWhereInput
    some?: walletWhereInput
    none?: walletWhereInput
  }

  export type OrderPaymentListRelationFilter = {
    every?: orderPaymentWhereInput
    some?: orderPaymentWhereInput
    none?: orderPaymentWhereInput
  }

  export type ProfileListRelationFilter = {
    every?: profileWhereInput
    some?: profileWhereInput
    none?: profileWhereInput
  }

  export type UsersRolesListRelationFilter = {
    every?: usersRolesWhereInput
    some?: usersRolesWhereInput
    none?: usersRolesWhereInput
  }

  export type ForgotPasswordListRelationFilter = {
    every?: forgotPasswordWhereInput
    some?: forgotPasswordWhereInput
    none?: forgotPasswordWhereInput
  }

  export type UsersActivitiesListRelationFilter = {
    every?: usersActivitiesWhereInput
    some?: usersActivitiesWhereInput
    none?: usersActivitiesWhereInput
  }

  export type OrderPersonalListRelationFilter = {
    every?: orderPersonalWhereInput
    some?: orderPersonalWhereInput
    none?: orderPersonalWhereInput
  }

  export type walletOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type orderPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type profileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersRolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type forgotPasswordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersActivitiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type orderPersonalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    ID?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    URL?: SortOrder
    PhoneNumber?: SortOrder
    Email?: SortOrder
    Pin?: SortOrder
    IsRemember?: SortOrder
    IsPin?: SortOrder
    IsBiometric?: SortOrder
    Status?: SortOrder
    Remask?: SortOrder
    LastActive?: SortOrder
    BranchesID?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    ID?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    URL?: SortOrder
    PhoneNumber?: SortOrder
    Email?: SortOrder
    Pin?: SortOrder
    IsRemember?: SortOrder
    IsPin?: SortOrder
    IsBiometric?: SortOrder
    Status?: SortOrder
    Remask?: SortOrder
    LastActive?: SortOrder
    BranchesID?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    ID?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    URL?: SortOrder
    PhoneNumber?: SortOrder
    Email?: SortOrder
    Pin?: SortOrder
    IsRemember?: SortOrder
    IsPin?: SortOrder
    IsBiometric?: SortOrder
    Status?: SortOrder
    Remask?: SortOrder
    LastActive?: SortOrder
    BranchesID?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type profileCountOrderByAggregateInput = {
    ID?: SortOrder
    Gender?: SortOrder
    Name?: SortOrder
    SurName?: SortOrder
    ProfileURL?: SortOrder
    UserID?: SortOrder
    AdminID?: SortOrder
    AdminPin?: SortOrder
    Remask?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type profileMaxOrderByAggregateInput = {
    ID?: SortOrder
    Gender?: SortOrder
    Name?: SortOrder
    SurName?: SortOrder
    ProfileURL?: SortOrder
    UserID?: SortOrder
    AdminID?: SortOrder
    AdminPin?: SortOrder
    Remask?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type profileMinOrderByAggregateInput = {
    ID?: SortOrder
    Gender?: SortOrder
    Name?: SortOrder
    SurName?: SortOrder
    ProfileURL?: SortOrder
    UserID?: SortOrder
    AdminID?: SortOrder
    AdminPin?: SortOrder
    Remask?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type otpCountOrderByAggregateInput = {
    ID?: SortOrder
    OTP?: SortOrder
    IsVerify?: SortOrder
    UserName?: SortOrder
    Type?: SortOrder
    Remask?: SortOrder
    UsersID?: SortOrder
    BranchesID?: SortOrder
    SmsGatewayUUID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type otpMaxOrderByAggregateInput = {
    ID?: SortOrder
    OTP?: SortOrder
    IsVerify?: SortOrder
    UserName?: SortOrder
    Type?: SortOrder
    Remask?: SortOrder
    UsersID?: SortOrder
    BranchesID?: SortOrder
    SmsGatewayUUID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type otpMinOrderByAggregateInput = {
    ID?: SortOrder
    OTP?: SortOrder
    IsVerify?: SortOrder
    UserName?: SortOrder
    Type?: SortOrder
    Remask?: SortOrder
    UsersID?: SortOrder
    BranchesID?: SortOrder
    SmsGatewayUUID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type notificationsCountOrderByAggregateInput = {
    ID?: SortOrder
    Titel?: SortOrder
    Details?: SortOrder
    Type?: SortOrder
    Provider?: SortOrder
    Remask?: SortOrder
    UsersID?: SortOrder
    BranchesID?: SortOrder
    SmsGatewayUUID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    ID?: SortOrder
    Titel?: SortOrder
    Details?: SortOrder
    Type?: SortOrder
    Provider?: SortOrder
    Remask?: SortOrder
    UsersID?: SortOrder
    BranchesID?: SortOrder
    SmsGatewayUUID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    ID?: SortOrder
    Titel?: SortOrder
    Details?: SortOrder
    Type?: SortOrder
    Provider?: SortOrder
    Remask?: SortOrder
    UsersID?: SortOrder
    BranchesID?: SortOrder
    SmsGatewayUUID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type forgotPasswordCountOrderByAggregateInput = {
    ID?: SortOrder
    Titel?: SortOrder
    Token?: SortOrder
    OldPassword?: SortOrder
    OtpID?: SortOrder
    Provider?: SortOrder
    Remask?: SortOrder
    UsersID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type forgotPasswordMaxOrderByAggregateInput = {
    ID?: SortOrder
    Titel?: SortOrder
    Token?: SortOrder
    OldPassword?: SortOrder
    OtpID?: SortOrder
    Provider?: SortOrder
    Remask?: SortOrder
    UsersID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type forgotPasswordMinOrderByAggregateInput = {
    ID?: SortOrder
    Titel?: SortOrder
    Token?: SortOrder
    OldPassword?: SortOrder
    OtpID?: SortOrder
    Provider?: SortOrder
    Remask?: SortOrder
    UsersID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type usersRolesCountOrderByAggregateInput = {
    ID?: SortOrder
    Titel?: SortOrder
    Type?: SortOrder
    Role?: SortOrder
    Permission?: SortOrder
    Remask?: SortOrder
    UsersID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type usersRolesMaxOrderByAggregateInput = {
    ID?: SortOrder
    Titel?: SortOrder
    Type?: SortOrder
    Role?: SortOrder
    Permission?: SortOrder
    Remask?: SortOrder
    UsersID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type usersRolesMinOrderByAggregateInput = {
    ID?: SortOrder
    Titel?: SortOrder
    Type?: SortOrder
    Role?: SortOrder
    Permission?: SortOrder
    Remask?: SortOrder
    UsersID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type OrderThreadingNullableRelationFilter = {
    is?: orderThreadingWhereInput | null
    isNot?: orderThreadingWhereInput | null
  }

  export type usersActivitiesCountOrderByAggregateInput = {
    ID?: SortOrder
    Activity?: SortOrder
    IP?: SortOrder
    MacAddress?: SortOrder
    UDID?: SortOrder
    Remask?: SortOrder
    Log?: SortOrder
    Error?: SortOrder
    Messages?: SortOrder
    UsersID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type usersActivitiesMaxOrderByAggregateInput = {
    ID?: SortOrder
    Activity?: SortOrder
    IP?: SortOrder
    MacAddress?: SortOrder
    UDID?: SortOrder
    Remask?: SortOrder
    Log?: SortOrder
    Error?: SortOrder
    Messages?: SortOrder
    UsersID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type usersActivitiesMinOrderByAggregateInput = {
    ID?: SortOrder
    Activity?: SortOrder
    IP?: SortOrder
    MacAddress?: SortOrder
    UDID?: SortOrder
    Remask?: SortOrder
    Log?: SortOrder
    Error?: SortOrder
    Messages?: SortOrder
    UsersID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderTypeCountOrderByAggregateInput = {
    ID?: SortOrder
    TypeCode?: SortOrder
    TypeNmae?: SortOrder
    Remask?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderTypeMaxOrderByAggregateInput = {
    ID?: SortOrder
    TypeCode?: SortOrder
    TypeNmae?: SortOrder
    Remask?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderTypeMinOrderByAggregateInput = {
    ID?: SortOrder
    TypeCode?: SortOrder
    TypeNmae?: SortOrder
    Remask?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderCategoryCountOrderByAggregateInput = {
    ID?: SortOrder
    TypeCode?: SortOrder
    TypeNmae?: SortOrder
    Remask?: SortOrder
    BranchesID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderCategoryMaxOrderByAggregateInput = {
    ID?: SortOrder
    TypeCode?: SortOrder
    TypeNmae?: SortOrder
    Remask?: SortOrder
    BranchesID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderCategoryMinOrderByAggregateInput = {
    ID?: SortOrder
    TypeCode?: SortOrder
    TypeNmae?: SortOrder
    Remask?: SortOrder
    BranchesID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type OrderCategoryNullableRelationFilter = {
    is?: orderCategoryWhereInput | null
    isNot?: orderCategoryWhereInput | null
  }

  export type OrderPersonalNullableRelationFilter = {
    is?: orderPersonalWhereInput | null
    isNot?: orderPersonalWhereInput | null
  }

  export type OrderDetailsNullableRelationFilter = {
    is?: orderDetailsWhereInput | null
    isNot?: orderDetailsWhereInput | null
  }

  export type OrderThreadingListRelationFilter = {
    every?: orderThreadingWhereInput
    some?: orderThreadingWhereInput
    none?: orderThreadingWhereInput
  }

  export type orderThreadingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type orderCountOrderByAggregateInput = {
    ID?: SortOrder
    Code?: SortOrder
    PrimaryCode?: SortOrder
    SecondaryCode?: SortOrder
    OrderDate?: SortOrder
    Name?: SortOrder
    UplaodURL?: SortOrder
    CategoryID?: SortOrder
    BranchesID?: SortOrder
    CreateByID?: SortOrder
    Remask?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderMaxOrderByAggregateInput = {
    ID?: SortOrder
    Code?: SortOrder
    PrimaryCode?: SortOrder
    SecondaryCode?: SortOrder
    OrderDate?: SortOrder
    Name?: SortOrder
    UplaodURL?: SortOrder
    CategoryID?: SortOrder
    BranchesID?: SortOrder
    CreateByID?: SortOrder
    Remask?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderMinOrderByAggregateInput = {
    ID?: SortOrder
    Code?: SortOrder
    PrimaryCode?: SortOrder
    SecondaryCode?: SortOrder
    OrderDate?: SortOrder
    Name?: SortOrder
    UplaodURL?: SortOrder
    CategoryID?: SortOrder
    BranchesID?: SortOrder
    CreateByID?: SortOrder
    Remask?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type UsersActivitiesNullableRelationFilter = {
    is?: usersActivitiesWhereInput | null
    isNot?: usersActivitiesWhereInput | null
  }

  export type OrderNullableRelationFilter = {
    is?: orderWhereInput | null
    isNot?: orderWhereInput | null
  }

  export type orderThreadingCountOrderByAggregateInput = {
    ID?: SortOrder
    Tasks?: SortOrder
    ActivitieID?: SortOrder
    OrderID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderThreadingMaxOrderByAggregateInput = {
    ID?: SortOrder
    Tasks?: SortOrder
    ActivitieID?: SortOrder
    OrderID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderThreadingMinOrderByAggregateInput = {
    ID?: SortOrder
    Tasks?: SortOrder
    ActivitieID?: SortOrder
    OrderID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderPersonalCountOrderByAggregateInput = {
    ID?: SortOrder
    SenderName?: SortOrder
    SenderPhoneNumber?: SortOrder
    SenderUserID?: SortOrder
    RecipientName?: SortOrder
    RecipientPhoneNumber?: SortOrder
    RecipientID?: SortOrder
    OrderID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderPersonalMaxOrderByAggregateInput = {
    ID?: SortOrder
    SenderName?: SortOrder
    SenderPhoneNumber?: SortOrder
    SenderUserID?: SortOrder
    RecipientName?: SortOrder
    RecipientPhoneNumber?: SortOrder
    RecipientID?: SortOrder
    OrderID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderPersonalMinOrderByAggregateInput = {
    ID?: SortOrder
    SenderName?: SortOrder
    SenderPhoneNumber?: SortOrder
    SenderUserID?: SortOrder
    RecipientName?: SortOrder
    RecipientPhoneNumber?: SortOrder
    RecipientID?: SortOrder
    OrderID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type TransactionNullableRelationFilter = {
    is?: transactionWhereInput | null
    isNot?: transactionWhereInput | null
  }

  export type orderPaymentCountOrderByAggregateInput = {
    ID?: SortOrder
    PaymentStatus?: SortOrder
    AmountDeliver?: SortOrder
    IsPaid?: SortOrder
    OrderID?: SortOrder
    PaidToID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderPaymentAvgOrderByAggregateInput = {
    AmountDeliver?: SortOrder
  }

  export type orderPaymentMaxOrderByAggregateInput = {
    ID?: SortOrder
    PaymentStatus?: SortOrder
    AmountDeliver?: SortOrder
    IsPaid?: SortOrder
    OrderID?: SortOrder
    PaidToID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderPaymentMinOrderByAggregateInput = {
    ID?: SortOrder
    PaymentStatus?: SortOrder
    AmountDeliver?: SortOrder
    IsPaid?: SortOrder
    OrderID?: SortOrder
    PaidToID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderPaymentSumOrderByAggregateInput = {
    AmountDeliver?: SortOrder
  }

  export type orderDetailsCountOrderByAggregateInput = {
    ID?: SortOrder
    Detail?: SortOrder
    AmountX?: SortOrder
    AmountY?: SortOrder
    AmountH?: SortOrder
    AmountW?: SortOrder
    Amount?: SortOrder
    OrderID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderDetailsAvgOrderByAggregateInput = {
    AmountX?: SortOrder
    AmountY?: SortOrder
    AmountH?: SortOrder
    AmountW?: SortOrder
    Amount?: SortOrder
  }

  export type orderDetailsMaxOrderByAggregateInput = {
    ID?: SortOrder
    Detail?: SortOrder
    AmountX?: SortOrder
    AmountY?: SortOrder
    AmountH?: SortOrder
    AmountW?: SortOrder
    Amount?: SortOrder
    OrderID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderDetailsMinOrderByAggregateInput = {
    ID?: SortOrder
    Detail?: SortOrder
    AmountX?: SortOrder
    AmountY?: SortOrder
    AmountH?: SortOrder
    AmountW?: SortOrder
    Amount?: SortOrder
    OrderID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderDetailsSumOrderByAggregateInput = {
    AmountX?: SortOrder
    AmountY?: SortOrder
    AmountH?: SortOrder
    AmountW?: SortOrder
    Amount?: SortOrder
  }

  export type tackingStatusCountOrderByAggregateInput = {
    ID?: SortOrder
    Status?: SortOrder
    Description?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type tackingStatusMaxOrderByAggregateInput = {
    ID?: SortOrder
    Status?: SortOrder
    Description?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type tackingStatusMinOrderByAggregateInput = {
    ID?: SortOrder
    Status?: SortOrder
    Description?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type TackingStatusNullableRelationFilter = {
    is?: tackingStatusWhereInput | null
    isNot?: tackingStatusWhereInput | null
  }

  export type orderTackingCountOrderByAggregateInput = {
    ID?: SortOrder
    Number?: SortOrder
    PrimaryPhoneNumber?: SortOrder
    SecondaryName?: SortOrder
    SecondaryPhoneNumber?: SortOrder
    OrderID?: SortOrder
    BranchesID?: SortOrder
    TrackingStatusID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderTackingMaxOrderByAggregateInput = {
    ID?: SortOrder
    Number?: SortOrder
    PrimaryPhoneNumber?: SortOrder
    SecondaryName?: SortOrder
    SecondaryPhoneNumber?: SortOrder
    OrderID?: SortOrder
    BranchesID?: SortOrder
    TrackingStatusID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type orderTackingMinOrderByAggregateInput = {
    ID?: SortOrder
    Number?: SortOrder
    PrimaryPhoneNumber?: SortOrder
    SecondaryName?: SortOrder
    SecondaryPhoneNumber?: SortOrder
    OrderID?: SortOrder
    BranchesID?: SortOrder
    TrackingStatusID?: SortOrder
    Status?: SortOrder
    IsActive?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type districtCreateNestedManyWithoutProvinceInput = {
    create?: XOR<districtCreateWithoutProvinceInput, districtUncheckedCreateWithoutProvinceInput> | districtCreateWithoutProvinceInput[] | districtUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: districtCreateOrConnectWithoutProvinceInput | districtCreateOrConnectWithoutProvinceInput[]
    createMany?: districtCreateManyProvinceInputEnvelope
    connect?: districtWhereUniqueInput | districtWhereUniqueInput[]
  }

  export type villageCreateNestedManyWithoutProvinceInput = {
    create?: XOR<villageCreateWithoutProvinceInput, villageUncheckedCreateWithoutProvinceInput> | villageCreateWithoutProvinceInput[] | villageUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: villageCreateOrConnectWithoutProvinceInput | villageCreateOrConnectWithoutProvinceInput[]
    createMany?: villageCreateManyProvinceInputEnvelope
    connect?: villageWhereUniqueInput | villageWhereUniqueInput[]
  }

  export type addressCreateNestedManyWithoutProvinceInput = {
    create?: XOR<addressCreateWithoutProvinceInput, addressUncheckedCreateWithoutProvinceInput> | addressCreateWithoutProvinceInput[] | addressUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: addressCreateOrConnectWithoutProvinceInput | addressCreateOrConnectWithoutProvinceInput[]
    createMany?: addressCreateManyProvinceInputEnvelope
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
  }

  export type districtUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<districtCreateWithoutProvinceInput, districtUncheckedCreateWithoutProvinceInput> | districtCreateWithoutProvinceInput[] | districtUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: districtCreateOrConnectWithoutProvinceInput | districtCreateOrConnectWithoutProvinceInput[]
    createMany?: districtCreateManyProvinceInputEnvelope
    connect?: districtWhereUniqueInput | districtWhereUniqueInput[]
  }

  export type villageUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<villageCreateWithoutProvinceInput, villageUncheckedCreateWithoutProvinceInput> | villageCreateWithoutProvinceInput[] | villageUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: villageCreateOrConnectWithoutProvinceInput | villageCreateOrConnectWithoutProvinceInput[]
    createMany?: villageCreateManyProvinceInputEnvelope
    connect?: villageWhereUniqueInput | villageWhereUniqueInput[]
  }

  export type addressUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<addressCreateWithoutProvinceInput, addressUncheckedCreateWithoutProvinceInput> | addressCreateWithoutProvinceInput[] | addressUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: addressCreateOrConnectWithoutProvinceInput | addressCreateOrConnectWithoutProvinceInput[]
    createMany?: addressCreateManyProvinceInputEnvelope
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type districtUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<districtCreateWithoutProvinceInput, districtUncheckedCreateWithoutProvinceInput> | districtCreateWithoutProvinceInput[] | districtUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: districtCreateOrConnectWithoutProvinceInput | districtCreateOrConnectWithoutProvinceInput[]
    upsert?: districtUpsertWithWhereUniqueWithoutProvinceInput | districtUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: districtCreateManyProvinceInputEnvelope
    set?: districtWhereUniqueInput | districtWhereUniqueInput[]
    disconnect?: districtWhereUniqueInput | districtWhereUniqueInput[]
    delete?: districtWhereUniqueInput | districtWhereUniqueInput[]
    connect?: districtWhereUniqueInput | districtWhereUniqueInput[]
    update?: districtUpdateWithWhereUniqueWithoutProvinceInput | districtUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: districtUpdateManyWithWhereWithoutProvinceInput | districtUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: districtScalarWhereInput | districtScalarWhereInput[]
  }

  export type villageUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<villageCreateWithoutProvinceInput, villageUncheckedCreateWithoutProvinceInput> | villageCreateWithoutProvinceInput[] | villageUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: villageCreateOrConnectWithoutProvinceInput | villageCreateOrConnectWithoutProvinceInput[]
    upsert?: villageUpsertWithWhereUniqueWithoutProvinceInput | villageUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: villageCreateManyProvinceInputEnvelope
    set?: villageWhereUniqueInput | villageWhereUniqueInput[]
    disconnect?: villageWhereUniqueInput | villageWhereUniqueInput[]
    delete?: villageWhereUniqueInput | villageWhereUniqueInput[]
    connect?: villageWhereUniqueInput | villageWhereUniqueInput[]
    update?: villageUpdateWithWhereUniqueWithoutProvinceInput | villageUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: villageUpdateManyWithWhereWithoutProvinceInput | villageUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: villageScalarWhereInput | villageScalarWhereInput[]
  }

  export type addressUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<addressCreateWithoutProvinceInput, addressUncheckedCreateWithoutProvinceInput> | addressCreateWithoutProvinceInput[] | addressUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: addressCreateOrConnectWithoutProvinceInput | addressCreateOrConnectWithoutProvinceInput[]
    upsert?: addressUpsertWithWhereUniqueWithoutProvinceInput | addressUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: addressCreateManyProvinceInputEnvelope
    set?: addressWhereUniqueInput | addressWhereUniqueInput[]
    disconnect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    delete?: addressWhereUniqueInput | addressWhereUniqueInput[]
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    update?: addressUpdateWithWhereUniqueWithoutProvinceInput | addressUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: addressUpdateManyWithWhereWithoutProvinceInput | addressUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: addressScalarWhereInput | addressScalarWhereInput[]
  }

  export type districtUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<districtCreateWithoutProvinceInput, districtUncheckedCreateWithoutProvinceInput> | districtCreateWithoutProvinceInput[] | districtUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: districtCreateOrConnectWithoutProvinceInput | districtCreateOrConnectWithoutProvinceInput[]
    upsert?: districtUpsertWithWhereUniqueWithoutProvinceInput | districtUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: districtCreateManyProvinceInputEnvelope
    set?: districtWhereUniqueInput | districtWhereUniqueInput[]
    disconnect?: districtWhereUniqueInput | districtWhereUniqueInput[]
    delete?: districtWhereUniqueInput | districtWhereUniqueInput[]
    connect?: districtWhereUniqueInput | districtWhereUniqueInput[]
    update?: districtUpdateWithWhereUniqueWithoutProvinceInput | districtUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: districtUpdateManyWithWhereWithoutProvinceInput | districtUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: districtScalarWhereInput | districtScalarWhereInput[]
  }

  export type villageUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<villageCreateWithoutProvinceInput, villageUncheckedCreateWithoutProvinceInput> | villageCreateWithoutProvinceInput[] | villageUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: villageCreateOrConnectWithoutProvinceInput | villageCreateOrConnectWithoutProvinceInput[]
    upsert?: villageUpsertWithWhereUniqueWithoutProvinceInput | villageUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: villageCreateManyProvinceInputEnvelope
    set?: villageWhereUniqueInput | villageWhereUniqueInput[]
    disconnect?: villageWhereUniqueInput | villageWhereUniqueInput[]
    delete?: villageWhereUniqueInput | villageWhereUniqueInput[]
    connect?: villageWhereUniqueInput | villageWhereUniqueInput[]
    update?: villageUpdateWithWhereUniqueWithoutProvinceInput | villageUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: villageUpdateManyWithWhereWithoutProvinceInput | villageUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: villageScalarWhereInput | villageScalarWhereInput[]
  }

  export type addressUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<addressCreateWithoutProvinceInput, addressUncheckedCreateWithoutProvinceInput> | addressCreateWithoutProvinceInput[] | addressUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: addressCreateOrConnectWithoutProvinceInput | addressCreateOrConnectWithoutProvinceInput[]
    upsert?: addressUpsertWithWhereUniqueWithoutProvinceInput | addressUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: addressCreateManyProvinceInputEnvelope
    set?: addressWhereUniqueInput | addressWhereUniqueInput[]
    disconnect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    delete?: addressWhereUniqueInput | addressWhereUniqueInput[]
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    update?: addressUpdateWithWhereUniqueWithoutProvinceInput | addressUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: addressUpdateManyWithWhereWithoutProvinceInput | addressUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: addressScalarWhereInput | addressScalarWhereInput[]
  }

  export type provinceCreateNestedOneWithoutDistrictInput = {
    create?: XOR<provinceCreateWithoutDistrictInput, provinceUncheckedCreateWithoutDistrictInput>
    connectOrCreate?: provinceCreateOrConnectWithoutDistrictInput
    connect?: provinceWhereUniqueInput
  }

  export type addressCreateNestedManyWithoutDistrictInput = {
    create?: XOR<addressCreateWithoutDistrictInput, addressUncheckedCreateWithoutDistrictInput> | addressCreateWithoutDistrictInput[] | addressUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: addressCreateOrConnectWithoutDistrictInput | addressCreateOrConnectWithoutDistrictInput[]
    createMany?: addressCreateManyDistrictInputEnvelope
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
  }

  export type villageCreateNestedManyWithoutDistrictInput = {
    create?: XOR<villageCreateWithoutDistrictInput, villageUncheckedCreateWithoutDistrictInput> | villageCreateWithoutDistrictInput[] | villageUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: villageCreateOrConnectWithoutDistrictInput | villageCreateOrConnectWithoutDistrictInput[]
    createMany?: villageCreateManyDistrictInputEnvelope
    connect?: villageWhereUniqueInput | villageWhereUniqueInput[]
  }

  export type addressUncheckedCreateNestedManyWithoutDistrictInput = {
    create?: XOR<addressCreateWithoutDistrictInput, addressUncheckedCreateWithoutDistrictInput> | addressCreateWithoutDistrictInput[] | addressUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: addressCreateOrConnectWithoutDistrictInput | addressCreateOrConnectWithoutDistrictInput[]
    createMany?: addressCreateManyDistrictInputEnvelope
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
  }

  export type villageUncheckedCreateNestedManyWithoutDistrictInput = {
    create?: XOR<villageCreateWithoutDistrictInput, villageUncheckedCreateWithoutDistrictInput> | villageCreateWithoutDistrictInput[] | villageUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: villageCreateOrConnectWithoutDistrictInput | villageCreateOrConnectWithoutDistrictInput[]
    createMany?: villageCreateManyDistrictInputEnvelope
    connect?: villageWhereUniqueInput | villageWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type provinceUpdateOneWithoutDistrictNestedInput = {
    create?: XOR<provinceCreateWithoutDistrictInput, provinceUncheckedCreateWithoutDistrictInput>
    connectOrCreate?: provinceCreateOrConnectWithoutDistrictInput
    upsert?: provinceUpsertWithoutDistrictInput
    disconnect?: provinceWhereInput | boolean
    delete?: provinceWhereInput | boolean
    connect?: provinceWhereUniqueInput
    update?: XOR<XOR<provinceUpdateToOneWithWhereWithoutDistrictInput, provinceUpdateWithoutDistrictInput>, provinceUncheckedUpdateWithoutDistrictInput>
  }

  export type addressUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<addressCreateWithoutDistrictInput, addressUncheckedCreateWithoutDistrictInput> | addressCreateWithoutDistrictInput[] | addressUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: addressCreateOrConnectWithoutDistrictInput | addressCreateOrConnectWithoutDistrictInput[]
    upsert?: addressUpsertWithWhereUniqueWithoutDistrictInput | addressUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: addressCreateManyDistrictInputEnvelope
    set?: addressWhereUniqueInput | addressWhereUniqueInput[]
    disconnect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    delete?: addressWhereUniqueInput | addressWhereUniqueInput[]
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    update?: addressUpdateWithWhereUniqueWithoutDistrictInput | addressUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: addressUpdateManyWithWhereWithoutDistrictInput | addressUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: addressScalarWhereInput | addressScalarWhereInput[]
  }

  export type villageUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<villageCreateWithoutDistrictInput, villageUncheckedCreateWithoutDistrictInput> | villageCreateWithoutDistrictInput[] | villageUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: villageCreateOrConnectWithoutDistrictInput | villageCreateOrConnectWithoutDistrictInput[]
    upsert?: villageUpsertWithWhereUniqueWithoutDistrictInput | villageUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: villageCreateManyDistrictInputEnvelope
    set?: villageWhereUniqueInput | villageWhereUniqueInput[]
    disconnect?: villageWhereUniqueInput | villageWhereUniqueInput[]
    delete?: villageWhereUniqueInput | villageWhereUniqueInput[]
    connect?: villageWhereUniqueInput | villageWhereUniqueInput[]
    update?: villageUpdateWithWhereUniqueWithoutDistrictInput | villageUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: villageUpdateManyWithWhereWithoutDistrictInput | villageUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: villageScalarWhereInput | villageScalarWhereInput[]
  }

  export type addressUncheckedUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<addressCreateWithoutDistrictInput, addressUncheckedCreateWithoutDistrictInput> | addressCreateWithoutDistrictInput[] | addressUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: addressCreateOrConnectWithoutDistrictInput | addressCreateOrConnectWithoutDistrictInput[]
    upsert?: addressUpsertWithWhereUniqueWithoutDistrictInput | addressUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: addressCreateManyDistrictInputEnvelope
    set?: addressWhereUniqueInput | addressWhereUniqueInput[]
    disconnect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    delete?: addressWhereUniqueInput | addressWhereUniqueInput[]
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    update?: addressUpdateWithWhereUniqueWithoutDistrictInput | addressUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: addressUpdateManyWithWhereWithoutDistrictInput | addressUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: addressScalarWhereInput | addressScalarWhereInput[]
  }

  export type villageUncheckedUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<villageCreateWithoutDistrictInput, villageUncheckedCreateWithoutDistrictInput> | villageCreateWithoutDistrictInput[] | villageUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: villageCreateOrConnectWithoutDistrictInput | villageCreateOrConnectWithoutDistrictInput[]
    upsert?: villageUpsertWithWhereUniqueWithoutDistrictInput | villageUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: villageCreateManyDistrictInputEnvelope
    set?: villageWhereUniqueInput | villageWhereUniqueInput[]
    disconnect?: villageWhereUniqueInput | villageWhereUniqueInput[]
    delete?: villageWhereUniqueInput | villageWhereUniqueInput[]
    connect?: villageWhereUniqueInput | villageWhereUniqueInput[]
    update?: villageUpdateWithWhereUniqueWithoutDistrictInput | villageUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: villageUpdateManyWithWhereWithoutDistrictInput | villageUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: villageScalarWhereInput | villageScalarWhereInput[]
  }

  export type provinceCreateNestedOneWithoutVillageInput = {
    create?: XOR<provinceCreateWithoutVillageInput, provinceUncheckedCreateWithoutVillageInput>
    connectOrCreate?: provinceCreateOrConnectWithoutVillageInput
    connect?: provinceWhereUniqueInput
  }

  export type districtCreateNestedOneWithoutVillageInput = {
    create?: XOR<districtCreateWithoutVillageInput, districtUncheckedCreateWithoutVillageInput>
    connectOrCreate?: districtCreateOrConnectWithoutVillageInput
    connect?: districtWhereUniqueInput
  }

  export type provinceUpdateOneWithoutVillageNestedInput = {
    create?: XOR<provinceCreateWithoutVillageInput, provinceUncheckedCreateWithoutVillageInput>
    connectOrCreate?: provinceCreateOrConnectWithoutVillageInput
    upsert?: provinceUpsertWithoutVillageInput
    disconnect?: provinceWhereInput | boolean
    delete?: provinceWhereInput | boolean
    connect?: provinceWhereUniqueInput
    update?: XOR<XOR<provinceUpdateToOneWithWhereWithoutVillageInput, provinceUpdateWithoutVillageInput>, provinceUncheckedUpdateWithoutVillageInput>
  }

  export type districtUpdateOneWithoutVillageNestedInput = {
    create?: XOR<districtCreateWithoutVillageInput, districtUncheckedCreateWithoutVillageInput>
    connectOrCreate?: districtCreateOrConnectWithoutVillageInput
    upsert?: districtUpsertWithoutVillageInput
    disconnect?: districtWhereInput | boolean
    delete?: districtWhereInput | boolean
    connect?: districtWhereUniqueInput
    update?: XOR<XOR<districtUpdateToOneWithWhereWithoutVillageInput, districtUpdateWithoutVillageInput>, districtUncheckedUpdateWithoutVillageInput>
  }

  export type provinceCreateNestedOneWithoutAddressInput = {
    create?: XOR<provinceCreateWithoutAddressInput, provinceUncheckedCreateWithoutAddressInput>
    connectOrCreate?: provinceCreateOrConnectWithoutAddressInput
    connect?: provinceWhereUniqueInput
  }

  export type districtCreateNestedOneWithoutAddressInput = {
    create?: XOR<districtCreateWithoutAddressInput, districtUncheckedCreateWithoutAddressInput>
    connectOrCreate?: districtCreateOrConnectWithoutAddressInput
    connect?: districtWhereUniqueInput
  }

  export type profileCreateNestedOneWithoutAddressInput = {
    create?: XOR<profileCreateWithoutAddressInput, profileUncheckedCreateWithoutAddressInput>
    connectOrCreate?: profileCreateOrConnectWithoutAddressInput
    connect?: profileWhereUniqueInput
  }

  export type branchesCreateNestedOneWithoutAddressInput = {
    create?: XOR<branchesCreateWithoutAddressInput, branchesUncheckedCreateWithoutAddressInput>
    connectOrCreate?: branchesCreateOrConnectWithoutAddressInput
    connect?: branchesWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type provinceUpdateOneWithoutAddressNestedInput = {
    create?: XOR<provinceCreateWithoutAddressInput, provinceUncheckedCreateWithoutAddressInput>
    connectOrCreate?: provinceCreateOrConnectWithoutAddressInput
    upsert?: provinceUpsertWithoutAddressInput
    disconnect?: provinceWhereInput | boolean
    delete?: provinceWhereInput | boolean
    connect?: provinceWhereUniqueInput
    update?: XOR<XOR<provinceUpdateToOneWithWhereWithoutAddressInput, provinceUpdateWithoutAddressInput>, provinceUncheckedUpdateWithoutAddressInput>
  }

  export type districtUpdateOneWithoutAddressNestedInput = {
    create?: XOR<districtCreateWithoutAddressInput, districtUncheckedCreateWithoutAddressInput>
    connectOrCreate?: districtCreateOrConnectWithoutAddressInput
    upsert?: districtUpsertWithoutAddressInput
    disconnect?: districtWhereInput | boolean
    delete?: districtWhereInput | boolean
    connect?: districtWhereUniqueInput
    update?: XOR<XOR<districtUpdateToOneWithWhereWithoutAddressInput, districtUpdateWithoutAddressInput>, districtUncheckedUpdateWithoutAddressInput>
  }

  export type profileUpdateOneWithoutAddressNestedInput = {
    create?: XOR<profileCreateWithoutAddressInput, profileUncheckedCreateWithoutAddressInput>
    connectOrCreate?: profileCreateOrConnectWithoutAddressInput
    upsert?: profileUpsertWithoutAddressInput
    disconnect?: profileWhereInput | boolean
    delete?: profileWhereInput | boolean
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutAddressInput, profileUpdateWithoutAddressInput>, profileUncheckedUpdateWithoutAddressInput>
  }

  export type branchesUpdateOneWithoutAddressNestedInput = {
    create?: XOR<branchesCreateWithoutAddressInput, branchesUncheckedCreateWithoutAddressInput>
    connectOrCreate?: branchesCreateOrConnectWithoutAddressInput
    upsert?: branchesUpsertWithoutAddressInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutAddressInput, branchesUpdateWithoutAddressInput>, branchesUncheckedUpdateWithoutAddressInput>
  }

  export type addressCreateNestedOneWithoutBranchesInput = {
    create?: XOR<addressCreateWithoutBranchesInput, addressUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: addressCreateOrConnectWithoutBranchesInput
    connect?: addressWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutBranchesInput = {
    create?: XOR<usersCreateWithoutBranchesInput, usersUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: usersCreateOrConnectWithoutBranchesInput
    connect?: usersWhereUniqueInput
  }

  export type branchesKeyCreateNestedManyWithoutBranchesInput = {
    create?: XOR<branchesKeyCreateWithoutBranchesInput, branchesKeyUncheckedCreateWithoutBranchesInput> | branchesKeyCreateWithoutBranchesInput[] | branchesKeyUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: branchesKeyCreateOrConnectWithoutBranchesInput | branchesKeyCreateOrConnectWithoutBranchesInput[]
    createMany?: branchesKeyCreateManyBranchesInputEnvelope
    connect?: branchesKeyWhereUniqueInput | branchesKeyWhereUniqueInput[]
  }

  export type branchesSettingsCreateNestedManyWithoutBranchesInput = {
    create?: XOR<branchesSettingsCreateWithoutBranchesInput, branchesSettingsUncheckedCreateWithoutBranchesInput> | branchesSettingsCreateWithoutBranchesInput[] | branchesSettingsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: branchesSettingsCreateOrConnectWithoutBranchesInput | branchesSettingsCreateOrConnectWithoutBranchesInput[]
    createMany?: branchesSettingsCreateManyBranchesInputEnvelope
    connect?: branchesSettingsWhereUniqueInput | branchesSettingsWhereUniqueInput[]
  }

  export type otpCreateNestedManyWithoutBranchesInput = {
    create?: XOR<otpCreateWithoutBranchesInput, otpUncheckedCreateWithoutBranchesInput> | otpCreateWithoutBranchesInput[] | otpUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: otpCreateOrConnectWithoutBranchesInput | otpCreateOrConnectWithoutBranchesInput[]
    createMany?: otpCreateManyBranchesInputEnvelope
    connect?: otpWhereUniqueInput | otpWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutBranchesInput = {
    create?: XOR<notificationsCreateWithoutBranchesInput, notificationsUncheckedCreateWithoutBranchesInput> | notificationsCreateWithoutBranchesInput[] | notificationsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutBranchesInput | notificationsCreateOrConnectWithoutBranchesInput[]
    createMany?: notificationsCreateManyBranchesInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type orderCategoryCreateNestedManyWithoutBranchesInput = {
    create?: XOR<orderCategoryCreateWithoutBranchesInput, orderCategoryUncheckedCreateWithoutBranchesInput> | orderCategoryCreateWithoutBranchesInput[] | orderCategoryUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: orderCategoryCreateOrConnectWithoutBranchesInput | orderCategoryCreateOrConnectWithoutBranchesInput[]
    createMany?: orderCategoryCreateManyBranchesInputEnvelope
    connect?: orderCategoryWhereUniqueInput | orderCategoryWhereUniqueInput[]
  }

  export type orderCreateNestedManyWithoutBranchesInput = {
    create?: XOR<orderCreateWithoutBranchesInput, orderUncheckedCreateWithoutBranchesInput> | orderCreateWithoutBranchesInput[] | orderUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: orderCreateOrConnectWithoutBranchesInput | orderCreateOrConnectWithoutBranchesInput[]
    createMany?: orderCreateManyBranchesInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type orderTackingCreateNestedManyWithoutBranchesInput = {
    create?: XOR<orderTackingCreateWithoutBranchesInput, orderTackingUncheckedCreateWithoutBranchesInput> | orderTackingCreateWithoutBranchesInput[] | orderTackingUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: orderTackingCreateOrConnectWithoutBranchesInput | orderTackingCreateOrConnectWithoutBranchesInput[]
    createMany?: orderTackingCreateManyBranchesInputEnvelope
    connect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
  }

  export type addressUncheckedCreateNestedOneWithoutBranchesInput = {
    create?: XOR<addressCreateWithoutBranchesInput, addressUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: addressCreateOrConnectWithoutBranchesInput
    connect?: addressWhereUniqueInput
  }

  export type usersUncheckedCreateNestedOneWithoutBranchesInput = {
    create?: XOR<usersCreateWithoutBranchesInput, usersUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: usersCreateOrConnectWithoutBranchesInput
    connect?: usersWhereUniqueInput
  }

  export type branchesKeyUncheckedCreateNestedManyWithoutBranchesInput = {
    create?: XOR<branchesKeyCreateWithoutBranchesInput, branchesKeyUncheckedCreateWithoutBranchesInput> | branchesKeyCreateWithoutBranchesInput[] | branchesKeyUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: branchesKeyCreateOrConnectWithoutBranchesInput | branchesKeyCreateOrConnectWithoutBranchesInput[]
    createMany?: branchesKeyCreateManyBranchesInputEnvelope
    connect?: branchesKeyWhereUniqueInput | branchesKeyWhereUniqueInput[]
  }

  export type branchesSettingsUncheckedCreateNestedManyWithoutBranchesInput = {
    create?: XOR<branchesSettingsCreateWithoutBranchesInput, branchesSettingsUncheckedCreateWithoutBranchesInput> | branchesSettingsCreateWithoutBranchesInput[] | branchesSettingsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: branchesSettingsCreateOrConnectWithoutBranchesInput | branchesSettingsCreateOrConnectWithoutBranchesInput[]
    createMany?: branchesSettingsCreateManyBranchesInputEnvelope
    connect?: branchesSettingsWhereUniqueInput | branchesSettingsWhereUniqueInput[]
  }

  export type otpUncheckedCreateNestedManyWithoutBranchesInput = {
    create?: XOR<otpCreateWithoutBranchesInput, otpUncheckedCreateWithoutBranchesInput> | otpCreateWithoutBranchesInput[] | otpUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: otpCreateOrConnectWithoutBranchesInput | otpCreateOrConnectWithoutBranchesInput[]
    createMany?: otpCreateManyBranchesInputEnvelope
    connect?: otpWhereUniqueInput | otpWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutBranchesInput = {
    create?: XOR<notificationsCreateWithoutBranchesInput, notificationsUncheckedCreateWithoutBranchesInput> | notificationsCreateWithoutBranchesInput[] | notificationsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutBranchesInput | notificationsCreateOrConnectWithoutBranchesInput[]
    createMany?: notificationsCreateManyBranchesInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type orderCategoryUncheckedCreateNestedManyWithoutBranchesInput = {
    create?: XOR<orderCategoryCreateWithoutBranchesInput, orderCategoryUncheckedCreateWithoutBranchesInput> | orderCategoryCreateWithoutBranchesInput[] | orderCategoryUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: orderCategoryCreateOrConnectWithoutBranchesInput | orderCategoryCreateOrConnectWithoutBranchesInput[]
    createMany?: orderCategoryCreateManyBranchesInputEnvelope
    connect?: orderCategoryWhereUniqueInput | orderCategoryWhereUniqueInput[]
  }

  export type orderUncheckedCreateNestedManyWithoutBranchesInput = {
    create?: XOR<orderCreateWithoutBranchesInput, orderUncheckedCreateWithoutBranchesInput> | orderCreateWithoutBranchesInput[] | orderUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: orderCreateOrConnectWithoutBranchesInput | orderCreateOrConnectWithoutBranchesInput[]
    createMany?: orderCreateManyBranchesInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type orderTackingUncheckedCreateNestedManyWithoutBranchesInput = {
    create?: XOR<orderTackingCreateWithoutBranchesInput, orderTackingUncheckedCreateWithoutBranchesInput> | orderTackingCreateWithoutBranchesInput[] | orderTackingUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: orderTackingCreateOrConnectWithoutBranchesInput | orderTackingCreateOrConnectWithoutBranchesInput[]
    createMany?: orderTackingCreateManyBranchesInputEnvelope
    connect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type addressUpdateOneWithoutBranchesNestedInput = {
    create?: XOR<addressCreateWithoutBranchesInput, addressUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: addressCreateOrConnectWithoutBranchesInput
    upsert?: addressUpsertWithoutBranchesInput
    disconnect?: addressWhereInput | boolean
    delete?: addressWhereInput | boolean
    connect?: addressWhereUniqueInput
    update?: XOR<XOR<addressUpdateToOneWithWhereWithoutBranchesInput, addressUpdateWithoutBranchesInput>, addressUncheckedUpdateWithoutBranchesInput>
  }

  export type usersUpdateOneWithoutBranchesNestedInput = {
    create?: XOR<usersCreateWithoutBranchesInput, usersUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: usersCreateOrConnectWithoutBranchesInput
    upsert?: usersUpsertWithoutBranchesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutBranchesInput, usersUpdateWithoutBranchesInput>, usersUncheckedUpdateWithoutBranchesInput>
  }

  export type branchesKeyUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<branchesKeyCreateWithoutBranchesInput, branchesKeyUncheckedCreateWithoutBranchesInput> | branchesKeyCreateWithoutBranchesInput[] | branchesKeyUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: branchesKeyCreateOrConnectWithoutBranchesInput | branchesKeyCreateOrConnectWithoutBranchesInput[]
    upsert?: branchesKeyUpsertWithWhereUniqueWithoutBranchesInput | branchesKeyUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: branchesKeyCreateManyBranchesInputEnvelope
    set?: branchesKeyWhereUniqueInput | branchesKeyWhereUniqueInput[]
    disconnect?: branchesKeyWhereUniqueInput | branchesKeyWhereUniqueInput[]
    delete?: branchesKeyWhereUniqueInput | branchesKeyWhereUniqueInput[]
    connect?: branchesKeyWhereUniqueInput | branchesKeyWhereUniqueInput[]
    update?: branchesKeyUpdateWithWhereUniqueWithoutBranchesInput | branchesKeyUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: branchesKeyUpdateManyWithWhereWithoutBranchesInput | branchesKeyUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: branchesKeyScalarWhereInput | branchesKeyScalarWhereInput[]
  }

  export type branchesSettingsUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<branchesSettingsCreateWithoutBranchesInput, branchesSettingsUncheckedCreateWithoutBranchesInput> | branchesSettingsCreateWithoutBranchesInput[] | branchesSettingsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: branchesSettingsCreateOrConnectWithoutBranchesInput | branchesSettingsCreateOrConnectWithoutBranchesInput[]
    upsert?: branchesSettingsUpsertWithWhereUniqueWithoutBranchesInput | branchesSettingsUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: branchesSettingsCreateManyBranchesInputEnvelope
    set?: branchesSettingsWhereUniqueInput | branchesSettingsWhereUniqueInput[]
    disconnect?: branchesSettingsWhereUniqueInput | branchesSettingsWhereUniqueInput[]
    delete?: branchesSettingsWhereUniqueInput | branchesSettingsWhereUniqueInput[]
    connect?: branchesSettingsWhereUniqueInput | branchesSettingsWhereUniqueInput[]
    update?: branchesSettingsUpdateWithWhereUniqueWithoutBranchesInput | branchesSettingsUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: branchesSettingsUpdateManyWithWhereWithoutBranchesInput | branchesSettingsUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: branchesSettingsScalarWhereInput | branchesSettingsScalarWhereInput[]
  }

  export type otpUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<otpCreateWithoutBranchesInput, otpUncheckedCreateWithoutBranchesInput> | otpCreateWithoutBranchesInput[] | otpUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: otpCreateOrConnectWithoutBranchesInput | otpCreateOrConnectWithoutBranchesInput[]
    upsert?: otpUpsertWithWhereUniqueWithoutBranchesInput | otpUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: otpCreateManyBranchesInputEnvelope
    set?: otpWhereUniqueInput | otpWhereUniqueInput[]
    disconnect?: otpWhereUniqueInput | otpWhereUniqueInput[]
    delete?: otpWhereUniqueInput | otpWhereUniqueInput[]
    connect?: otpWhereUniqueInput | otpWhereUniqueInput[]
    update?: otpUpdateWithWhereUniqueWithoutBranchesInput | otpUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: otpUpdateManyWithWhereWithoutBranchesInput | otpUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: otpScalarWhereInput | otpScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<notificationsCreateWithoutBranchesInput, notificationsUncheckedCreateWithoutBranchesInput> | notificationsCreateWithoutBranchesInput[] | notificationsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutBranchesInput | notificationsCreateOrConnectWithoutBranchesInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutBranchesInput | notificationsUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: notificationsCreateManyBranchesInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutBranchesInput | notificationsUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutBranchesInput | notificationsUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type orderCategoryUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<orderCategoryCreateWithoutBranchesInput, orderCategoryUncheckedCreateWithoutBranchesInput> | orderCategoryCreateWithoutBranchesInput[] | orderCategoryUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: orderCategoryCreateOrConnectWithoutBranchesInput | orderCategoryCreateOrConnectWithoutBranchesInput[]
    upsert?: orderCategoryUpsertWithWhereUniqueWithoutBranchesInput | orderCategoryUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: orderCategoryCreateManyBranchesInputEnvelope
    set?: orderCategoryWhereUniqueInput | orderCategoryWhereUniqueInput[]
    disconnect?: orderCategoryWhereUniqueInput | orderCategoryWhereUniqueInput[]
    delete?: orderCategoryWhereUniqueInput | orderCategoryWhereUniqueInput[]
    connect?: orderCategoryWhereUniqueInput | orderCategoryWhereUniqueInput[]
    update?: orderCategoryUpdateWithWhereUniqueWithoutBranchesInput | orderCategoryUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: orderCategoryUpdateManyWithWhereWithoutBranchesInput | orderCategoryUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: orderCategoryScalarWhereInput | orderCategoryScalarWhereInput[]
  }

  export type orderUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<orderCreateWithoutBranchesInput, orderUncheckedCreateWithoutBranchesInput> | orderCreateWithoutBranchesInput[] | orderUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: orderCreateOrConnectWithoutBranchesInput | orderCreateOrConnectWithoutBranchesInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutBranchesInput | orderUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: orderCreateManyBranchesInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutBranchesInput | orderUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: orderUpdateManyWithWhereWithoutBranchesInput | orderUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type orderTackingUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<orderTackingCreateWithoutBranchesInput, orderTackingUncheckedCreateWithoutBranchesInput> | orderTackingCreateWithoutBranchesInput[] | orderTackingUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: orderTackingCreateOrConnectWithoutBranchesInput | orderTackingCreateOrConnectWithoutBranchesInput[]
    upsert?: orderTackingUpsertWithWhereUniqueWithoutBranchesInput | orderTackingUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: orderTackingCreateManyBranchesInputEnvelope
    set?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    disconnect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    delete?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    connect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    update?: orderTackingUpdateWithWhereUniqueWithoutBranchesInput | orderTackingUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: orderTackingUpdateManyWithWhereWithoutBranchesInput | orderTackingUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: orderTackingScalarWhereInput | orderTackingScalarWhereInput[]
  }

  export type addressUncheckedUpdateOneWithoutBranchesNestedInput = {
    create?: XOR<addressCreateWithoutBranchesInput, addressUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: addressCreateOrConnectWithoutBranchesInput
    upsert?: addressUpsertWithoutBranchesInput
    disconnect?: addressWhereInput | boolean
    delete?: addressWhereInput | boolean
    connect?: addressWhereUniqueInput
    update?: XOR<XOR<addressUpdateToOneWithWhereWithoutBranchesInput, addressUpdateWithoutBranchesInput>, addressUncheckedUpdateWithoutBranchesInput>
  }

  export type usersUncheckedUpdateOneWithoutBranchesNestedInput = {
    create?: XOR<usersCreateWithoutBranchesInput, usersUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: usersCreateOrConnectWithoutBranchesInput
    upsert?: usersUpsertWithoutBranchesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutBranchesInput, usersUpdateWithoutBranchesInput>, usersUncheckedUpdateWithoutBranchesInput>
  }

  export type branchesKeyUncheckedUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<branchesKeyCreateWithoutBranchesInput, branchesKeyUncheckedCreateWithoutBranchesInput> | branchesKeyCreateWithoutBranchesInput[] | branchesKeyUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: branchesKeyCreateOrConnectWithoutBranchesInput | branchesKeyCreateOrConnectWithoutBranchesInput[]
    upsert?: branchesKeyUpsertWithWhereUniqueWithoutBranchesInput | branchesKeyUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: branchesKeyCreateManyBranchesInputEnvelope
    set?: branchesKeyWhereUniqueInput | branchesKeyWhereUniqueInput[]
    disconnect?: branchesKeyWhereUniqueInput | branchesKeyWhereUniqueInput[]
    delete?: branchesKeyWhereUniqueInput | branchesKeyWhereUniqueInput[]
    connect?: branchesKeyWhereUniqueInput | branchesKeyWhereUniqueInput[]
    update?: branchesKeyUpdateWithWhereUniqueWithoutBranchesInput | branchesKeyUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: branchesKeyUpdateManyWithWhereWithoutBranchesInput | branchesKeyUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: branchesKeyScalarWhereInput | branchesKeyScalarWhereInput[]
  }

  export type branchesSettingsUncheckedUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<branchesSettingsCreateWithoutBranchesInput, branchesSettingsUncheckedCreateWithoutBranchesInput> | branchesSettingsCreateWithoutBranchesInput[] | branchesSettingsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: branchesSettingsCreateOrConnectWithoutBranchesInput | branchesSettingsCreateOrConnectWithoutBranchesInput[]
    upsert?: branchesSettingsUpsertWithWhereUniqueWithoutBranchesInput | branchesSettingsUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: branchesSettingsCreateManyBranchesInputEnvelope
    set?: branchesSettingsWhereUniqueInput | branchesSettingsWhereUniqueInput[]
    disconnect?: branchesSettingsWhereUniqueInput | branchesSettingsWhereUniqueInput[]
    delete?: branchesSettingsWhereUniqueInput | branchesSettingsWhereUniqueInput[]
    connect?: branchesSettingsWhereUniqueInput | branchesSettingsWhereUniqueInput[]
    update?: branchesSettingsUpdateWithWhereUniqueWithoutBranchesInput | branchesSettingsUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: branchesSettingsUpdateManyWithWhereWithoutBranchesInput | branchesSettingsUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: branchesSettingsScalarWhereInput | branchesSettingsScalarWhereInput[]
  }

  export type otpUncheckedUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<otpCreateWithoutBranchesInput, otpUncheckedCreateWithoutBranchesInput> | otpCreateWithoutBranchesInput[] | otpUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: otpCreateOrConnectWithoutBranchesInput | otpCreateOrConnectWithoutBranchesInput[]
    upsert?: otpUpsertWithWhereUniqueWithoutBranchesInput | otpUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: otpCreateManyBranchesInputEnvelope
    set?: otpWhereUniqueInput | otpWhereUniqueInput[]
    disconnect?: otpWhereUniqueInput | otpWhereUniqueInput[]
    delete?: otpWhereUniqueInput | otpWhereUniqueInput[]
    connect?: otpWhereUniqueInput | otpWhereUniqueInput[]
    update?: otpUpdateWithWhereUniqueWithoutBranchesInput | otpUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: otpUpdateManyWithWhereWithoutBranchesInput | otpUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: otpScalarWhereInput | otpScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<notificationsCreateWithoutBranchesInput, notificationsUncheckedCreateWithoutBranchesInput> | notificationsCreateWithoutBranchesInput[] | notificationsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutBranchesInput | notificationsCreateOrConnectWithoutBranchesInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutBranchesInput | notificationsUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: notificationsCreateManyBranchesInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutBranchesInput | notificationsUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutBranchesInput | notificationsUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type orderCategoryUncheckedUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<orderCategoryCreateWithoutBranchesInput, orderCategoryUncheckedCreateWithoutBranchesInput> | orderCategoryCreateWithoutBranchesInput[] | orderCategoryUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: orderCategoryCreateOrConnectWithoutBranchesInput | orderCategoryCreateOrConnectWithoutBranchesInput[]
    upsert?: orderCategoryUpsertWithWhereUniqueWithoutBranchesInput | orderCategoryUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: orderCategoryCreateManyBranchesInputEnvelope
    set?: orderCategoryWhereUniqueInput | orderCategoryWhereUniqueInput[]
    disconnect?: orderCategoryWhereUniqueInput | orderCategoryWhereUniqueInput[]
    delete?: orderCategoryWhereUniqueInput | orderCategoryWhereUniqueInput[]
    connect?: orderCategoryWhereUniqueInput | orderCategoryWhereUniqueInput[]
    update?: orderCategoryUpdateWithWhereUniqueWithoutBranchesInput | orderCategoryUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: orderCategoryUpdateManyWithWhereWithoutBranchesInput | orderCategoryUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: orderCategoryScalarWhereInput | orderCategoryScalarWhereInput[]
  }

  export type orderUncheckedUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<orderCreateWithoutBranchesInput, orderUncheckedCreateWithoutBranchesInput> | orderCreateWithoutBranchesInput[] | orderUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: orderCreateOrConnectWithoutBranchesInput | orderCreateOrConnectWithoutBranchesInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutBranchesInput | orderUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: orderCreateManyBranchesInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutBranchesInput | orderUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: orderUpdateManyWithWhereWithoutBranchesInput | orderUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type orderTackingUncheckedUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<orderTackingCreateWithoutBranchesInput, orderTackingUncheckedCreateWithoutBranchesInput> | orderTackingCreateWithoutBranchesInput[] | orderTackingUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: orderTackingCreateOrConnectWithoutBranchesInput | orderTackingCreateOrConnectWithoutBranchesInput[]
    upsert?: orderTackingUpsertWithWhereUniqueWithoutBranchesInput | orderTackingUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: orderTackingCreateManyBranchesInputEnvelope
    set?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    disconnect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    delete?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    connect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    update?: orderTackingUpdateWithWhereUniqueWithoutBranchesInput | orderTackingUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: orderTackingUpdateManyWithWhereWithoutBranchesInput | orderTackingUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: orderTackingScalarWhereInput | orderTackingScalarWhereInput[]
  }

  export type branchesCreateNestedOneWithoutBranchesKeyInput = {
    create?: XOR<branchesCreateWithoutBranchesKeyInput, branchesUncheckedCreateWithoutBranchesKeyInput>
    connectOrCreate?: branchesCreateOrConnectWithoutBranchesKeyInput
    connect?: branchesWhereUniqueInput
  }

  export type branchesUpdateOneWithoutBranchesKeyNestedInput = {
    create?: XOR<branchesCreateWithoutBranchesKeyInput, branchesUncheckedCreateWithoutBranchesKeyInput>
    connectOrCreate?: branchesCreateOrConnectWithoutBranchesKeyInput
    upsert?: branchesUpsertWithoutBranchesKeyInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutBranchesKeyInput, branchesUpdateWithoutBranchesKeyInput>, branchesUncheckedUpdateWithoutBranchesKeyInput>
  }

  export type branchesCreateNestedOneWithoutBranchesSettingsInput = {
    create?: XOR<branchesCreateWithoutBranchesSettingsInput, branchesUncheckedCreateWithoutBranchesSettingsInput>
    connectOrCreate?: branchesCreateOrConnectWithoutBranchesSettingsInput
    connect?: branchesWhereUniqueInput
  }

  export type branchesUpdateOneWithoutBranchesSettingsNestedInput = {
    create?: XOR<branchesCreateWithoutBranchesSettingsInput, branchesUncheckedCreateWithoutBranchesSettingsInput>
    connectOrCreate?: branchesCreateOrConnectWithoutBranchesSettingsInput
    upsert?: branchesUpsertWithoutBranchesSettingsInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutBranchesSettingsInput, branchesUpdateWithoutBranchesSettingsInput>, branchesUncheckedUpdateWithoutBranchesSettingsInput>
  }

  export type usersCreateNestedOneWithoutWalletInput = {
    create?: XOR<usersCreateWithoutWalletInput, usersUncheckedCreateWithoutWalletInput>
    connectOrCreate?: usersCreateOrConnectWithoutWalletInput
    connect?: usersWhereUniqueInput
  }

  export type transactionCreateNestedManyWithoutPaidToInput = {
    create?: XOR<transactionCreateWithoutPaidToInput, transactionUncheckedCreateWithoutPaidToInput> | transactionCreateWithoutPaidToInput[] | transactionUncheckedCreateWithoutPaidToInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutPaidToInput | transactionCreateOrConnectWithoutPaidToInput[]
    createMany?: transactionCreateManyPaidToInputEnvelope
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
  }

  export type transactionCreateNestedManyWithoutPaidByInput = {
    create?: XOR<transactionCreateWithoutPaidByInput, transactionUncheckedCreateWithoutPaidByInput> | transactionCreateWithoutPaidByInput[] | transactionUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutPaidByInput | transactionCreateOrConnectWithoutPaidByInput[]
    createMany?: transactionCreateManyPaidByInputEnvelope
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
  }

  export type transactionUncheckedCreateNestedManyWithoutPaidToInput = {
    create?: XOR<transactionCreateWithoutPaidToInput, transactionUncheckedCreateWithoutPaidToInput> | transactionCreateWithoutPaidToInput[] | transactionUncheckedCreateWithoutPaidToInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutPaidToInput | transactionCreateOrConnectWithoutPaidToInput[]
    createMany?: transactionCreateManyPaidToInputEnvelope
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
  }

  export type transactionUncheckedCreateNestedManyWithoutPaidByInput = {
    create?: XOR<transactionCreateWithoutPaidByInput, transactionUncheckedCreateWithoutPaidByInput> | transactionCreateWithoutPaidByInput[] | transactionUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutPaidByInput | transactionCreateOrConnectWithoutPaidByInput[]
    createMany?: transactionCreateManyPaidByInputEnvelope
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
  }

  export type usersUpdateOneWithoutWalletNestedInput = {
    create?: XOR<usersCreateWithoutWalletInput, usersUncheckedCreateWithoutWalletInput>
    connectOrCreate?: usersCreateOrConnectWithoutWalletInput
    upsert?: usersUpsertWithoutWalletInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutWalletInput, usersUpdateWithoutWalletInput>, usersUncheckedUpdateWithoutWalletInput>
  }

  export type transactionUpdateManyWithoutPaidToNestedInput = {
    create?: XOR<transactionCreateWithoutPaidToInput, transactionUncheckedCreateWithoutPaidToInput> | transactionCreateWithoutPaidToInput[] | transactionUncheckedCreateWithoutPaidToInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutPaidToInput | transactionCreateOrConnectWithoutPaidToInput[]
    upsert?: transactionUpsertWithWhereUniqueWithoutPaidToInput | transactionUpsertWithWhereUniqueWithoutPaidToInput[]
    createMany?: transactionCreateManyPaidToInputEnvelope
    set?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    disconnect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    delete?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    update?: transactionUpdateWithWhereUniqueWithoutPaidToInput | transactionUpdateWithWhereUniqueWithoutPaidToInput[]
    updateMany?: transactionUpdateManyWithWhereWithoutPaidToInput | transactionUpdateManyWithWhereWithoutPaidToInput[]
    deleteMany?: transactionScalarWhereInput | transactionScalarWhereInput[]
  }

  export type transactionUpdateManyWithoutPaidByNestedInput = {
    create?: XOR<transactionCreateWithoutPaidByInput, transactionUncheckedCreateWithoutPaidByInput> | transactionCreateWithoutPaidByInput[] | transactionUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutPaidByInput | transactionCreateOrConnectWithoutPaidByInput[]
    upsert?: transactionUpsertWithWhereUniqueWithoutPaidByInput | transactionUpsertWithWhereUniqueWithoutPaidByInput[]
    createMany?: transactionCreateManyPaidByInputEnvelope
    set?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    disconnect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    delete?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    update?: transactionUpdateWithWhereUniqueWithoutPaidByInput | transactionUpdateWithWhereUniqueWithoutPaidByInput[]
    updateMany?: transactionUpdateManyWithWhereWithoutPaidByInput | transactionUpdateManyWithWhereWithoutPaidByInput[]
    deleteMany?: transactionScalarWhereInput | transactionScalarWhereInput[]
  }

  export type transactionUncheckedUpdateManyWithoutPaidToNestedInput = {
    create?: XOR<transactionCreateWithoutPaidToInput, transactionUncheckedCreateWithoutPaidToInput> | transactionCreateWithoutPaidToInput[] | transactionUncheckedCreateWithoutPaidToInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutPaidToInput | transactionCreateOrConnectWithoutPaidToInput[]
    upsert?: transactionUpsertWithWhereUniqueWithoutPaidToInput | transactionUpsertWithWhereUniqueWithoutPaidToInput[]
    createMany?: transactionCreateManyPaidToInputEnvelope
    set?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    disconnect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    delete?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    update?: transactionUpdateWithWhereUniqueWithoutPaidToInput | transactionUpdateWithWhereUniqueWithoutPaidToInput[]
    updateMany?: transactionUpdateManyWithWhereWithoutPaidToInput | transactionUpdateManyWithWhereWithoutPaidToInput[]
    deleteMany?: transactionScalarWhereInput | transactionScalarWhereInput[]
  }

  export type transactionUncheckedUpdateManyWithoutPaidByNestedInput = {
    create?: XOR<transactionCreateWithoutPaidByInput, transactionUncheckedCreateWithoutPaidByInput> | transactionCreateWithoutPaidByInput[] | transactionUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutPaidByInput | transactionCreateOrConnectWithoutPaidByInput[]
    upsert?: transactionUpsertWithWhereUniqueWithoutPaidByInput | transactionUpsertWithWhereUniqueWithoutPaidByInput[]
    createMany?: transactionCreateManyPaidByInputEnvelope
    set?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    disconnect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    delete?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    update?: transactionUpdateWithWhereUniqueWithoutPaidByInput | transactionUpdateWithWhereUniqueWithoutPaidByInput[]
    updateMany?: transactionUpdateManyWithWhereWithoutPaidByInput | transactionUpdateManyWithWhereWithoutPaidByInput[]
    deleteMany?: transactionScalarWhereInput | transactionScalarWhereInput[]
  }

  export type orderPaymentCreateNestedOneWithoutTransactionInput = {
    create?: XOR<orderPaymentCreateWithoutTransactionInput, orderPaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: orderPaymentCreateOrConnectWithoutTransactionInput
    connect?: orderPaymentWhereUniqueInput
  }

  export type walletCreateNestedOneWithoutPaymentInput = {
    create?: XOR<walletCreateWithoutPaymentInput, walletUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: walletCreateOrConnectWithoutPaymentInput
    connect?: walletWhereUniqueInput
  }

  export type walletCreateNestedOneWithoutReceiveInput = {
    create?: XOR<walletCreateWithoutReceiveInput, walletUncheckedCreateWithoutReceiveInput>
    connectOrCreate?: walletCreateOrConnectWithoutReceiveInput
    connect?: walletWhereUniqueInput
  }

  export type orderPaymentUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<orderPaymentCreateWithoutTransactionInput, orderPaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: orderPaymentCreateOrConnectWithoutTransactionInput
    upsert?: orderPaymentUpsertWithoutTransactionInput
    disconnect?: orderPaymentWhereInput | boolean
    delete?: orderPaymentWhereInput | boolean
    connect?: orderPaymentWhereUniqueInput
    update?: XOR<XOR<orderPaymentUpdateToOneWithWhereWithoutTransactionInput, orderPaymentUpdateWithoutTransactionInput>, orderPaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type walletUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<walletCreateWithoutPaymentInput, walletUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: walletCreateOrConnectWithoutPaymentInput
    upsert?: walletUpsertWithoutPaymentInput
    disconnect?: walletWhereInput | boolean
    delete?: walletWhereInput | boolean
    connect?: walletWhereUniqueInput
    update?: XOR<XOR<walletUpdateToOneWithWhereWithoutPaymentInput, walletUpdateWithoutPaymentInput>, walletUncheckedUpdateWithoutPaymentInput>
  }

  export type walletUpdateOneWithoutReceiveNestedInput = {
    create?: XOR<walletCreateWithoutReceiveInput, walletUncheckedCreateWithoutReceiveInput>
    connectOrCreate?: walletCreateOrConnectWithoutReceiveInput
    upsert?: walletUpsertWithoutReceiveInput
    disconnect?: walletWhereInput | boolean
    delete?: walletWhereInput | boolean
    connect?: walletWhereUniqueInput
    update?: XOR<XOR<walletUpdateToOneWithWhereWithoutReceiveInput, walletUpdateWithoutReceiveInput>, walletUncheckedUpdateWithoutReceiveInput>
  }

  export type branchesCreateNestedOneWithoutUserInput = {
    create?: XOR<branchesCreateWithoutUserInput, branchesUncheckedCreateWithoutUserInput>
    connectOrCreate?: branchesCreateOrConnectWithoutUserInput
    connect?: branchesWhereUniqueInput
  }

  export type walletCreateNestedManyWithoutUserInput = {
    create?: XOR<walletCreateWithoutUserInput, walletUncheckedCreateWithoutUserInput> | walletCreateWithoutUserInput[] | walletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: walletCreateOrConnectWithoutUserInput | walletCreateOrConnectWithoutUserInput[]
    createMany?: walletCreateManyUserInputEnvelope
    connect?: walletWhereUniqueInput | walletWhereUniqueInput[]
  }

  export type orderPaymentCreateNestedManyWithoutPaidToInput = {
    create?: XOR<orderPaymentCreateWithoutPaidToInput, orderPaymentUncheckedCreateWithoutPaidToInput> | orderPaymentCreateWithoutPaidToInput[] | orderPaymentUncheckedCreateWithoutPaidToInput[]
    connectOrCreate?: orderPaymentCreateOrConnectWithoutPaidToInput | orderPaymentCreateOrConnectWithoutPaidToInput[]
    createMany?: orderPaymentCreateManyPaidToInputEnvelope
    connect?: orderPaymentWhereUniqueInput | orderPaymentWhereUniqueInput[]
  }

  export type profileCreateNestedManyWithoutAdminInput = {
    create?: XOR<profileCreateWithoutAdminInput, profileUncheckedCreateWithoutAdminInput> | profileCreateWithoutAdminInput[] | profileUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: profileCreateOrConnectWithoutAdminInput | profileCreateOrConnectWithoutAdminInput[]
    createMany?: profileCreateManyAdminInputEnvelope
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
  }

  export type profileCreateNestedOneWithoutUserInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    connect?: profileWhereUniqueInput
  }

  export type otpCreateNestedManyWithoutUsersInput = {
    create?: XOR<otpCreateWithoutUsersInput, otpUncheckedCreateWithoutUsersInput> | otpCreateWithoutUsersInput[] | otpUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: otpCreateOrConnectWithoutUsersInput | otpCreateOrConnectWithoutUsersInput[]
    createMany?: otpCreateManyUsersInputEnvelope
    connect?: otpWhereUniqueInput | otpWhereUniqueInput[]
  }

  export type usersRolesCreateNestedManyWithoutUsersInput = {
    create?: XOR<usersRolesCreateWithoutUsersInput, usersRolesUncheckedCreateWithoutUsersInput> | usersRolesCreateWithoutUsersInput[] | usersRolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usersRolesCreateOrConnectWithoutUsersInput | usersRolesCreateOrConnectWithoutUsersInput[]
    createMany?: usersRolesCreateManyUsersInputEnvelope
    connect?: usersRolesWhereUniqueInput | usersRolesWhereUniqueInput[]
  }

  export type forgotPasswordCreateNestedManyWithoutUsersInput = {
    create?: XOR<forgotPasswordCreateWithoutUsersInput, forgotPasswordUncheckedCreateWithoutUsersInput> | forgotPasswordCreateWithoutUsersInput[] | forgotPasswordUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: forgotPasswordCreateOrConnectWithoutUsersInput | forgotPasswordCreateOrConnectWithoutUsersInput[]
    createMany?: forgotPasswordCreateManyUsersInputEnvelope
    connect?: forgotPasswordWhereUniqueInput | forgotPasswordWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type usersActivitiesCreateNestedManyWithoutUsersInput = {
    create?: XOR<usersActivitiesCreateWithoutUsersInput, usersActivitiesUncheckedCreateWithoutUsersInput> | usersActivitiesCreateWithoutUsersInput[] | usersActivitiesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usersActivitiesCreateOrConnectWithoutUsersInput | usersActivitiesCreateOrConnectWithoutUsersInput[]
    createMany?: usersActivitiesCreateManyUsersInputEnvelope
    connect?: usersActivitiesWhereUniqueInput | usersActivitiesWhereUniqueInput[]
  }

  export type orderCreateNestedManyWithoutCreateByInput = {
    create?: XOR<orderCreateWithoutCreateByInput, orderUncheckedCreateWithoutCreateByInput> | orderCreateWithoutCreateByInput[] | orderUncheckedCreateWithoutCreateByInput[]
    connectOrCreate?: orderCreateOrConnectWithoutCreateByInput | orderCreateOrConnectWithoutCreateByInput[]
    createMany?: orderCreateManyCreateByInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type orderPersonalCreateNestedManyWithoutSenderUserInput = {
    create?: XOR<orderPersonalCreateWithoutSenderUserInput, orderPersonalUncheckedCreateWithoutSenderUserInput> | orderPersonalCreateWithoutSenderUserInput[] | orderPersonalUncheckedCreateWithoutSenderUserInput[]
    connectOrCreate?: orderPersonalCreateOrConnectWithoutSenderUserInput | orderPersonalCreateOrConnectWithoutSenderUserInput[]
    createMany?: orderPersonalCreateManySenderUserInputEnvelope
    connect?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
  }

  export type orderPersonalCreateNestedManyWithoutRecipientUserInput = {
    create?: XOR<orderPersonalCreateWithoutRecipientUserInput, orderPersonalUncheckedCreateWithoutRecipientUserInput> | orderPersonalCreateWithoutRecipientUserInput[] | orderPersonalUncheckedCreateWithoutRecipientUserInput[]
    connectOrCreate?: orderPersonalCreateOrConnectWithoutRecipientUserInput | orderPersonalCreateOrConnectWithoutRecipientUserInput[]
    createMany?: orderPersonalCreateManyRecipientUserInputEnvelope
    connect?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
  }

  export type walletUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<walletCreateWithoutUserInput, walletUncheckedCreateWithoutUserInput> | walletCreateWithoutUserInput[] | walletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: walletCreateOrConnectWithoutUserInput | walletCreateOrConnectWithoutUserInput[]
    createMany?: walletCreateManyUserInputEnvelope
    connect?: walletWhereUniqueInput | walletWhereUniqueInput[]
  }

  export type orderPaymentUncheckedCreateNestedManyWithoutPaidToInput = {
    create?: XOR<orderPaymentCreateWithoutPaidToInput, orderPaymentUncheckedCreateWithoutPaidToInput> | orderPaymentCreateWithoutPaidToInput[] | orderPaymentUncheckedCreateWithoutPaidToInput[]
    connectOrCreate?: orderPaymentCreateOrConnectWithoutPaidToInput | orderPaymentCreateOrConnectWithoutPaidToInput[]
    createMany?: orderPaymentCreateManyPaidToInputEnvelope
    connect?: orderPaymentWhereUniqueInput | orderPaymentWhereUniqueInput[]
  }

  export type profileUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<profileCreateWithoutAdminInput, profileUncheckedCreateWithoutAdminInput> | profileCreateWithoutAdminInput[] | profileUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: profileCreateOrConnectWithoutAdminInput | profileCreateOrConnectWithoutAdminInput[]
    createMany?: profileCreateManyAdminInputEnvelope
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
  }

  export type profileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    connect?: profileWhereUniqueInput
  }

  export type otpUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<otpCreateWithoutUsersInput, otpUncheckedCreateWithoutUsersInput> | otpCreateWithoutUsersInput[] | otpUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: otpCreateOrConnectWithoutUsersInput | otpCreateOrConnectWithoutUsersInput[]
    createMany?: otpCreateManyUsersInputEnvelope
    connect?: otpWhereUniqueInput | otpWhereUniqueInput[]
  }

  export type usersRolesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<usersRolesCreateWithoutUsersInput, usersRolesUncheckedCreateWithoutUsersInput> | usersRolesCreateWithoutUsersInput[] | usersRolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usersRolesCreateOrConnectWithoutUsersInput | usersRolesCreateOrConnectWithoutUsersInput[]
    createMany?: usersRolesCreateManyUsersInputEnvelope
    connect?: usersRolesWhereUniqueInput | usersRolesWhereUniqueInput[]
  }

  export type forgotPasswordUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<forgotPasswordCreateWithoutUsersInput, forgotPasswordUncheckedCreateWithoutUsersInput> | forgotPasswordCreateWithoutUsersInput[] | forgotPasswordUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: forgotPasswordCreateOrConnectWithoutUsersInput | forgotPasswordCreateOrConnectWithoutUsersInput[]
    createMany?: forgotPasswordCreateManyUsersInputEnvelope
    connect?: forgotPasswordWhereUniqueInput | forgotPasswordWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type usersActivitiesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<usersActivitiesCreateWithoutUsersInput, usersActivitiesUncheckedCreateWithoutUsersInput> | usersActivitiesCreateWithoutUsersInput[] | usersActivitiesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usersActivitiesCreateOrConnectWithoutUsersInput | usersActivitiesCreateOrConnectWithoutUsersInput[]
    createMany?: usersActivitiesCreateManyUsersInputEnvelope
    connect?: usersActivitiesWhereUniqueInput | usersActivitiesWhereUniqueInput[]
  }

  export type orderUncheckedCreateNestedManyWithoutCreateByInput = {
    create?: XOR<orderCreateWithoutCreateByInput, orderUncheckedCreateWithoutCreateByInput> | orderCreateWithoutCreateByInput[] | orderUncheckedCreateWithoutCreateByInput[]
    connectOrCreate?: orderCreateOrConnectWithoutCreateByInput | orderCreateOrConnectWithoutCreateByInput[]
    createMany?: orderCreateManyCreateByInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type orderPersonalUncheckedCreateNestedManyWithoutSenderUserInput = {
    create?: XOR<orderPersonalCreateWithoutSenderUserInput, orderPersonalUncheckedCreateWithoutSenderUserInput> | orderPersonalCreateWithoutSenderUserInput[] | orderPersonalUncheckedCreateWithoutSenderUserInput[]
    connectOrCreate?: orderPersonalCreateOrConnectWithoutSenderUserInput | orderPersonalCreateOrConnectWithoutSenderUserInput[]
    createMany?: orderPersonalCreateManySenderUserInputEnvelope
    connect?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
  }

  export type orderPersonalUncheckedCreateNestedManyWithoutRecipientUserInput = {
    create?: XOR<orderPersonalCreateWithoutRecipientUserInput, orderPersonalUncheckedCreateWithoutRecipientUserInput> | orderPersonalCreateWithoutRecipientUserInput[] | orderPersonalUncheckedCreateWithoutRecipientUserInput[]
    connectOrCreate?: orderPersonalCreateOrConnectWithoutRecipientUserInput | orderPersonalCreateOrConnectWithoutRecipientUserInput[]
    createMany?: orderPersonalCreateManyRecipientUserInputEnvelope
    connect?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
  }

  export type branchesUpdateOneWithoutUserNestedInput = {
    create?: XOR<branchesCreateWithoutUserInput, branchesUncheckedCreateWithoutUserInput>
    connectOrCreate?: branchesCreateOrConnectWithoutUserInput
    upsert?: branchesUpsertWithoutUserInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutUserInput, branchesUpdateWithoutUserInput>, branchesUncheckedUpdateWithoutUserInput>
  }

  export type walletUpdateManyWithoutUserNestedInput = {
    create?: XOR<walletCreateWithoutUserInput, walletUncheckedCreateWithoutUserInput> | walletCreateWithoutUserInput[] | walletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: walletCreateOrConnectWithoutUserInput | walletCreateOrConnectWithoutUserInput[]
    upsert?: walletUpsertWithWhereUniqueWithoutUserInput | walletUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: walletCreateManyUserInputEnvelope
    set?: walletWhereUniqueInput | walletWhereUniqueInput[]
    disconnect?: walletWhereUniqueInput | walletWhereUniqueInput[]
    delete?: walletWhereUniqueInput | walletWhereUniqueInput[]
    connect?: walletWhereUniqueInput | walletWhereUniqueInput[]
    update?: walletUpdateWithWhereUniqueWithoutUserInput | walletUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: walletUpdateManyWithWhereWithoutUserInput | walletUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: walletScalarWhereInput | walletScalarWhereInput[]
  }

  export type orderPaymentUpdateManyWithoutPaidToNestedInput = {
    create?: XOR<orderPaymentCreateWithoutPaidToInput, orderPaymentUncheckedCreateWithoutPaidToInput> | orderPaymentCreateWithoutPaidToInput[] | orderPaymentUncheckedCreateWithoutPaidToInput[]
    connectOrCreate?: orderPaymentCreateOrConnectWithoutPaidToInput | orderPaymentCreateOrConnectWithoutPaidToInput[]
    upsert?: orderPaymentUpsertWithWhereUniqueWithoutPaidToInput | orderPaymentUpsertWithWhereUniqueWithoutPaidToInput[]
    createMany?: orderPaymentCreateManyPaidToInputEnvelope
    set?: orderPaymentWhereUniqueInput | orderPaymentWhereUniqueInput[]
    disconnect?: orderPaymentWhereUniqueInput | orderPaymentWhereUniqueInput[]
    delete?: orderPaymentWhereUniqueInput | orderPaymentWhereUniqueInput[]
    connect?: orderPaymentWhereUniqueInput | orderPaymentWhereUniqueInput[]
    update?: orderPaymentUpdateWithWhereUniqueWithoutPaidToInput | orderPaymentUpdateWithWhereUniqueWithoutPaidToInput[]
    updateMany?: orderPaymentUpdateManyWithWhereWithoutPaidToInput | orderPaymentUpdateManyWithWhereWithoutPaidToInput[]
    deleteMany?: orderPaymentScalarWhereInput | orderPaymentScalarWhereInput[]
  }

  export type profileUpdateManyWithoutAdminNestedInput = {
    create?: XOR<profileCreateWithoutAdminInput, profileUncheckedCreateWithoutAdminInput> | profileCreateWithoutAdminInput[] | profileUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: profileCreateOrConnectWithoutAdminInput | profileCreateOrConnectWithoutAdminInput[]
    upsert?: profileUpsertWithWhereUniqueWithoutAdminInput | profileUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: profileCreateManyAdminInputEnvelope
    set?: profileWhereUniqueInput | profileWhereUniqueInput[]
    disconnect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    delete?: profileWhereUniqueInput | profileWhereUniqueInput[]
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    update?: profileUpdateWithWhereUniqueWithoutAdminInput | profileUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: profileUpdateManyWithWhereWithoutAdminInput | profileUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: profileScalarWhereInput | profileScalarWhereInput[]
  }

  export type profileUpdateOneWithoutUserNestedInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    upsert?: profileUpsertWithoutUserInput
    disconnect?: profileWhereInput | boolean
    delete?: profileWhereInput | boolean
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutUserInput, profileUpdateWithoutUserInput>, profileUncheckedUpdateWithoutUserInput>
  }

  export type otpUpdateManyWithoutUsersNestedInput = {
    create?: XOR<otpCreateWithoutUsersInput, otpUncheckedCreateWithoutUsersInput> | otpCreateWithoutUsersInput[] | otpUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: otpCreateOrConnectWithoutUsersInput | otpCreateOrConnectWithoutUsersInput[]
    upsert?: otpUpsertWithWhereUniqueWithoutUsersInput | otpUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: otpCreateManyUsersInputEnvelope
    set?: otpWhereUniqueInput | otpWhereUniqueInput[]
    disconnect?: otpWhereUniqueInput | otpWhereUniqueInput[]
    delete?: otpWhereUniqueInput | otpWhereUniqueInput[]
    connect?: otpWhereUniqueInput | otpWhereUniqueInput[]
    update?: otpUpdateWithWhereUniqueWithoutUsersInput | otpUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: otpUpdateManyWithWhereWithoutUsersInput | otpUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: otpScalarWhereInput | otpScalarWhereInput[]
  }

  export type usersRolesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<usersRolesCreateWithoutUsersInput, usersRolesUncheckedCreateWithoutUsersInput> | usersRolesCreateWithoutUsersInput[] | usersRolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usersRolesCreateOrConnectWithoutUsersInput | usersRolesCreateOrConnectWithoutUsersInput[]
    upsert?: usersRolesUpsertWithWhereUniqueWithoutUsersInput | usersRolesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: usersRolesCreateManyUsersInputEnvelope
    set?: usersRolesWhereUniqueInput | usersRolesWhereUniqueInput[]
    disconnect?: usersRolesWhereUniqueInput | usersRolesWhereUniqueInput[]
    delete?: usersRolesWhereUniqueInput | usersRolesWhereUniqueInput[]
    connect?: usersRolesWhereUniqueInput | usersRolesWhereUniqueInput[]
    update?: usersRolesUpdateWithWhereUniqueWithoutUsersInput | usersRolesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: usersRolesUpdateManyWithWhereWithoutUsersInput | usersRolesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: usersRolesScalarWhereInput | usersRolesScalarWhereInput[]
  }

  export type forgotPasswordUpdateManyWithoutUsersNestedInput = {
    create?: XOR<forgotPasswordCreateWithoutUsersInput, forgotPasswordUncheckedCreateWithoutUsersInput> | forgotPasswordCreateWithoutUsersInput[] | forgotPasswordUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: forgotPasswordCreateOrConnectWithoutUsersInput | forgotPasswordCreateOrConnectWithoutUsersInput[]
    upsert?: forgotPasswordUpsertWithWhereUniqueWithoutUsersInput | forgotPasswordUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: forgotPasswordCreateManyUsersInputEnvelope
    set?: forgotPasswordWhereUniqueInput | forgotPasswordWhereUniqueInput[]
    disconnect?: forgotPasswordWhereUniqueInput | forgotPasswordWhereUniqueInput[]
    delete?: forgotPasswordWhereUniqueInput | forgotPasswordWhereUniqueInput[]
    connect?: forgotPasswordWhereUniqueInput | forgotPasswordWhereUniqueInput[]
    update?: forgotPasswordUpdateWithWhereUniqueWithoutUsersInput | forgotPasswordUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: forgotPasswordUpdateManyWithWhereWithoutUsersInput | forgotPasswordUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: forgotPasswordScalarWhereInput | forgotPasswordScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsersInput | notificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsersInput | notificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsersInput | notificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type usersActivitiesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<usersActivitiesCreateWithoutUsersInput, usersActivitiesUncheckedCreateWithoutUsersInput> | usersActivitiesCreateWithoutUsersInput[] | usersActivitiesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usersActivitiesCreateOrConnectWithoutUsersInput | usersActivitiesCreateOrConnectWithoutUsersInput[]
    upsert?: usersActivitiesUpsertWithWhereUniqueWithoutUsersInput | usersActivitiesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: usersActivitiesCreateManyUsersInputEnvelope
    set?: usersActivitiesWhereUniqueInput | usersActivitiesWhereUniqueInput[]
    disconnect?: usersActivitiesWhereUniqueInput | usersActivitiesWhereUniqueInput[]
    delete?: usersActivitiesWhereUniqueInput | usersActivitiesWhereUniqueInput[]
    connect?: usersActivitiesWhereUniqueInput | usersActivitiesWhereUniqueInput[]
    update?: usersActivitiesUpdateWithWhereUniqueWithoutUsersInput | usersActivitiesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: usersActivitiesUpdateManyWithWhereWithoutUsersInput | usersActivitiesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: usersActivitiesScalarWhereInput | usersActivitiesScalarWhereInput[]
  }

  export type orderUpdateManyWithoutCreateByNestedInput = {
    create?: XOR<orderCreateWithoutCreateByInput, orderUncheckedCreateWithoutCreateByInput> | orderCreateWithoutCreateByInput[] | orderUncheckedCreateWithoutCreateByInput[]
    connectOrCreate?: orderCreateOrConnectWithoutCreateByInput | orderCreateOrConnectWithoutCreateByInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutCreateByInput | orderUpsertWithWhereUniqueWithoutCreateByInput[]
    createMany?: orderCreateManyCreateByInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutCreateByInput | orderUpdateWithWhereUniqueWithoutCreateByInput[]
    updateMany?: orderUpdateManyWithWhereWithoutCreateByInput | orderUpdateManyWithWhereWithoutCreateByInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type orderPersonalUpdateManyWithoutSenderUserNestedInput = {
    create?: XOR<orderPersonalCreateWithoutSenderUserInput, orderPersonalUncheckedCreateWithoutSenderUserInput> | orderPersonalCreateWithoutSenderUserInput[] | orderPersonalUncheckedCreateWithoutSenderUserInput[]
    connectOrCreate?: orderPersonalCreateOrConnectWithoutSenderUserInput | orderPersonalCreateOrConnectWithoutSenderUserInput[]
    upsert?: orderPersonalUpsertWithWhereUniqueWithoutSenderUserInput | orderPersonalUpsertWithWhereUniqueWithoutSenderUserInput[]
    createMany?: orderPersonalCreateManySenderUserInputEnvelope
    set?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
    disconnect?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
    delete?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
    connect?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
    update?: orderPersonalUpdateWithWhereUniqueWithoutSenderUserInput | orderPersonalUpdateWithWhereUniqueWithoutSenderUserInput[]
    updateMany?: orderPersonalUpdateManyWithWhereWithoutSenderUserInput | orderPersonalUpdateManyWithWhereWithoutSenderUserInput[]
    deleteMany?: orderPersonalScalarWhereInput | orderPersonalScalarWhereInput[]
  }

  export type orderPersonalUpdateManyWithoutRecipientUserNestedInput = {
    create?: XOR<orderPersonalCreateWithoutRecipientUserInput, orderPersonalUncheckedCreateWithoutRecipientUserInput> | orderPersonalCreateWithoutRecipientUserInput[] | orderPersonalUncheckedCreateWithoutRecipientUserInput[]
    connectOrCreate?: orderPersonalCreateOrConnectWithoutRecipientUserInput | orderPersonalCreateOrConnectWithoutRecipientUserInput[]
    upsert?: orderPersonalUpsertWithWhereUniqueWithoutRecipientUserInput | orderPersonalUpsertWithWhereUniqueWithoutRecipientUserInput[]
    createMany?: orderPersonalCreateManyRecipientUserInputEnvelope
    set?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
    disconnect?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
    delete?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
    connect?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
    update?: orderPersonalUpdateWithWhereUniqueWithoutRecipientUserInput | orderPersonalUpdateWithWhereUniqueWithoutRecipientUserInput[]
    updateMany?: orderPersonalUpdateManyWithWhereWithoutRecipientUserInput | orderPersonalUpdateManyWithWhereWithoutRecipientUserInput[]
    deleteMany?: orderPersonalScalarWhereInput | orderPersonalScalarWhereInput[]
  }

  export type walletUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<walletCreateWithoutUserInput, walletUncheckedCreateWithoutUserInput> | walletCreateWithoutUserInput[] | walletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: walletCreateOrConnectWithoutUserInput | walletCreateOrConnectWithoutUserInput[]
    upsert?: walletUpsertWithWhereUniqueWithoutUserInput | walletUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: walletCreateManyUserInputEnvelope
    set?: walletWhereUniqueInput | walletWhereUniqueInput[]
    disconnect?: walletWhereUniqueInput | walletWhereUniqueInput[]
    delete?: walletWhereUniqueInput | walletWhereUniqueInput[]
    connect?: walletWhereUniqueInput | walletWhereUniqueInput[]
    update?: walletUpdateWithWhereUniqueWithoutUserInput | walletUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: walletUpdateManyWithWhereWithoutUserInput | walletUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: walletScalarWhereInput | walletScalarWhereInput[]
  }

  export type orderPaymentUncheckedUpdateManyWithoutPaidToNestedInput = {
    create?: XOR<orderPaymentCreateWithoutPaidToInput, orderPaymentUncheckedCreateWithoutPaidToInput> | orderPaymentCreateWithoutPaidToInput[] | orderPaymentUncheckedCreateWithoutPaidToInput[]
    connectOrCreate?: orderPaymentCreateOrConnectWithoutPaidToInput | orderPaymentCreateOrConnectWithoutPaidToInput[]
    upsert?: orderPaymentUpsertWithWhereUniqueWithoutPaidToInput | orderPaymentUpsertWithWhereUniqueWithoutPaidToInput[]
    createMany?: orderPaymentCreateManyPaidToInputEnvelope
    set?: orderPaymentWhereUniqueInput | orderPaymentWhereUniqueInput[]
    disconnect?: orderPaymentWhereUniqueInput | orderPaymentWhereUniqueInput[]
    delete?: orderPaymentWhereUniqueInput | orderPaymentWhereUniqueInput[]
    connect?: orderPaymentWhereUniqueInput | orderPaymentWhereUniqueInput[]
    update?: orderPaymentUpdateWithWhereUniqueWithoutPaidToInput | orderPaymentUpdateWithWhereUniqueWithoutPaidToInput[]
    updateMany?: orderPaymentUpdateManyWithWhereWithoutPaidToInput | orderPaymentUpdateManyWithWhereWithoutPaidToInput[]
    deleteMany?: orderPaymentScalarWhereInput | orderPaymentScalarWhereInput[]
  }

  export type profileUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<profileCreateWithoutAdminInput, profileUncheckedCreateWithoutAdminInput> | profileCreateWithoutAdminInput[] | profileUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: profileCreateOrConnectWithoutAdminInput | profileCreateOrConnectWithoutAdminInput[]
    upsert?: profileUpsertWithWhereUniqueWithoutAdminInput | profileUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: profileCreateManyAdminInputEnvelope
    set?: profileWhereUniqueInput | profileWhereUniqueInput[]
    disconnect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    delete?: profileWhereUniqueInput | profileWhereUniqueInput[]
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    update?: profileUpdateWithWhereUniqueWithoutAdminInput | profileUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: profileUpdateManyWithWhereWithoutAdminInput | profileUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: profileScalarWhereInput | profileScalarWhereInput[]
  }

  export type profileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    upsert?: profileUpsertWithoutUserInput
    disconnect?: profileWhereInput | boolean
    delete?: profileWhereInput | boolean
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutUserInput, profileUpdateWithoutUserInput>, profileUncheckedUpdateWithoutUserInput>
  }

  export type otpUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<otpCreateWithoutUsersInput, otpUncheckedCreateWithoutUsersInput> | otpCreateWithoutUsersInput[] | otpUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: otpCreateOrConnectWithoutUsersInput | otpCreateOrConnectWithoutUsersInput[]
    upsert?: otpUpsertWithWhereUniqueWithoutUsersInput | otpUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: otpCreateManyUsersInputEnvelope
    set?: otpWhereUniqueInput | otpWhereUniqueInput[]
    disconnect?: otpWhereUniqueInput | otpWhereUniqueInput[]
    delete?: otpWhereUniqueInput | otpWhereUniqueInput[]
    connect?: otpWhereUniqueInput | otpWhereUniqueInput[]
    update?: otpUpdateWithWhereUniqueWithoutUsersInput | otpUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: otpUpdateManyWithWhereWithoutUsersInput | otpUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: otpScalarWhereInput | otpScalarWhereInput[]
  }

  export type usersRolesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<usersRolesCreateWithoutUsersInput, usersRolesUncheckedCreateWithoutUsersInput> | usersRolesCreateWithoutUsersInput[] | usersRolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usersRolesCreateOrConnectWithoutUsersInput | usersRolesCreateOrConnectWithoutUsersInput[]
    upsert?: usersRolesUpsertWithWhereUniqueWithoutUsersInput | usersRolesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: usersRolesCreateManyUsersInputEnvelope
    set?: usersRolesWhereUniqueInput | usersRolesWhereUniqueInput[]
    disconnect?: usersRolesWhereUniqueInput | usersRolesWhereUniqueInput[]
    delete?: usersRolesWhereUniqueInput | usersRolesWhereUniqueInput[]
    connect?: usersRolesWhereUniqueInput | usersRolesWhereUniqueInput[]
    update?: usersRolesUpdateWithWhereUniqueWithoutUsersInput | usersRolesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: usersRolesUpdateManyWithWhereWithoutUsersInput | usersRolesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: usersRolesScalarWhereInput | usersRolesScalarWhereInput[]
  }

  export type forgotPasswordUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<forgotPasswordCreateWithoutUsersInput, forgotPasswordUncheckedCreateWithoutUsersInput> | forgotPasswordCreateWithoutUsersInput[] | forgotPasswordUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: forgotPasswordCreateOrConnectWithoutUsersInput | forgotPasswordCreateOrConnectWithoutUsersInput[]
    upsert?: forgotPasswordUpsertWithWhereUniqueWithoutUsersInput | forgotPasswordUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: forgotPasswordCreateManyUsersInputEnvelope
    set?: forgotPasswordWhereUniqueInput | forgotPasswordWhereUniqueInput[]
    disconnect?: forgotPasswordWhereUniqueInput | forgotPasswordWhereUniqueInput[]
    delete?: forgotPasswordWhereUniqueInput | forgotPasswordWhereUniqueInput[]
    connect?: forgotPasswordWhereUniqueInput | forgotPasswordWhereUniqueInput[]
    update?: forgotPasswordUpdateWithWhereUniqueWithoutUsersInput | forgotPasswordUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: forgotPasswordUpdateManyWithWhereWithoutUsersInput | forgotPasswordUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: forgotPasswordScalarWhereInput | forgotPasswordScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsersInput | notificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsersInput | notificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsersInput | notificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type usersActivitiesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<usersActivitiesCreateWithoutUsersInput, usersActivitiesUncheckedCreateWithoutUsersInput> | usersActivitiesCreateWithoutUsersInput[] | usersActivitiesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usersActivitiesCreateOrConnectWithoutUsersInput | usersActivitiesCreateOrConnectWithoutUsersInput[]
    upsert?: usersActivitiesUpsertWithWhereUniqueWithoutUsersInput | usersActivitiesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: usersActivitiesCreateManyUsersInputEnvelope
    set?: usersActivitiesWhereUniqueInput | usersActivitiesWhereUniqueInput[]
    disconnect?: usersActivitiesWhereUniqueInput | usersActivitiesWhereUniqueInput[]
    delete?: usersActivitiesWhereUniqueInput | usersActivitiesWhereUniqueInput[]
    connect?: usersActivitiesWhereUniqueInput | usersActivitiesWhereUniqueInput[]
    update?: usersActivitiesUpdateWithWhereUniqueWithoutUsersInput | usersActivitiesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: usersActivitiesUpdateManyWithWhereWithoutUsersInput | usersActivitiesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: usersActivitiesScalarWhereInput | usersActivitiesScalarWhereInput[]
  }

  export type orderUncheckedUpdateManyWithoutCreateByNestedInput = {
    create?: XOR<orderCreateWithoutCreateByInput, orderUncheckedCreateWithoutCreateByInput> | orderCreateWithoutCreateByInput[] | orderUncheckedCreateWithoutCreateByInput[]
    connectOrCreate?: orderCreateOrConnectWithoutCreateByInput | orderCreateOrConnectWithoutCreateByInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutCreateByInput | orderUpsertWithWhereUniqueWithoutCreateByInput[]
    createMany?: orderCreateManyCreateByInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutCreateByInput | orderUpdateWithWhereUniqueWithoutCreateByInput[]
    updateMany?: orderUpdateManyWithWhereWithoutCreateByInput | orderUpdateManyWithWhereWithoutCreateByInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type orderPersonalUncheckedUpdateManyWithoutSenderUserNestedInput = {
    create?: XOR<orderPersonalCreateWithoutSenderUserInput, orderPersonalUncheckedCreateWithoutSenderUserInput> | orderPersonalCreateWithoutSenderUserInput[] | orderPersonalUncheckedCreateWithoutSenderUserInput[]
    connectOrCreate?: orderPersonalCreateOrConnectWithoutSenderUserInput | orderPersonalCreateOrConnectWithoutSenderUserInput[]
    upsert?: orderPersonalUpsertWithWhereUniqueWithoutSenderUserInput | orderPersonalUpsertWithWhereUniqueWithoutSenderUserInput[]
    createMany?: orderPersonalCreateManySenderUserInputEnvelope
    set?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
    disconnect?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
    delete?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
    connect?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
    update?: orderPersonalUpdateWithWhereUniqueWithoutSenderUserInput | orderPersonalUpdateWithWhereUniqueWithoutSenderUserInput[]
    updateMany?: orderPersonalUpdateManyWithWhereWithoutSenderUserInput | orderPersonalUpdateManyWithWhereWithoutSenderUserInput[]
    deleteMany?: orderPersonalScalarWhereInput | orderPersonalScalarWhereInput[]
  }

  export type orderPersonalUncheckedUpdateManyWithoutRecipientUserNestedInput = {
    create?: XOR<orderPersonalCreateWithoutRecipientUserInput, orderPersonalUncheckedCreateWithoutRecipientUserInput> | orderPersonalCreateWithoutRecipientUserInput[] | orderPersonalUncheckedCreateWithoutRecipientUserInput[]
    connectOrCreate?: orderPersonalCreateOrConnectWithoutRecipientUserInput | orderPersonalCreateOrConnectWithoutRecipientUserInput[]
    upsert?: orderPersonalUpsertWithWhereUniqueWithoutRecipientUserInput | orderPersonalUpsertWithWhereUniqueWithoutRecipientUserInput[]
    createMany?: orderPersonalCreateManyRecipientUserInputEnvelope
    set?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
    disconnect?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
    delete?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
    connect?: orderPersonalWhereUniqueInput | orderPersonalWhereUniqueInput[]
    update?: orderPersonalUpdateWithWhereUniqueWithoutRecipientUserInput | orderPersonalUpdateWithWhereUniqueWithoutRecipientUserInput[]
    updateMany?: orderPersonalUpdateManyWithWhereWithoutRecipientUserInput | orderPersonalUpdateManyWithWhereWithoutRecipientUserInput[]
    deleteMany?: orderPersonalScalarWhereInput | orderPersonalScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutUserProfileInput = {
    create?: XOR<usersCreateWithoutUserProfileInput, usersUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserProfileInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutAdminProfileInput = {
    create?: XOR<usersCreateWithoutAdminProfileInput, usersUncheckedCreateWithoutAdminProfileInput>
    connectOrCreate?: usersCreateOrConnectWithoutAdminProfileInput
    connect?: usersWhereUniqueInput
  }

  export type addressCreateNestedManyWithoutProfileInput = {
    create?: XOR<addressCreateWithoutProfileInput, addressUncheckedCreateWithoutProfileInput> | addressCreateWithoutProfileInput[] | addressUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: addressCreateOrConnectWithoutProfileInput | addressCreateOrConnectWithoutProfileInput[]
    createMany?: addressCreateManyProfileInputEnvelope
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
  }

  export type addressUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<addressCreateWithoutProfileInput, addressUncheckedCreateWithoutProfileInput> | addressCreateWithoutProfileInput[] | addressUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: addressCreateOrConnectWithoutProfileInput | addressCreateOrConnectWithoutProfileInput[]
    createMany?: addressCreateManyProfileInputEnvelope
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
  }

  export type usersUpdateOneWithoutUserProfileNestedInput = {
    create?: XOR<usersCreateWithoutUserProfileInput, usersUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserProfileInput
    upsert?: usersUpsertWithoutUserProfileInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUserProfileInput, usersUpdateWithoutUserProfileInput>, usersUncheckedUpdateWithoutUserProfileInput>
  }

  export type usersUpdateOneWithoutAdminProfileNestedInput = {
    create?: XOR<usersCreateWithoutAdminProfileInput, usersUncheckedCreateWithoutAdminProfileInput>
    connectOrCreate?: usersCreateOrConnectWithoutAdminProfileInput
    upsert?: usersUpsertWithoutAdminProfileInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAdminProfileInput, usersUpdateWithoutAdminProfileInput>, usersUncheckedUpdateWithoutAdminProfileInput>
  }

  export type addressUpdateManyWithoutProfileNestedInput = {
    create?: XOR<addressCreateWithoutProfileInput, addressUncheckedCreateWithoutProfileInput> | addressCreateWithoutProfileInput[] | addressUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: addressCreateOrConnectWithoutProfileInput | addressCreateOrConnectWithoutProfileInput[]
    upsert?: addressUpsertWithWhereUniqueWithoutProfileInput | addressUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: addressCreateManyProfileInputEnvelope
    set?: addressWhereUniqueInput | addressWhereUniqueInput[]
    disconnect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    delete?: addressWhereUniqueInput | addressWhereUniqueInput[]
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    update?: addressUpdateWithWhereUniqueWithoutProfileInput | addressUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: addressUpdateManyWithWhereWithoutProfileInput | addressUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: addressScalarWhereInput | addressScalarWhereInput[]
  }

  export type addressUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<addressCreateWithoutProfileInput, addressUncheckedCreateWithoutProfileInput> | addressCreateWithoutProfileInput[] | addressUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: addressCreateOrConnectWithoutProfileInput | addressCreateOrConnectWithoutProfileInput[]
    upsert?: addressUpsertWithWhereUniqueWithoutProfileInput | addressUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: addressCreateManyProfileInputEnvelope
    set?: addressWhereUniqueInput | addressWhereUniqueInput[]
    disconnect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    delete?: addressWhereUniqueInput | addressWhereUniqueInput[]
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    update?: addressUpdateWithWhereUniqueWithoutProfileInput | addressUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: addressUpdateManyWithWhereWithoutProfileInput | addressUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: addressScalarWhereInput | addressScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutOTPInput = {
    create?: XOR<usersCreateWithoutOTPInput, usersUncheckedCreateWithoutOTPInput>
    connectOrCreate?: usersCreateOrConnectWithoutOTPInput
    connect?: usersWhereUniqueInput
  }

  export type branchesCreateNestedOneWithoutOtpInput = {
    create?: XOR<branchesCreateWithoutOtpInput, branchesUncheckedCreateWithoutOtpInput>
    connectOrCreate?: branchesCreateOrConnectWithoutOtpInput
    connect?: branchesWhereUniqueInput
  }

  export type usersUpdateOneWithoutOTPNestedInput = {
    create?: XOR<usersCreateWithoutOTPInput, usersUncheckedCreateWithoutOTPInput>
    connectOrCreate?: usersCreateOrConnectWithoutOTPInput
    upsert?: usersUpsertWithoutOTPInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutOTPInput, usersUpdateWithoutOTPInput>, usersUncheckedUpdateWithoutOTPInput>
  }

  export type branchesUpdateOneWithoutOtpNestedInput = {
    create?: XOR<branchesCreateWithoutOtpInput, branchesUncheckedCreateWithoutOtpInput>
    connectOrCreate?: branchesCreateOrConnectWithoutOtpInput
    upsert?: branchesUpsertWithoutOtpInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutOtpInput, branchesUpdateWithoutOtpInput>, branchesUncheckedUpdateWithoutOtpInput>
  }

  export type usersCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationsInput
    connect?: usersWhereUniqueInput
  }

  export type branchesCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<branchesCreateWithoutNotificationsInput, branchesUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: branchesCreateOrConnectWithoutNotificationsInput
    connect?: branchesWhereUniqueInput
  }

  export type usersUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationsInput
    upsert?: usersUpsertWithoutNotificationsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotificationsInput, usersUpdateWithoutNotificationsInput>, usersUncheckedUpdateWithoutNotificationsInput>
  }

  export type branchesUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<branchesCreateWithoutNotificationsInput, branchesUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: branchesCreateOrConnectWithoutNotificationsInput
    upsert?: branchesUpsertWithoutNotificationsInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutNotificationsInput, branchesUpdateWithoutNotificationsInput>, branchesUncheckedUpdateWithoutNotificationsInput>
  }

  export type usersCreateNestedOneWithoutForgotInput = {
    create?: XOR<usersCreateWithoutForgotInput, usersUncheckedCreateWithoutForgotInput>
    connectOrCreate?: usersCreateOrConnectWithoutForgotInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutForgotNestedInput = {
    create?: XOR<usersCreateWithoutForgotInput, usersUncheckedCreateWithoutForgotInput>
    connectOrCreate?: usersCreateOrConnectWithoutForgotInput
    upsert?: usersUpsertWithoutForgotInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutForgotInput, usersUpdateWithoutForgotInput>, usersUncheckedUpdateWithoutForgotInput>
  }

  export type usersCreateNestedOneWithoutRolesInput = {
    create?: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput>
    connectOrCreate?: usersCreateOrConnectWithoutRolesInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutRolesNestedInput = {
    create?: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput>
    connectOrCreate?: usersCreateOrConnectWithoutRolesInput
    upsert?: usersUpsertWithoutRolesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutRolesInput, usersUpdateWithoutRolesInput>, usersUncheckedUpdateWithoutRolesInput>
  }

  export type usersCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<usersCreateWithoutActivitiesInput, usersUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: usersCreateOrConnectWithoutActivitiesInput
    connect?: usersWhereUniqueInput
  }

  export type orderThreadingCreateNestedOneWithoutActivitieInput = {
    create?: XOR<orderThreadingCreateWithoutActivitieInput, orderThreadingUncheckedCreateWithoutActivitieInput>
    connectOrCreate?: orderThreadingCreateOrConnectWithoutActivitieInput
    connect?: orderThreadingWhereUniqueInput
  }

  export type orderThreadingUncheckedCreateNestedOneWithoutActivitieInput = {
    create?: XOR<orderThreadingCreateWithoutActivitieInput, orderThreadingUncheckedCreateWithoutActivitieInput>
    connectOrCreate?: orderThreadingCreateOrConnectWithoutActivitieInput
    connect?: orderThreadingWhereUniqueInput
  }

  export type usersUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<usersCreateWithoutActivitiesInput, usersUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: usersCreateOrConnectWithoutActivitiesInput
    upsert?: usersUpsertWithoutActivitiesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutActivitiesInput, usersUpdateWithoutActivitiesInput>, usersUncheckedUpdateWithoutActivitiesInput>
  }

  export type orderThreadingUpdateOneWithoutActivitieNestedInput = {
    create?: XOR<orderThreadingCreateWithoutActivitieInput, orderThreadingUncheckedCreateWithoutActivitieInput>
    connectOrCreate?: orderThreadingCreateOrConnectWithoutActivitieInput
    upsert?: orderThreadingUpsertWithoutActivitieInput
    disconnect?: orderThreadingWhereInput | boolean
    delete?: orderThreadingWhereInput | boolean
    connect?: orderThreadingWhereUniqueInput
    update?: XOR<XOR<orderThreadingUpdateToOneWithWhereWithoutActivitieInput, orderThreadingUpdateWithoutActivitieInput>, orderThreadingUncheckedUpdateWithoutActivitieInput>
  }

  export type orderThreadingUncheckedUpdateOneWithoutActivitieNestedInput = {
    create?: XOR<orderThreadingCreateWithoutActivitieInput, orderThreadingUncheckedCreateWithoutActivitieInput>
    connectOrCreate?: orderThreadingCreateOrConnectWithoutActivitieInput
    upsert?: orderThreadingUpsertWithoutActivitieInput
    disconnect?: orderThreadingWhereInput | boolean
    delete?: orderThreadingWhereInput | boolean
    connect?: orderThreadingWhereUniqueInput
    update?: XOR<XOR<orderThreadingUpdateToOneWithWhereWithoutActivitieInput, orderThreadingUpdateWithoutActivitieInput>, orderThreadingUncheckedUpdateWithoutActivitieInput>
  }

  export type branchesCreateNestedOneWithoutOrderCategoryInput = {
    create?: XOR<branchesCreateWithoutOrderCategoryInput, branchesUncheckedCreateWithoutOrderCategoryInput>
    connectOrCreate?: branchesCreateOrConnectWithoutOrderCategoryInput
    connect?: branchesWhereUniqueInput
  }

  export type orderCreateNestedManyWithoutCategoryInput = {
    create?: XOR<orderCreateWithoutCategoryInput, orderUncheckedCreateWithoutCategoryInput> | orderCreateWithoutCategoryInput[] | orderUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: orderCreateOrConnectWithoutCategoryInput | orderCreateOrConnectWithoutCategoryInput[]
    createMany?: orderCreateManyCategoryInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type orderUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<orderCreateWithoutCategoryInput, orderUncheckedCreateWithoutCategoryInput> | orderCreateWithoutCategoryInput[] | orderUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: orderCreateOrConnectWithoutCategoryInput | orderCreateOrConnectWithoutCategoryInput[]
    createMany?: orderCreateManyCategoryInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type branchesUpdateOneWithoutOrderCategoryNestedInput = {
    create?: XOR<branchesCreateWithoutOrderCategoryInput, branchesUncheckedCreateWithoutOrderCategoryInput>
    connectOrCreate?: branchesCreateOrConnectWithoutOrderCategoryInput
    upsert?: branchesUpsertWithoutOrderCategoryInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutOrderCategoryInput, branchesUpdateWithoutOrderCategoryInput>, branchesUncheckedUpdateWithoutOrderCategoryInput>
  }

  export type orderUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<orderCreateWithoutCategoryInput, orderUncheckedCreateWithoutCategoryInput> | orderCreateWithoutCategoryInput[] | orderUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: orderCreateOrConnectWithoutCategoryInput | orderCreateOrConnectWithoutCategoryInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutCategoryInput | orderUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: orderCreateManyCategoryInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutCategoryInput | orderUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: orderUpdateManyWithWhereWithoutCategoryInput | orderUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type orderUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<orderCreateWithoutCategoryInput, orderUncheckedCreateWithoutCategoryInput> | orderCreateWithoutCategoryInput[] | orderUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: orderCreateOrConnectWithoutCategoryInput | orderCreateOrConnectWithoutCategoryInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutCategoryInput | orderUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: orderCreateManyCategoryInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutCategoryInput | orderUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: orderUpdateManyWithWhereWithoutCategoryInput | orderUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type orderCategoryCreateNestedOneWithoutOrderInput = {
    create?: XOR<orderCategoryCreateWithoutOrderInput, orderCategoryUncheckedCreateWithoutOrderInput>
    connectOrCreate?: orderCategoryCreateOrConnectWithoutOrderInput
    connect?: orderCategoryWhereUniqueInput
  }

  export type orderPersonalCreateNestedOneWithoutOrderInput = {
    create?: XOR<orderPersonalCreateWithoutOrderInput, orderPersonalUncheckedCreateWithoutOrderInput>
    connectOrCreate?: orderPersonalCreateOrConnectWithoutOrderInput
    connect?: orderPersonalWhereUniqueInput
  }

  export type orderDetailsCreateNestedOneWithoutOrderInput = {
    create?: XOR<orderDetailsCreateWithoutOrderInput, orderDetailsUncheckedCreateWithoutOrderInput>
    connectOrCreate?: orderDetailsCreateOrConnectWithoutOrderInput
    connect?: orderDetailsWhereUniqueInput
  }

  export type orderPaymentCreateNestedOneWithoutOrderInput = {
    create?: XOR<orderPaymentCreateWithoutOrderInput, orderPaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: orderPaymentCreateOrConnectWithoutOrderInput
    connect?: orderPaymentWhereUniqueInput
  }

  export type branchesCreateNestedOneWithoutOrderInput = {
    create?: XOR<branchesCreateWithoutOrderInput, branchesUncheckedCreateWithoutOrderInput>
    connectOrCreate?: branchesCreateOrConnectWithoutOrderInput
    connect?: branchesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutOrderInput = {
    create?: XOR<usersCreateWithoutOrderInput, usersUncheckedCreateWithoutOrderInput>
    connectOrCreate?: usersCreateOrConnectWithoutOrderInput
    connect?: usersWhereUniqueInput
  }

  export type orderTackingCreateNestedManyWithoutOrderInput = {
    create?: XOR<orderTackingCreateWithoutOrderInput, orderTackingUncheckedCreateWithoutOrderInput> | orderTackingCreateWithoutOrderInput[] | orderTackingUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: orderTackingCreateOrConnectWithoutOrderInput | orderTackingCreateOrConnectWithoutOrderInput[]
    createMany?: orderTackingCreateManyOrderInputEnvelope
    connect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
  }

  export type orderThreadingCreateNestedManyWithoutOrderInput = {
    create?: XOR<orderThreadingCreateWithoutOrderInput, orderThreadingUncheckedCreateWithoutOrderInput> | orderThreadingCreateWithoutOrderInput[] | orderThreadingUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: orderThreadingCreateOrConnectWithoutOrderInput | orderThreadingCreateOrConnectWithoutOrderInput[]
    createMany?: orderThreadingCreateManyOrderInputEnvelope
    connect?: orderThreadingWhereUniqueInput | orderThreadingWhereUniqueInput[]
  }

  export type orderPersonalUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<orderPersonalCreateWithoutOrderInput, orderPersonalUncheckedCreateWithoutOrderInput>
    connectOrCreate?: orderPersonalCreateOrConnectWithoutOrderInput
    connect?: orderPersonalWhereUniqueInput
  }

  export type orderDetailsUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<orderDetailsCreateWithoutOrderInput, orderDetailsUncheckedCreateWithoutOrderInput>
    connectOrCreate?: orderDetailsCreateOrConnectWithoutOrderInput
    connect?: orderDetailsWhereUniqueInput
  }

  export type orderPaymentUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<orderPaymentCreateWithoutOrderInput, orderPaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: orderPaymentCreateOrConnectWithoutOrderInput
    connect?: orderPaymentWhereUniqueInput
  }

  export type orderTackingUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<orderTackingCreateWithoutOrderInput, orderTackingUncheckedCreateWithoutOrderInput> | orderTackingCreateWithoutOrderInput[] | orderTackingUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: orderTackingCreateOrConnectWithoutOrderInput | orderTackingCreateOrConnectWithoutOrderInput[]
    createMany?: orderTackingCreateManyOrderInputEnvelope
    connect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
  }

  export type orderThreadingUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<orderThreadingCreateWithoutOrderInput, orderThreadingUncheckedCreateWithoutOrderInput> | orderThreadingCreateWithoutOrderInput[] | orderThreadingUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: orderThreadingCreateOrConnectWithoutOrderInput | orderThreadingCreateOrConnectWithoutOrderInput[]
    createMany?: orderThreadingCreateManyOrderInputEnvelope
    connect?: orderThreadingWhereUniqueInput | orderThreadingWhereUniqueInput[]
  }

  export type orderCategoryUpdateOneWithoutOrderNestedInput = {
    create?: XOR<orderCategoryCreateWithoutOrderInput, orderCategoryUncheckedCreateWithoutOrderInput>
    connectOrCreate?: orderCategoryCreateOrConnectWithoutOrderInput
    upsert?: orderCategoryUpsertWithoutOrderInput
    disconnect?: orderCategoryWhereInput | boolean
    delete?: orderCategoryWhereInput | boolean
    connect?: orderCategoryWhereUniqueInput
    update?: XOR<XOR<orderCategoryUpdateToOneWithWhereWithoutOrderInput, orderCategoryUpdateWithoutOrderInput>, orderCategoryUncheckedUpdateWithoutOrderInput>
  }

  export type orderPersonalUpdateOneWithoutOrderNestedInput = {
    create?: XOR<orderPersonalCreateWithoutOrderInput, orderPersonalUncheckedCreateWithoutOrderInput>
    connectOrCreate?: orderPersonalCreateOrConnectWithoutOrderInput
    upsert?: orderPersonalUpsertWithoutOrderInput
    disconnect?: orderPersonalWhereInput | boolean
    delete?: orderPersonalWhereInput | boolean
    connect?: orderPersonalWhereUniqueInput
    update?: XOR<XOR<orderPersonalUpdateToOneWithWhereWithoutOrderInput, orderPersonalUpdateWithoutOrderInput>, orderPersonalUncheckedUpdateWithoutOrderInput>
  }

  export type orderDetailsUpdateOneWithoutOrderNestedInput = {
    create?: XOR<orderDetailsCreateWithoutOrderInput, orderDetailsUncheckedCreateWithoutOrderInput>
    connectOrCreate?: orderDetailsCreateOrConnectWithoutOrderInput
    upsert?: orderDetailsUpsertWithoutOrderInput
    disconnect?: orderDetailsWhereInput | boolean
    delete?: orderDetailsWhereInput | boolean
    connect?: orderDetailsWhereUniqueInput
    update?: XOR<XOR<orderDetailsUpdateToOneWithWhereWithoutOrderInput, orderDetailsUpdateWithoutOrderInput>, orderDetailsUncheckedUpdateWithoutOrderInput>
  }

  export type orderPaymentUpdateOneWithoutOrderNestedInput = {
    create?: XOR<orderPaymentCreateWithoutOrderInput, orderPaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: orderPaymentCreateOrConnectWithoutOrderInput
    upsert?: orderPaymentUpsertWithoutOrderInput
    disconnect?: orderPaymentWhereInput | boolean
    delete?: orderPaymentWhereInput | boolean
    connect?: orderPaymentWhereUniqueInput
    update?: XOR<XOR<orderPaymentUpdateToOneWithWhereWithoutOrderInput, orderPaymentUpdateWithoutOrderInput>, orderPaymentUncheckedUpdateWithoutOrderInput>
  }

  export type branchesUpdateOneWithoutOrderNestedInput = {
    create?: XOR<branchesCreateWithoutOrderInput, branchesUncheckedCreateWithoutOrderInput>
    connectOrCreate?: branchesCreateOrConnectWithoutOrderInput
    upsert?: branchesUpsertWithoutOrderInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutOrderInput, branchesUpdateWithoutOrderInput>, branchesUncheckedUpdateWithoutOrderInput>
  }

  export type usersUpdateOneWithoutOrderNestedInput = {
    create?: XOR<usersCreateWithoutOrderInput, usersUncheckedCreateWithoutOrderInput>
    connectOrCreate?: usersCreateOrConnectWithoutOrderInput
    upsert?: usersUpsertWithoutOrderInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutOrderInput, usersUpdateWithoutOrderInput>, usersUncheckedUpdateWithoutOrderInput>
  }

  export type orderTackingUpdateManyWithoutOrderNestedInput = {
    create?: XOR<orderTackingCreateWithoutOrderInput, orderTackingUncheckedCreateWithoutOrderInput> | orderTackingCreateWithoutOrderInput[] | orderTackingUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: orderTackingCreateOrConnectWithoutOrderInput | orderTackingCreateOrConnectWithoutOrderInput[]
    upsert?: orderTackingUpsertWithWhereUniqueWithoutOrderInput | orderTackingUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: orderTackingCreateManyOrderInputEnvelope
    set?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    disconnect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    delete?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    connect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    update?: orderTackingUpdateWithWhereUniqueWithoutOrderInput | orderTackingUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: orderTackingUpdateManyWithWhereWithoutOrderInput | orderTackingUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: orderTackingScalarWhereInput | orderTackingScalarWhereInput[]
  }

  export type orderThreadingUpdateManyWithoutOrderNestedInput = {
    create?: XOR<orderThreadingCreateWithoutOrderInput, orderThreadingUncheckedCreateWithoutOrderInput> | orderThreadingCreateWithoutOrderInput[] | orderThreadingUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: orderThreadingCreateOrConnectWithoutOrderInput | orderThreadingCreateOrConnectWithoutOrderInput[]
    upsert?: orderThreadingUpsertWithWhereUniqueWithoutOrderInput | orderThreadingUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: orderThreadingCreateManyOrderInputEnvelope
    set?: orderThreadingWhereUniqueInput | orderThreadingWhereUniqueInput[]
    disconnect?: orderThreadingWhereUniqueInput | orderThreadingWhereUniqueInput[]
    delete?: orderThreadingWhereUniqueInput | orderThreadingWhereUniqueInput[]
    connect?: orderThreadingWhereUniqueInput | orderThreadingWhereUniqueInput[]
    update?: orderThreadingUpdateWithWhereUniqueWithoutOrderInput | orderThreadingUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: orderThreadingUpdateManyWithWhereWithoutOrderInput | orderThreadingUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: orderThreadingScalarWhereInput | orderThreadingScalarWhereInput[]
  }

  export type orderPersonalUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<orderPersonalCreateWithoutOrderInput, orderPersonalUncheckedCreateWithoutOrderInput>
    connectOrCreate?: orderPersonalCreateOrConnectWithoutOrderInput
    upsert?: orderPersonalUpsertWithoutOrderInput
    disconnect?: orderPersonalWhereInput | boolean
    delete?: orderPersonalWhereInput | boolean
    connect?: orderPersonalWhereUniqueInput
    update?: XOR<XOR<orderPersonalUpdateToOneWithWhereWithoutOrderInput, orderPersonalUpdateWithoutOrderInput>, orderPersonalUncheckedUpdateWithoutOrderInput>
  }

  export type orderDetailsUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<orderDetailsCreateWithoutOrderInput, orderDetailsUncheckedCreateWithoutOrderInput>
    connectOrCreate?: orderDetailsCreateOrConnectWithoutOrderInput
    upsert?: orderDetailsUpsertWithoutOrderInput
    disconnect?: orderDetailsWhereInput | boolean
    delete?: orderDetailsWhereInput | boolean
    connect?: orderDetailsWhereUniqueInput
    update?: XOR<XOR<orderDetailsUpdateToOneWithWhereWithoutOrderInput, orderDetailsUpdateWithoutOrderInput>, orderDetailsUncheckedUpdateWithoutOrderInput>
  }

  export type orderPaymentUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<orderPaymentCreateWithoutOrderInput, orderPaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: orderPaymentCreateOrConnectWithoutOrderInput
    upsert?: orderPaymentUpsertWithoutOrderInput
    disconnect?: orderPaymentWhereInput | boolean
    delete?: orderPaymentWhereInput | boolean
    connect?: orderPaymentWhereUniqueInput
    update?: XOR<XOR<orderPaymentUpdateToOneWithWhereWithoutOrderInput, orderPaymentUpdateWithoutOrderInput>, orderPaymentUncheckedUpdateWithoutOrderInput>
  }

  export type orderTackingUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<orderTackingCreateWithoutOrderInput, orderTackingUncheckedCreateWithoutOrderInput> | orderTackingCreateWithoutOrderInput[] | orderTackingUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: orderTackingCreateOrConnectWithoutOrderInput | orderTackingCreateOrConnectWithoutOrderInput[]
    upsert?: orderTackingUpsertWithWhereUniqueWithoutOrderInput | orderTackingUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: orderTackingCreateManyOrderInputEnvelope
    set?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    disconnect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    delete?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    connect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    update?: orderTackingUpdateWithWhereUniqueWithoutOrderInput | orderTackingUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: orderTackingUpdateManyWithWhereWithoutOrderInput | orderTackingUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: orderTackingScalarWhereInput | orderTackingScalarWhereInput[]
  }

  export type orderThreadingUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<orderThreadingCreateWithoutOrderInput, orderThreadingUncheckedCreateWithoutOrderInput> | orderThreadingCreateWithoutOrderInput[] | orderThreadingUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: orderThreadingCreateOrConnectWithoutOrderInput | orderThreadingCreateOrConnectWithoutOrderInput[]
    upsert?: orderThreadingUpsertWithWhereUniqueWithoutOrderInput | orderThreadingUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: orderThreadingCreateManyOrderInputEnvelope
    set?: orderThreadingWhereUniqueInput | orderThreadingWhereUniqueInput[]
    disconnect?: orderThreadingWhereUniqueInput | orderThreadingWhereUniqueInput[]
    delete?: orderThreadingWhereUniqueInput | orderThreadingWhereUniqueInput[]
    connect?: orderThreadingWhereUniqueInput | orderThreadingWhereUniqueInput[]
    update?: orderThreadingUpdateWithWhereUniqueWithoutOrderInput | orderThreadingUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: orderThreadingUpdateManyWithWhereWithoutOrderInput | orderThreadingUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: orderThreadingScalarWhereInput | orderThreadingScalarWhereInput[]
  }

  export type usersActivitiesCreateNestedOneWithoutThreadingOrderInput = {
    create?: XOR<usersActivitiesCreateWithoutThreadingOrderInput, usersActivitiesUncheckedCreateWithoutThreadingOrderInput>
    connectOrCreate?: usersActivitiesCreateOrConnectWithoutThreadingOrderInput
    connect?: usersActivitiesWhereUniqueInput
  }

  export type orderCreateNestedOneWithoutThreadingInput = {
    create?: XOR<orderCreateWithoutThreadingInput, orderUncheckedCreateWithoutThreadingInput>
    connectOrCreate?: orderCreateOrConnectWithoutThreadingInput
    connect?: orderWhereUniqueInput
  }

  export type usersActivitiesUpdateOneWithoutThreadingOrderNestedInput = {
    create?: XOR<usersActivitiesCreateWithoutThreadingOrderInput, usersActivitiesUncheckedCreateWithoutThreadingOrderInput>
    connectOrCreate?: usersActivitiesCreateOrConnectWithoutThreadingOrderInput
    upsert?: usersActivitiesUpsertWithoutThreadingOrderInput
    disconnect?: usersActivitiesWhereInput | boolean
    delete?: usersActivitiesWhereInput | boolean
    connect?: usersActivitiesWhereUniqueInput
    update?: XOR<XOR<usersActivitiesUpdateToOneWithWhereWithoutThreadingOrderInput, usersActivitiesUpdateWithoutThreadingOrderInput>, usersActivitiesUncheckedUpdateWithoutThreadingOrderInput>
  }

  export type orderUpdateOneWithoutThreadingNestedInput = {
    create?: XOR<orderCreateWithoutThreadingInput, orderUncheckedCreateWithoutThreadingInput>
    connectOrCreate?: orderCreateOrConnectWithoutThreadingInput
    upsert?: orderUpsertWithoutThreadingInput
    disconnect?: orderWhereInput | boolean
    delete?: orderWhereInput | boolean
    connect?: orderWhereUniqueInput
    update?: XOR<XOR<orderUpdateToOneWithWhereWithoutThreadingInput, orderUpdateWithoutThreadingInput>, orderUncheckedUpdateWithoutThreadingInput>
  }

  export type usersCreateNestedOneWithoutSenderOrderInput = {
    create?: XOR<usersCreateWithoutSenderOrderInput, usersUncheckedCreateWithoutSenderOrderInput>
    connectOrCreate?: usersCreateOrConnectWithoutSenderOrderInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutRecipientOrderInput = {
    create?: XOR<usersCreateWithoutRecipientOrderInput, usersUncheckedCreateWithoutRecipientOrderInput>
    connectOrCreate?: usersCreateOrConnectWithoutRecipientOrderInput
    connect?: usersWhereUniqueInput
  }

  export type orderCreateNestedOneWithoutPersonalInput = {
    create?: XOR<orderCreateWithoutPersonalInput, orderUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: orderCreateOrConnectWithoutPersonalInput
    connect?: orderWhereUniqueInput
  }

  export type usersUpdateOneWithoutSenderOrderNestedInput = {
    create?: XOR<usersCreateWithoutSenderOrderInput, usersUncheckedCreateWithoutSenderOrderInput>
    connectOrCreate?: usersCreateOrConnectWithoutSenderOrderInput
    upsert?: usersUpsertWithoutSenderOrderInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSenderOrderInput, usersUpdateWithoutSenderOrderInput>, usersUncheckedUpdateWithoutSenderOrderInput>
  }

  export type usersUpdateOneWithoutRecipientOrderNestedInput = {
    create?: XOR<usersCreateWithoutRecipientOrderInput, usersUncheckedCreateWithoutRecipientOrderInput>
    connectOrCreate?: usersCreateOrConnectWithoutRecipientOrderInput
    upsert?: usersUpsertWithoutRecipientOrderInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutRecipientOrderInput, usersUpdateWithoutRecipientOrderInput>, usersUncheckedUpdateWithoutRecipientOrderInput>
  }

  export type orderUpdateOneWithoutPersonalNestedInput = {
    create?: XOR<orderCreateWithoutPersonalInput, orderUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: orderCreateOrConnectWithoutPersonalInput
    upsert?: orderUpsertWithoutPersonalInput
    disconnect?: orderWhereInput | boolean
    delete?: orderWhereInput | boolean
    connect?: orderWhereUniqueInput
    update?: XOR<XOR<orderUpdateToOneWithWhereWithoutPersonalInput, orderUpdateWithoutPersonalInput>, orderUncheckedUpdateWithoutPersonalInput>
  }

  export type orderCreateNestedOneWithoutPaymentInput = {
    create?: XOR<orderCreateWithoutPaymentInput, orderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: orderCreateOrConnectWithoutPaymentInput
    connect?: orderWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutRecipientPaymentInput = {
    create?: XOR<usersCreateWithoutRecipientPaymentInput, usersUncheckedCreateWithoutRecipientPaymentInput>
    connectOrCreate?: usersCreateOrConnectWithoutRecipientPaymentInput
    connect?: usersWhereUniqueInput
  }

  export type transactionCreateNestedOneWithoutOrderPaymentInput = {
    create?: XOR<transactionCreateWithoutOrderPaymentInput, transactionUncheckedCreateWithoutOrderPaymentInput>
    connectOrCreate?: transactionCreateOrConnectWithoutOrderPaymentInput
    connect?: transactionWhereUniqueInput
  }

  export type transactionUncheckedCreateNestedOneWithoutOrderPaymentInput = {
    create?: XOR<transactionCreateWithoutOrderPaymentInput, transactionUncheckedCreateWithoutOrderPaymentInput>
    connectOrCreate?: transactionCreateOrConnectWithoutOrderPaymentInput
    connect?: transactionWhereUniqueInput
  }

  export type orderUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<orderCreateWithoutPaymentInput, orderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: orderCreateOrConnectWithoutPaymentInput
    upsert?: orderUpsertWithoutPaymentInput
    disconnect?: orderWhereInput | boolean
    delete?: orderWhereInput | boolean
    connect?: orderWhereUniqueInput
    update?: XOR<XOR<orderUpdateToOneWithWhereWithoutPaymentInput, orderUpdateWithoutPaymentInput>, orderUncheckedUpdateWithoutPaymentInput>
  }

  export type usersUpdateOneWithoutRecipientPaymentNestedInput = {
    create?: XOR<usersCreateWithoutRecipientPaymentInput, usersUncheckedCreateWithoutRecipientPaymentInput>
    connectOrCreate?: usersCreateOrConnectWithoutRecipientPaymentInput
    upsert?: usersUpsertWithoutRecipientPaymentInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutRecipientPaymentInput, usersUpdateWithoutRecipientPaymentInput>, usersUncheckedUpdateWithoutRecipientPaymentInput>
  }

  export type transactionUpdateOneWithoutOrderPaymentNestedInput = {
    create?: XOR<transactionCreateWithoutOrderPaymentInput, transactionUncheckedCreateWithoutOrderPaymentInput>
    connectOrCreate?: transactionCreateOrConnectWithoutOrderPaymentInput
    upsert?: transactionUpsertWithoutOrderPaymentInput
    disconnect?: transactionWhereInput | boolean
    delete?: transactionWhereInput | boolean
    connect?: transactionWhereUniqueInput
    update?: XOR<XOR<transactionUpdateToOneWithWhereWithoutOrderPaymentInput, transactionUpdateWithoutOrderPaymentInput>, transactionUncheckedUpdateWithoutOrderPaymentInput>
  }

  export type transactionUncheckedUpdateOneWithoutOrderPaymentNestedInput = {
    create?: XOR<transactionCreateWithoutOrderPaymentInput, transactionUncheckedCreateWithoutOrderPaymentInput>
    connectOrCreate?: transactionCreateOrConnectWithoutOrderPaymentInput
    upsert?: transactionUpsertWithoutOrderPaymentInput
    disconnect?: transactionWhereInput | boolean
    delete?: transactionWhereInput | boolean
    connect?: transactionWhereUniqueInput
    update?: XOR<XOR<transactionUpdateToOneWithWhereWithoutOrderPaymentInput, transactionUpdateWithoutOrderPaymentInput>, transactionUncheckedUpdateWithoutOrderPaymentInput>
  }

  export type orderCreateNestedOneWithoutDetailsInput = {
    create?: XOR<orderCreateWithoutDetailsInput, orderUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: orderCreateOrConnectWithoutDetailsInput
    connect?: orderWhereUniqueInput
  }

  export type orderUpdateOneWithoutDetailsNestedInput = {
    create?: XOR<orderCreateWithoutDetailsInput, orderUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: orderCreateOrConnectWithoutDetailsInput
    upsert?: orderUpsertWithoutDetailsInput
    disconnect?: orderWhereInput | boolean
    delete?: orderWhereInput | boolean
    connect?: orderWhereUniqueInput
    update?: XOR<XOR<orderUpdateToOneWithWhereWithoutDetailsInput, orderUpdateWithoutDetailsInput>, orderUncheckedUpdateWithoutDetailsInput>
  }

  export type orderTackingCreateNestedManyWithoutTrackingStatusInput = {
    create?: XOR<orderTackingCreateWithoutTrackingStatusInput, orderTackingUncheckedCreateWithoutTrackingStatusInput> | orderTackingCreateWithoutTrackingStatusInput[] | orderTackingUncheckedCreateWithoutTrackingStatusInput[]
    connectOrCreate?: orderTackingCreateOrConnectWithoutTrackingStatusInput | orderTackingCreateOrConnectWithoutTrackingStatusInput[]
    createMany?: orderTackingCreateManyTrackingStatusInputEnvelope
    connect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
  }

  export type orderTackingUncheckedCreateNestedManyWithoutTrackingStatusInput = {
    create?: XOR<orderTackingCreateWithoutTrackingStatusInput, orderTackingUncheckedCreateWithoutTrackingStatusInput> | orderTackingCreateWithoutTrackingStatusInput[] | orderTackingUncheckedCreateWithoutTrackingStatusInput[]
    connectOrCreate?: orderTackingCreateOrConnectWithoutTrackingStatusInput | orderTackingCreateOrConnectWithoutTrackingStatusInput[]
    createMany?: orderTackingCreateManyTrackingStatusInputEnvelope
    connect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
  }

  export type orderTackingUpdateManyWithoutTrackingStatusNestedInput = {
    create?: XOR<orderTackingCreateWithoutTrackingStatusInput, orderTackingUncheckedCreateWithoutTrackingStatusInput> | orderTackingCreateWithoutTrackingStatusInput[] | orderTackingUncheckedCreateWithoutTrackingStatusInput[]
    connectOrCreate?: orderTackingCreateOrConnectWithoutTrackingStatusInput | orderTackingCreateOrConnectWithoutTrackingStatusInput[]
    upsert?: orderTackingUpsertWithWhereUniqueWithoutTrackingStatusInput | orderTackingUpsertWithWhereUniqueWithoutTrackingStatusInput[]
    createMany?: orderTackingCreateManyTrackingStatusInputEnvelope
    set?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    disconnect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    delete?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    connect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    update?: orderTackingUpdateWithWhereUniqueWithoutTrackingStatusInput | orderTackingUpdateWithWhereUniqueWithoutTrackingStatusInput[]
    updateMany?: orderTackingUpdateManyWithWhereWithoutTrackingStatusInput | orderTackingUpdateManyWithWhereWithoutTrackingStatusInput[]
    deleteMany?: orderTackingScalarWhereInput | orderTackingScalarWhereInput[]
  }

  export type orderTackingUncheckedUpdateManyWithoutTrackingStatusNestedInput = {
    create?: XOR<orderTackingCreateWithoutTrackingStatusInput, orderTackingUncheckedCreateWithoutTrackingStatusInput> | orderTackingCreateWithoutTrackingStatusInput[] | orderTackingUncheckedCreateWithoutTrackingStatusInput[]
    connectOrCreate?: orderTackingCreateOrConnectWithoutTrackingStatusInput | orderTackingCreateOrConnectWithoutTrackingStatusInput[]
    upsert?: orderTackingUpsertWithWhereUniqueWithoutTrackingStatusInput | orderTackingUpsertWithWhereUniqueWithoutTrackingStatusInput[]
    createMany?: orderTackingCreateManyTrackingStatusInputEnvelope
    set?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    disconnect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    delete?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    connect?: orderTackingWhereUniqueInput | orderTackingWhereUniqueInput[]
    update?: orderTackingUpdateWithWhereUniqueWithoutTrackingStatusInput | orderTackingUpdateWithWhereUniqueWithoutTrackingStatusInput[]
    updateMany?: orderTackingUpdateManyWithWhereWithoutTrackingStatusInput | orderTackingUpdateManyWithWhereWithoutTrackingStatusInput[]
    deleteMany?: orderTackingScalarWhereInput | orderTackingScalarWhereInput[]
  }

  export type orderCreateNestedOneWithoutTackingInput = {
    create?: XOR<orderCreateWithoutTackingInput, orderUncheckedCreateWithoutTackingInput>
    connectOrCreate?: orderCreateOrConnectWithoutTackingInput
    connect?: orderWhereUniqueInput
  }

  export type branchesCreateNestedOneWithoutTrackingInput = {
    create?: XOR<branchesCreateWithoutTrackingInput, branchesUncheckedCreateWithoutTrackingInput>
    connectOrCreate?: branchesCreateOrConnectWithoutTrackingInput
    connect?: branchesWhereUniqueInput
  }

  export type tackingStatusCreateNestedOneWithoutTrackingInput = {
    create?: XOR<tackingStatusCreateWithoutTrackingInput, tackingStatusUncheckedCreateWithoutTrackingInput>
    connectOrCreate?: tackingStatusCreateOrConnectWithoutTrackingInput
    connect?: tackingStatusWhereUniqueInput
  }

  export type orderUpdateOneWithoutTackingNestedInput = {
    create?: XOR<orderCreateWithoutTackingInput, orderUncheckedCreateWithoutTackingInput>
    connectOrCreate?: orderCreateOrConnectWithoutTackingInput
    upsert?: orderUpsertWithoutTackingInput
    disconnect?: orderWhereInput | boolean
    delete?: orderWhereInput | boolean
    connect?: orderWhereUniqueInput
    update?: XOR<XOR<orderUpdateToOneWithWhereWithoutTackingInput, orderUpdateWithoutTackingInput>, orderUncheckedUpdateWithoutTackingInput>
  }

  export type branchesUpdateOneWithoutTrackingNestedInput = {
    create?: XOR<branchesCreateWithoutTrackingInput, branchesUncheckedCreateWithoutTrackingInput>
    connectOrCreate?: branchesCreateOrConnectWithoutTrackingInput
    upsert?: branchesUpsertWithoutTrackingInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutTrackingInput, branchesUpdateWithoutTrackingInput>, branchesUncheckedUpdateWithoutTrackingInput>
  }

  export type tackingStatusUpdateOneWithoutTrackingNestedInput = {
    create?: XOR<tackingStatusCreateWithoutTrackingInput, tackingStatusUncheckedCreateWithoutTrackingInput>
    connectOrCreate?: tackingStatusCreateOrConnectWithoutTrackingInput
    upsert?: tackingStatusUpsertWithoutTrackingInput
    disconnect?: tackingStatusWhereInput | boolean
    delete?: tackingStatusWhereInput | boolean
    connect?: tackingStatusWhereUniqueInput
    update?: XOR<XOR<tackingStatusUpdateToOneWithWhereWithoutTrackingInput, tackingStatusUpdateWithoutTrackingInput>, tackingStatusUncheckedUpdateWithoutTrackingInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type districtCreateWithoutProvinceInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressCreateNestedManyWithoutDistrictInput
    Village?: villageCreateNestedManyWithoutDistrictInput
  }

  export type districtUncheckedCreateWithoutProvinceInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressUncheckedCreateNestedManyWithoutDistrictInput
    Village?: villageUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type districtCreateOrConnectWithoutProvinceInput = {
    where: districtWhereUniqueInput
    create: XOR<districtCreateWithoutProvinceInput, districtUncheckedCreateWithoutProvinceInput>
  }

  export type districtCreateManyProvinceInputEnvelope = {
    data: districtCreateManyProvinceInput | districtCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type villageCreateWithoutProvinceInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    District?: districtCreateNestedOneWithoutVillageInput
  }

  export type villageUncheckedCreateWithoutProvinceInput = {
    ID?: string
    Name: string
    DistrictID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type villageCreateOrConnectWithoutProvinceInput = {
    where: villageWhereUniqueInput
    create: XOR<villageCreateWithoutProvinceInput, villageUncheckedCreateWithoutProvinceInput>
  }

  export type villageCreateManyProvinceInputEnvelope = {
    data: villageCreateManyProvinceInput | villageCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type addressCreateWithoutProvinceInput = {
    ID?: string
    Address: string
    IsDefault?: boolean | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    District?: districtCreateNestedOneWithoutAddressInput
    Profile?: profileCreateNestedOneWithoutAddressInput
    Branches?: branchesCreateNestedOneWithoutAddressInput
  }

  export type addressUncheckedCreateWithoutProvinceInput = {
    ID?: string
    Address: string
    DistrictID?: string | null
    ProfileID?: string | null
    BranchesID?: string | null
    IsDefault?: boolean | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type addressCreateOrConnectWithoutProvinceInput = {
    where: addressWhereUniqueInput
    create: XOR<addressCreateWithoutProvinceInput, addressUncheckedCreateWithoutProvinceInput>
  }

  export type addressCreateManyProvinceInputEnvelope = {
    data: addressCreateManyProvinceInput | addressCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type districtUpsertWithWhereUniqueWithoutProvinceInput = {
    where: districtWhereUniqueInput
    update: XOR<districtUpdateWithoutProvinceInput, districtUncheckedUpdateWithoutProvinceInput>
    create: XOR<districtCreateWithoutProvinceInput, districtUncheckedCreateWithoutProvinceInput>
  }

  export type districtUpdateWithWhereUniqueWithoutProvinceInput = {
    where: districtWhereUniqueInput
    data: XOR<districtUpdateWithoutProvinceInput, districtUncheckedUpdateWithoutProvinceInput>
  }

  export type districtUpdateManyWithWhereWithoutProvinceInput = {
    where: districtScalarWhereInput
    data: XOR<districtUpdateManyMutationInput, districtUncheckedUpdateManyWithoutProvinceInput>
  }

  export type districtScalarWhereInput = {
    AND?: districtScalarWhereInput | districtScalarWhereInput[]
    OR?: districtScalarWhereInput[]
    NOT?: districtScalarWhereInput | districtScalarWhereInput[]
    ID?: StringFilter<"district"> | string
    Name?: StringFilter<"district"> | string
    ProvinceID?: StringNullableFilter<"district"> | string | null
    Status?: StringNullableFilter<"district"> | string | null
    IsActive?: BoolFilter<"district"> | boolean
    CreatedAt?: DateTimeFilter<"district"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"district"> | Date | string | null
  }

  export type villageUpsertWithWhereUniqueWithoutProvinceInput = {
    where: villageWhereUniqueInput
    update: XOR<villageUpdateWithoutProvinceInput, villageUncheckedUpdateWithoutProvinceInput>
    create: XOR<villageCreateWithoutProvinceInput, villageUncheckedCreateWithoutProvinceInput>
  }

  export type villageUpdateWithWhereUniqueWithoutProvinceInput = {
    where: villageWhereUniqueInput
    data: XOR<villageUpdateWithoutProvinceInput, villageUncheckedUpdateWithoutProvinceInput>
  }

  export type villageUpdateManyWithWhereWithoutProvinceInput = {
    where: villageScalarWhereInput
    data: XOR<villageUpdateManyMutationInput, villageUncheckedUpdateManyWithoutProvinceInput>
  }

  export type villageScalarWhereInput = {
    AND?: villageScalarWhereInput | villageScalarWhereInput[]
    OR?: villageScalarWhereInput[]
    NOT?: villageScalarWhereInput | villageScalarWhereInput[]
    ID?: StringFilter<"village"> | string
    Name?: StringFilter<"village"> | string
    ProvinceID?: StringNullableFilter<"village"> | string | null
    DistrictID?: StringNullableFilter<"village"> | string | null
    Status?: StringNullableFilter<"village"> | string | null
    IsActive?: BoolFilter<"village"> | boolean
    CreatedAt?: DateTimeFilter<"village"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"village"> | Date | string | null
  }

  export type addressUpsertWithWhereUniqueWithoutProvinceInput = {
    where: addressWhereUniqueInput
    update: XOR<addressUpdateWithoutProvinceInput, addressUncheckedUpdateWithoutProvinceInput>
    create: XOR<addressCreateWithoutProvinceInput, addressUncheckedCreateWithoutProvinceInput>
  }

  export type addressUpdateWithWhereUniqueWithoutProvinceInput = {
    where: addressWhereUniqueInput
    data: XOR<addressUpdateWithoutProvinceInput, addressUncheckedUpdateWithoutProvinceInput>
  }

  export type addressUpdateManyWithWhereWithoutProvinceInput = {
    where: addressScalarWhereInput
    data: XOR<addressUpdateManyMutationInput, addressUncheckedUpdateManyWithoutProvinceInput>
  }

  export type addressScalarWhereInput = {
    AND?: addressScalarWhereInput | addressScalarWhereInput[]
    OR?: addressScalarWhereInput[]
    NOT?: addressScalarWhereInput | addressScalarWhereInput[]
    ID?: StringFilter<"address"> | string
    Address?: StringFilter<"address"> | string
    ProvinceID?: StringNullableFilter<"address"> | string | null
    DistrictID?: StringNullableFilter<"address"> | string | null
    ProfileID?: StringNullableFilter<"address"> | string | null
    BranchesID?: StringNullableFilter<"address"> | string | null
    IsDefault?: BoolNullableFilter<"address"> | boolean | null
    Status?: StringNullableFilter<"address"> | string | null
    IsActive?: BoolFilter<"address"> | boolean
    CreatedAt?: DateTimeFilter<"address"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"address"> | Date | string | null
  }

  export type provinceCreateWithoutDistrictInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
    Village?: villageCreateNestedManyWithoutProvinceInput
    Address?: addressCreateNestedManyWithoutProvinceInput
  }

  export type provinceUncheckedCreateWithoutDistrictInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
    Village?: villageUncheckedCreateNestedManyWithoutProvinceInput
    Address?: addressUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type provinceCreateOrConnectWithoutDistrictInput = {
    where: provinceWhereUniqueInput
    create: XOR<provinceCreateWithoutDistrictInput, provinceUncheckedCreateWithoutDistrictInput>
  }

  export type addressCreateWithoutDistrictInput = {
    ID?: string
    Address: string
    IsDefault?: boolean | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Province?: provinceCreateNestedOneWithoutAddressInput
    Profile?: profileCreateNestedOneWithoutAddressInput
    Branches?: branchesCreateNestedOneWithoutAddressInput
  }

  export type addressUncheckedCreateWithoutDistrictInput = {
    ID?: string
    Address: string
    ProvinceID?: string | null
    ProfileID?: string | null
    BranchesID?: string | null
    IsDefault?: boolean | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type addressCreateOrConnectWithoutDistrictInput = {
    where: addressWhereUniqueInput
    create: XOR<addressCreateWithoutDistrictInput, addressUncheckedCreateWithoutDistrictInput>
  }

  export type addressCreateManyDistrictInputEnvelope = {
    data: addressCreateManyDistrictInput | addressCreateManyDistrictInput[]
    skipDuplicates?: boolean
  }

  export type villageCreateWithoutDistrictInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Province?: provinceCreateNestedOneWithoutVillageInput
  }

  export type villageUncheckedCreateWithoutDistrictInput = {
    ID?: string
    Name: string
    ProvinceID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type villageCreateOrConnectWithoutDistrictInput = {
    where: villageWhereUniqueInput
    create: XOR<villageCreateWithoutDistrictInput, villageUncheckedCreateWithoutDistrictInput>
  }

  export type villageCreateManyDistrictInputEnvelope = {
    data: villageCreateManyDistrictInput | villageCreateManyDistrictInput[]
    skipDuplicates?: boolean
  }

  export type provinceUpsertWithoutDistrictInput = {
    update: XOR<provinceUpdateWithoutDistrictInput, provinceUncheckedUpdateWithoutDistrictInput>
    create: XOR<provinceCreateWithoutDistrictInput, provinceUncheckedCreateWithoutDistrictInput>
    where?: provinceWhereInput
  }

  export type provinceUpdateToOneWithWhereWithoutDistrictInput = {
    where?: provinceWhereInput
    data: XOR<provinceUpdateWithoutDistrictInput, provinceUncheckedUpdateWithoutDistrictInput>
  }

  export type provinceUpdateWithoutDistrictInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Village?: villageUpdateManyWithoutProvinceNestedInput
    Address?: addressUpdateManyWithoutProvinceNestedInput
  }

  export type provinceUncheckedUpdateWithoutDistrictInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Village?: villageUncheckedUpdateManyWithoutProvinceNestedInput
    Address?: addressUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type addressUpsertWithWhereUniqueWithoutDistrictInput = {
    where: addressWhereUniqueInput
    update: XOR<addressUpdateWithoutDistrictInput, addressUncheckedUpdateWithoutDistrictInput>
    create: XOR<addressCreateWithoutDistrictInput, addressUncheckedCreateWithoutDistrictInput>
  }

  export type addressUpdateWithWhereUniqueWithoutDistrictInput = {
    where: addressWhereUniqueInput
    data: XOR<addressUpdateWithoutDistrictInput, addressUncheckedUpdateWithoutDistrictInput>
  }

  export type addressUpdateManyWithWhereWithoutDistrictInput = {
    where: addressScalarWhereInput
    data: XOR<addressUpdateManyMutationInput, addressUncheckedUpdateManyWithoutDistrictInput>
  }

  export type villageUpsertWithWhereUniqueWithoutDistrictInput = {
    where: villageWhereUniqueInput
    update: XOR<villageUpdateWithoutDistrictInput, villageUncheckedUpdateWithoutDistrictInput>
    create: XOR<villageCreateWithoutDistrictInput, villageUncheckedCreateWithoutDistrictInput>
  }

  export type villageUpdateWithWhereUniqueWithoutDistrictInput = {
    where: villageWhereUniqueInput
    data: XOR<villageUpdateWithoutDistrictInput, villageUncheckedUpdateWithoutDistrictInput>
  }

  export type villageUpdateManyWithWhereWithoutDistrictInput = {
    where: villageScalarWhereInput
    data: XOR<villageUpdateManyMutationInput, villageUncheckedUpdateManyWithoutDistrictInput>
  }

  export type provinceCreateWithoutVillageInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
    District?: districtCreateNestedManyWithoutProvinceInput
    Address?: addressCreateNestedManyWithoutProvinceInput
  }

  export type provinceUncheckedCreateWithoutVillageInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
    District?: districtUncheckedCreateNestedManyWithoutProvinceInput
    Address?: addressUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type provinceCreateOrConnectWithoutVillageInput = {
    where: provinceWhereUniqueInput
    create: XOR<provinceCreateWithoutVillageInput, provinceUncheckedCreateWithoutVillageInput>
  }

  export type districtCreateWithoutVillageInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Province?: provinceCreateNestedOneWithoutDistrictInput
    Address?: addressCreateNestedManyWithoutDistrictInput
  }

  export type districtUncheckedCreateWithoutVillageInput = {
    ID?: string
    Name: string
    ProvinceID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type districtCreateOrConnectWithoutVillageInput = {
    where: districtWhereUniqueInput
    create: XOR<districtCreateWithoutVillageInput, districtUncheckedCreateWithoutVillageInput>
  }

  export type provinceUpsertWithoutVillageInput = {
    update: XOR<provinceUpdateWithoutVillageInput, provinceUncheckedUpdateWithoutVillageInput>
    create: XOR<provinceCreateWithoutVillageInput, provinceUncheckedCreateWithoutVillageInput>
    where?: provinceWhereInput
  }

  export type provinceUpdateToOneWithWhereWithoutVillageInput = {
    where?: provinceWhereInput
    data: XOR<provinceUpdateWithoutVillageInput, provinceUncheckedUpdateWithoutVillageInput>
  }

  export type provinceUpdateWithoutVillageInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    District?: districtUpdateManyWithoutProvinceNestedInput
    Address?: addressUpdateManyWithoutProvinceNestedInput
  }

  export type provinceUncheckedUpdateWithoutVillageInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    District?: districtUncheckedUpdateManyWithoutProvinceNestedInput
    Address?: addressUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type districtUpsertWithoutVillageInput = {
    update: XOR<districtUpdateWithoutVillageInput, districtUncheckedUpdateWithoutVillageInput>
    create: XOR<districtCreateWithoutVillageInput, districtUncheckedCreateWithoutVillageInput>
    where?: districtWhereInput
  }

  export type districtUpdateToOneWithWhereWithoutVillageInput = {
    where?: districtWhereInput
    data: XOR<districtUpdateWithoutVillageInput, districtUncheckedUpdateWithoutVillageInput>
  }

  export type districtUpdateWithoutVillageInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Province?: provinceUpdateOneWithoutDistrictNestedInput
    Address?: addressUpdateManyWithoutDistrictNestedInput
  }

  export type districtUncheckedUpdateWithoutVillageInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    ProvinceID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type provinceCreateWithoutAddressInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
    District?: districtCreateNestedManyWithoutProvinceInput
    Village?: villageCreateNestedManyWithoutProvinceInput
  }

  export type provinceUncheckedCreateWithoutAddressInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
    District?: districtUncheckedCreateNestedManyWithoutProvinceInput
    Village?: villageUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type provinceCreateOrConnectWithoutAddressInput = {
    where: provinceWhereUniqueInput
    create: XOR<provinceCreateWithoutAddressInput, provinceUncheckedCreateWithoutAddressInput>
  }

  export type districtCreateWithoutAddressInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Province?: provinceCreateNestedOneWithoutDistrictInput
    Village?: villageCreateNestedManyWithoutDistrictInput
  }

  export type districtUncheckedCreateWithoutAddressInput = {
    ID?: string
    Name: string
    ProvinceID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Village?: villageUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type districtCreateOrConnectWithoutAddressInput = {
    where: districtWhereUniqueInput
    create: XOR<districtCreateWithoutAddressInput, districtUncheckedCreateWithoutAddressInput>
  }

  export type profileCreateWithoutAddressInput = {
    ID?: string
    Gender?: string | null
    Name: string
    SurName: string
    ProfileURL?: string | null
    AdminPin?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    User?: usersCreateNestedOneWithoutUserProfileInput
    Admin?: usersCreateNestedOneWithoutAdminProfileInput
  }

  export type profileUncheckedCreateWithoutAddressInput = {
    ID?: string
    Gender?: string | null
    Name: string
    SurName: string
    ProfileURL?: string | null
    UserID?: string | null
    AdminID?: string | null
    AdminPin?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type profileCreateOrConnectWithoutAddressInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutAddressInput, profileUncheckedCreateWithoutAddressInput>
  }

  export type branchesCreateWithoutAddressInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    User?: usersCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyCreateNestedManyWithoutBranchesInput
    BranchesSettings?: branchesSettingsCreateNestedManyWithoutBranchesInput
    Otp?: otpCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryCreateNestedManyWithoutBranchesInput
    Order?: orderCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutAddressInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    User?: usersUncheckedCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyUncheckedCreateNestedManyWithoutBranchesInput
    BranchesSettings?: branchesSettingsUncheckedCreateNestedManyWithoutBranchesInput
    Otp?: otpUncheckedCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryUncheckedCreateNestedManyWithoutBranchesInput
    Order?: orderUncheckedCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutAddressInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutAddressInput, branchesUncheckedCreateWithoutAddressInput>
  }

  export type provinceUpsertWithoutAddressInput = {
    update: XOR<provinceUpdateWithoutAddressInput, provinceUncheckedUpdateWithoutAddressInput>
    create: XOR<provinceCreateWithoutAddressInput, provinceUncheckedCreateWithoutAddressInput>
    where?: provinceWhereInput
  }

  export type provinceUpdateToOneWithWhereWithoutAddressInput = {
    where?: provinceWhereInput
    data: XOR<provinceUpdateWithoutAddressInput, provinceUncheckedUpdateWithoutAddressInput>
  }

  export type provinceUpdateWithoutAddressInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    District?: districtUpdateManyWithoutProvinceNestedInput
    Village?: villageUpdateManyWithoutProvinceNestedInput
  }

  export type provinceUncheckedUpdateWithoutAddressInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    District?: districtUncheckedUpdateManyWithoutProvinceNestedInput
    Village?: villageUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type districtUpsertWithoutAddressInput = {
    update: XOR<districtUpdateWithoutAddressInput, districtUncheckedUpdateWithoutAddressInput>
    create: XOR<districtCreateWithoutAddressInput, districtUncheckedCreateWithoutAddressInput>
    where?: districtWhereInput
  }

  export type districtUpdateToOneWithWhereWithoutAddressInput = {
    where?: districtWhereInput
    data: XOR<districtUpdateWithoutAddressInput, districtUncheckedUpdateWithoutAddressInput>
  }

  export type districtUpdateWithoutAddressInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Province?: provinceUpdateOneWithoutDistrictNestedInput
    Village?: villageUpdateManyWithoutDistrictNestedInput
  }

  export type districtUncheckedUpdateWithoutAddressInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    ProvinceID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Village?: villageUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type profileUpsertWithoutAddressInput = {
    update: XOR<profileUpdateWithoutAddressInput, profileUncheckedUpdateWithoutAddressInput>
    create: XOR<profileCreateWithoutAddressInput, profileUncheckedCreateWithoutAddressInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutAddressInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutAddressInput, profileUncheckedUpdateWithoutAddressInput>
  }

  export type profileUpdateWithoutAddressInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    SurName?: StringFieldUpdateOperationsInput | string
    ProfileURL?: NullableStringFieldUpdateOperationsInput | string | null
    AdminPin?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: usersUpdateOneWithoutUserProfileNestedInput
    Admin?: usersUpdateOneWithoutAdminProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutAddressInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    SurName?: StringFieldUpdateOperationsInput | string
    ProfileURL?: NullableStringFieldUpdateOperationsInput | string | null
    UserID?: NullableStringFieldUpdateOperationsInput | string | null
    AdminID?: NullableStringFieldUpdateOperationsInput | string | null
    AdminPin?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type branchesUpsertWithoutAddressInput = {
    update: XOR<branchesUpdateWithoutAddressInput, branchesUncheckedUpdateWithoutAddressInput>
    create: XOR<branchesCreateWithoutAddressInput, branchesUncheckedCreateWithoutAddressInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutAddressInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutAddressInput, branchesUncheckedUpdateWithoutAddressInput>
  }

  export type branchesUpdateWithoutAddressInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: usersUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUpdateManyWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUpdateManyWithoutBranchesNestedInput
    Otp?: otpUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUpdateManyWithoutBranchesNestedInput
    Order?: orderUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutAddressInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: usersUncheckedUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUncheckedUpdateManyWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUncheckedUpdateManyWithoutBranchesNestedInput
    Otp?: otpUncheckedUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUncheckedUpdateManyWithoutBranchesNestedInput
    Order?: orderUncheckedUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type addressCreateWithoutBranchesInput = {
    ID?: string
    Address: string
    IsDefault?: boolean | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Province?: provinceCreateNestedOneWithoutAddressInput
    District?: districtCreateNestedOneWithoutAddressInput
    Profile?: profileCreateNestedOneWithoutAddressInput
  }

  export type addressUncheckedCreateWithoutBranchesInput = {
    ID?: string
    Address: string
    ProvinceID?: string | null
    DistrictID?: string | null
    ProfileID?: string | null
    IsDefault?: boolean | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type addressCreateOrConnectWithoutBranchesInput = {
    where: addressWhereUniqueInput
    create: XOR<addressCreateWithoutBranchesInput, addressUncheckedCreateWithoutBranchesInput>
  }

  export type usersCreateWithoutBranchesInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Wallet?: walletCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileCreateNestedManyWithoutAdminInput
    UserProfile?: profileCreateNestedOneWithoutUserInput
    OTP?: otpCreateNestedManyWithoutUsersInput
    Roles?: usersRolesCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordCreateNestedManyWithoutUsersInput
    Notifications?: notificationsCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesCreateNestedManyWithoutUsersInput
    Order?: orderCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalCreateNestedManyWithoutRecipientUserInput
  }

  export type usersUncheckedCreateWithoutBranchesInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Wallet?: walletUncheckedCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentUncheckedCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileUncheckedCreateNestedManyWithoutAdminInput
    UserProfile?: profileUncheckedCreateNestedOneWithoutUserInput
    OTP?: otpUncheckedCreateNestedManyWithoutUsersInput
    Roles?: usersRolesUncheckedCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesUncheckedCreateNestedManyWithoutUsersInput
    Order?: orderUncheckedCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalUncheckedCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalUncheckedCreateNestedManyWithoutRecipientUserInput
  }

  export type usersCreateOrConnectWithoutBranchesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutBranchesInput, usersUncheckedCreateWithoutBranchesInput>
  }

  export type branchesKeyCreateWithoutBranchesInput = {
    ID?: string
    Key: string
    Secret: string
    Remask?: string | null
    Status: string
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type branchesKeyUncheckedCreateWithoutBranchesInput = {
    ID?: string
    Key: string
    Secret: string
    Remask?: string | null
    Status: string
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type branchesKeyCreateOrConnectWithoutBranchesInput = {
    where: branchesKeyWhereUniqueInput
    create: XOR<branchesKeyCreateWithoutBranchesInput, branchesKeyUncheckedCreateWithoutBranchesInput>
  }

  export type branchesKeyCreateManyBranchesInputEnvelope = {
    data: branchesKeyCreateManyBranchesInput | branchesKeyCreateManyBranchesInput[]
    skipDuplicates?: boolean
  }

  export type branchesSettingsCreateWithoutBranchesInput = {
    ID?: string
    Titel: string
    Setting: string
    Remask?: string | null
    Status: string
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type branchesSettingsUncheckedCreateWithoutBranchesInput = {
    ID?: string
    Titel: string
    Setting: string
    Remask?: string | null
    Status: string
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type branchesSettingsCreateOrConnectWithoutBranchesInput = {
    where: branchesSettingsWhereUniqueInput
    create: XOR<branchesSettingsCreateWithoutBranchesInput, branchesSettingsUncheckedCreateWithoutBranchesInput>
  }

  export type branchesSettingsCreateManyBranchesInputEnvelope = {
    data: branchesSettingsCreateManyBranchesInput | branchesSettingsCreateManyBranchesInput[]
    skipDuplicates?: boolean
  }

  export type otpCreateWithoutBranchesInput = {
    ID?: string
    OTP?: string | null
    IsVerify?: boolean
    UserName: string
    Type?: string | null
    Remask?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Users?: usersCreateNestedOneWithoutOTPInput
  }

  export type otpUncheckedCreateWithoutBranchesInput = {
    ID?: string
    OTP?: string | null
    IsVerify?: boolean
    UserName: string
    Type?: string | null
    Remask?: string | null
    UsersID?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type otpCreateOrConnectWithoutBranchesInput = {
    where: otpWhereUniqueInput
    create: XOR<otpCreateWithoutBranchesInput, otpUncheckedCreateWithoutBranchesInput>
  }

  export type otpCreateManyBranchesInputEnvelope = {
    data: otpCreateManyBranchesInput | otpCreateManyBranchesInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutBranchesInput = {
    ID?: string
    Titel?: string | null
    Details?: string | null
    Type?: string | null
    Provider?: string | null
    Remask?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Users?: usersCreateNestedOneWithoutNotificationsInput
  }

  export type notificationsUncheckedCreateWithoutBranchesInput = {
    ID?: string
    Titel?: string | null
    Details?: string | null
    Type?: string | null
    Provider?: string | null
    Remask?: string | null
    UsersID?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type notificationsCreateOrConnectWithoutBranchesInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutBranchesInput, notificationsUncheckedCreateWithoutBranchesInput>
  }

  export type notificationsCreateManyBranchesInputEnvelope = {
    data: notificationsCreateManyBranchesInput | notificationsCreateManyBranchesInput[]
    skipDuplicates?: boolean
  }

  export type orderCategoryCreateWithoutBranchesInput = {
    ID?: string
    TypeCode?: string | null
    TypeNmae?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Order?: orderCreateNestedManyWithoutCategoryInput
  }

  export type orderCategoryUncheckedCreateWithoutBranchesInput = {
    ID?: string
    TypeCode?: string | null
    TypeNmae?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Order?: orderUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type orderCategoryCreateOrConnectWithoutBranchesInput = {
    where: orderCategoryWhereUniqueInput
    create: XOR<orderCategoryCreateWithoutBranchesInput, orderCategoryUncheckedCreateWithoutBranchesInput>
  }

  export type orderCategoryCreateManyBranchesInputEnvelope = {
    data: orderCategoryCreateManyBranchesInput | orderCategoryCreateManyBranchesInput[]
    skipDuplicates?: boolean
  }

  export type orderCreateWithoutBranchesInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Category?: orderCategoryCreateNestedOneWithoutOrderInput
    Personal?: orderPersonalCreateNestedOneWithoutOrderInput
    Details?: orderDetailsCreateNestedOneWithoutOrderInput
    Payment?: orderPaymentCreateNestedOneWithoutOrderInput
    CreateBy?: usersCreateNestedOneWithoutOrderInput
    Tacking?: orderTackingCreateNestedManyWithoutOrderInput
    Threading?: orderThreadingCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutBranchesInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    CategoryID?: string | null
    CreateByID?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Personal?: orderPersonalUncheckedCreateNestedOneWithoutOrderInput
    Details?: orderDetailsUncheckedCreateNestedOneWithoutOrderInput
    Payment?: orderPaymentUncheckedCreateNestedOneWithoutOrderInput
    Tacking?: orderTackingUncheckedCreateNestedManyWithoutOrderInput
    Threading?: orderThreadingUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutBranchesInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutBranchesInput, orderUncheckedCreateWithoutBranchesInput>
  }

  export type orderCreateManyBranchesInputEnvelope = {
    data: orderCreateManyBranchesInput | orderCreateManyBranchesInput[]
    skipDuplicates?: boolean
  }

  export type orderTackingCreateWithoutBranchesInput = {
    ID?: string
    Number?: string | null
    PrimaryPhoneNumber?: string | null
    SecondaryName?: string | null
    SecondaryPhoneNumber?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Order?: orderCreateNestedOneWithoutTackingInput
    TrackingStatus?: tackingStatusCreateNestedOneWithoutTrackingInput
  }

  export type orderTackingUncheckedCreateWithoutBranchesInput = {
    ID?: string
    Number?: string | null
    PrimaryPhoneNumber?: string | null
    SecondaryName?: string | null
    SecondaryPhoneNumber?: string | null
    OrderID?: string | null
    TrackingStatusID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderTackingCreateOrConnectWithoutBranchesInput = {
    where: orderTackingWhereUniqueInput
    create: XOR<orderTackingCreateWithoutBranchesInput, orderTackingUncheckedCreateWithoutBranchesInput>
  }

  export type orderTackingCreateManyBranchesInputEnvelope = {
    data: orderTackingCreateManyBranchesInput | orderTackingCreateManyBranchesInput[]
    skipDuplicates?: boolean
  }

  export type addressUpsertWithoutBranchesInput = {
    update: XOR<addressUpdateWithoutBranchesInput, addressUncheckedUpdateWithoutBranchesInput>
    create: XOR<addressCreateWithoutBranchesInput, addressUncheckedCreateWithoutBranchesInput>
    where?: addressWhereInput
  }

  export type addressUpdateToOneWithWhereWithoutBranchesInput = {
    where?: addressWhereInput
    data: XOR<addressUpdateWithoutBranchesInput, addressUncheckedUpdateWithoutBranchesInput>
  }

  export type addressUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    IsDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Province?: provinceUpdateOneWithoutAddressNestedInput
    District?: districtUpdateOneWithoutAddressNestedInput
    Profile?: profileUpdateOneWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    ProvinceID?: NullableStringFieldUpdateOperationsInput | string | null
    DistrictID?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileID?: NullableStringFieldUpdateOperationsInput | string | null
    IsDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUpsertWithoutBranchesInput = {
    update: XOR<usersUpdateWithoutBranchesInput, usersUncheckedUpdateWithoutBranchesInput>
    create: XOR<usersCreateWithoutBranchesInput, usersUncheckedCreateWithoutBranchesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutBranchesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutBranchesInput, usersUncheckedUpdateWithoutBranchesInput>
  }

  export type usersUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Wallet?: walletUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUpdateOneWithoutUserNestedInput
    OTP?: otpUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUpdateManyWithoutUsersNestedInput
    Order?: orderUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersUncheckedUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Wallet?: walletUncheckedUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUncheckedUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUncheckedUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUncheckedUpdateOneWithoutUserNestedInput
    OTP?: otpUncheckedUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUncheckedUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUncheckedUpdateManyWithoutUsersNestedInput
    Order?: orderUncheckedUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUncheckedUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUncheckedUpdateManyWithoutRecipientUserNestedInput
  }

  export type branchesKeyUpsertWithWhereUniqueWithoutBranchesInput = {
    where: branchesKeyWhereUniqueInput
    update: XOR<branchesKeyUpdateWithoutBranchesInput, branchesKeyUncheckedUpdateWithoutBranchesInput>
    create: XOR<branchesKeyCreateWithoutBranchesInput, branchesKeyUncheckedCreateWithoutBranchesInput>
  }

  export type branchesKeyUpdateWithWhereUniqueWithoutBranchesInput = {
    where: branchesKeyWhereUniqueInput
    data: XOR<branchesKeyUpdateWithoutBranchesInput, branchesKeyUncheckedUpdateWithoutBranchesInput>
  }

  export type branchesKeyUpdateManyWithWhereWithoutBranchesInput = {
    where: branchesKeyScalarWhereInput
    data: XOR<branchesKeyUpdateManyMutationInput, branchesKeyUncheckedUpdateManyWithoutBranchesInput>
  }

  export type branchesKeyScalarWhereInput = {
    AND?: branchesKeyScalarWhereInput | branchesKeyScalarWhereInput[]
    OR?: branchesKeyScalarWhereInput[]
    NOT?: branchesKeyScalarWhereInput | branchesKeyScalarWhereInput[]
    ID?: StringFilter<"branchesKey"> | string
    Key?: StringFilter<"branchesKey"> | string
    Secret?: StringFilter<"branchesKey"> | string
    Remask?: StringNullableFilter<"branchesKey"> | string | null
    BranchesID?: StringNullableFilter<"branchesKey"> | string | null
    Status?: StringFilter<"branchesKey"> | string
    IsActive?: BoolFilter<"branchesKey"> | boolean
    CreatedAt?: DateTimeFilter<"branchesKey"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"branchesKey"> | Date | string | null
  }

  export type branchesSettingsUpsertWithWhereUniqueWithoutBranchesInput = {
    where: branchesSettingsWhereUniqueInput
    update: XOR<branchesSettingsUpdateWithoutBranchesInput, branchesSettingsUncheckedUpdateWithoutBranchesInput>
    create: XOR<branchesSettingsCreateWithoutBranchesInput, branchesSettingsUncheckedCreateWithoutBranchesInput>
  }

  export type branchesSettingsUpdateWithWhereUniqueWithoutBranchesInput = {
    where: branchesSettingsWhereUniqueInput
    data: XOR<branchesSettingsUpdateWithoutBranchesInput, branchesSettingsUncheckedUpdateWithoutBranchesInput>
  }

  export type branchesSettingsUpdateManyWithWhereWithoutBranchesInput = {
    where: branchesSettingsScalarWhereInput
    data: XOR<branchesSettingsUpdateManyMutationInput, branchesSettingsUncheckedUpdateManyWithoutBranchesInput>
  }

  export type branchesSettingsScalarWhereInput = {
    AND?: branchesSettingsScalarWhereInput | branchesSettingsScalarWhereInput[]
    OR?: branchesSettingsScalarWhereInput[]
    NOT?: branchesSettingsScalarWhereInput | branchesSettingsScalarWhereInput[]
    ID?: StringFilter<"branchesSettings"> | string
    Titel?: StringFilter<"branchesSettings"> | string
    Setting?: StringFilter<"branchesSettings"> | string
    Remask?: StringNullableFilter<"branchesSettings"> | string | null
    BranchesID?: StringNullableFilter<"branchesSettings"> | string | null
    Status?: StringFilter<"branchesSettings"> | string
    IsActive?: BoolFilter<"branchesSettings"> | boolean
    CreatedAt?: DateTimeFilter<"branchesSettings"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"branchesSettings"> | Date | string | null
  }

  export type otpUpsertWithWhereUniqueWithoutBranchesInput = {
    where: otpWhereUniqueInput
    update: XOR<otpUpdateWithoutBranchesInput, otpUncheckedUpdateWithoutBranchesInput>
    create: XOR<otpCreateWithoutBranchesInput, otpUncheckedCreateWithoutBranchesInput>
  }

  export type otpUpdateWithWhereUniqueWithoutBranchesInput = {
    where: otpWhereUniqueInput
    data: XOR<otpUpdateWithoutBranchesInput, otpUncheckedUpdateWithoutBranchesInput>
  }

  export type otpUpdateManyWithWhereWithoutBranchesInput = {
    where: otpScalarWhereInput
    data: XOR<otpUpdateManyMutationInput, otpUncheckedUpdateManyWithoutBranchesInput>
  }

  export type otpScalarWhereInput = {
    AND?: otpScalarWhereInput | otpScalarWhereInput[]
    OR?: otpScalarWhereInput[]
    NOT?: otpScalarWhereInput | otpScalarWhereInput[]
    ID?: StringFilter<"otp"> | string
    OTP?: StringNullableFilter<"otp"> | string | null
    IsVerify?: BoolFilter<"otp"> | boolean
    UserName?: StringFilter<"otp"> | string
    Type?: StringNullableFilter<"otp"> | string | null
    Remask?: StringNullableFilter<"otp"> | string | null
    UsersID?: StringNullableFilter<"otp"> | string | null
    BranchesID?: StringNullableFilter<"otp"> | string | null
    SmsGatewayUUID?: StringNullableFilter<"otp"> | string | null
    Status?: StringNullableFilter<"otp"> | string | null
    IsActive?: BoolFilter<"otp"> | boolean
    CreatedAt?: DateTimeFilter<"otp"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"otp"> | Date | string | null
  }

  export type notificationsUpsertWithWhereUniqueWithoutBranchesInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutBranchesInput, notificationsUncheckedUpdateWithoutBranchesInput>
    create: XOR<notificationsCreateWithoutBranchesInput, notificationsUncheckedCreateWithoutBranchesInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutBranchesInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutBranchesInput, notificationsUncheckedUpdateWithoutBranchesInput>
  }

  export type notificationsUpdateManyWithWhereWithoutBranchesInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutBranchesInput>
  }

  export type notificationsScalarWhereInput = {
    AND?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    OR?: notificationsScalarWhereInput[]
    NOT?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    ID?: StringFilter<"notifications"> | string
    Titel?: StringNullableFilter<"notifications"> | string | null
    Details?: StringNullableFilter<"notifications"> | string | null
    Type?: StringNullableFilter<"notifications"> | string | null
    Provider?: StringNullableFilter<"notifications"> | string | null
    Remask?: StringNullableFilter<"notifications"> | string | null
    UsersID?: StringNullableFilter<"notifications"> | string | null
    BranchesID?: StringNullableFilter<"notifications"> | string | null
    SmsGatewayUUID?: StringNullableFilter<"notifications"> | string | null
    Status?: StringNullableFilter<"notifications"> | string | null
    IsActive?: BoolFilter<"notifications"> | boolean
    CreatedAt?: DateTimeFilter<"notifications"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"notifications"> | Date | string | null
  }

  export type orderCategoryUpsertWithWhereUniqueWithoutBranchesInput = {
    where: orderCategoryWhereUniqueInput
    update: XOR<orderCategoryUpdateWithoutBranchesInput, orderCategoryUncheckedUpdateWithoutBranchesInput>
    create: XOR<orderCategoryCreateWithoutBranchesInput, orderCategoryUncheckedCreateWithoutBranchesInput>
  }

  export type orderCategoryUpdateWithWhereUniqueWithoutBranchesInput = {
    where: orderCategoryWhereUniqueInput
    data: XOR<orderCategoryUpdateWithoutBranchesInput, orderCategoryUncheckedUpdateWithoutBranchesInput>
  }

  export type orderCategoryUpdateManyWithWhereWithoutBranchesInput = {
    where: orderCategoryScalarWhereInput
    data: XOR<orderCategoryUpdateManyMutationInput, orderCategoryUncheckedUpdateManyWithoutBranchesInput>
  }

  export type orderCategoryScalarWhereInput = {
    AND?: orderCategoryScalarWhereInput | orderCategoryScalarWhereInput[]
    OR?: orderCategoryScalarWhereInput[]
    NOT?: orderCategoryScalarWhereInput | orderCategoryScalarWhereInput[]
    ID?: StringFilter<"orderCategory"> | string
    TypeCode?: StringNullableFilter<"orderCategory"> | string | null
    TypeNmae?: StringNullableFilter<"orderCategory"> | string | null
    Remask?: StringNullableFilter<"orderCategory"> | string | null
    BranchesID?: StringNullableFilter<"orderCategory"> | string | null
    Status?: StringNullableFilter<"orderCategory"> | string | null
    IsActive?: BoolFilter<"orderCategory"> | boolean
    CreatedAt?: DateTimeFilter<"orderCategory"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderCategory"> | Date | string | null
  }

  export type orderUpsertWithWhereUniqueWithoutBranchesInput = {
    where: orderWhereUniqueInput
    update: XOR<orderUpdateWithoutBranchesInput, orderUncheckedUpdateWithoutBranchesInput>
    create: XOR<orderCreateWithoutBranchesInput, orderUncheckedCreateWithoutBranchesInput>
  }

  export type orderUpdateWithWhereUniqueWithoutBranchesInput = {
    where: orderWhereUniqueInput
    data: XOR<orderUpdateWithoutBranchesInput, orderUncheckedUpdateWithoutBranchesInput>
  }

  export type orderUpdateManyWithWhereWithoutBranchesInput = {
    where: orderScalarWhereInput
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyWithoutBranchesInput>
  }

  export type orderScalarWhereInput = {
    AND?: orderScalarWhereInput | orderScalarWhereInput[]
    OR?: orderScalarWhereInput[]
    NOT?: orderScalarWhereInput | orderScalarWhereInput[]
    ID?: StringFilter<"order"> | string
    Code?: StringNullableFilter<"order"> | string | null
    PrimaryCode?: StringNullableFilter<"order"> | string | null
    SecondaryCode?: StringNullableFilter<"order"> | string | null
    OrderDate?: DateTimeNullableFilter<"order"> | Date | string | null
    Name?: StringNullableFilter<"order"> | string | null
    UplaodURL?: StringNullableFilter<"order"> | string | null
    CategoryID?: StringNullableFilter<"order"> | string | null
    BranchesID?: StringNullableFilter<"order"> | string | null
    CreateByID?: StringNullableFilter<"order"> | string | null
    Remask?: StringNullableFilter<"order"> | string | null
    Status?: StringNullableFilter<"order"> | string | null
    IsActive?: BoolFilter<"order"> | boolean
    CreatedAt?: DateTimeFilter<"order"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"order"> | Date | string | null
  }

  export type orderTackingUpsertWithWhereUniqueWithoutBranchesInput = {
    where: orderTackingWhereUniqueInput
    update: XOR<orderTackingUpdateWithoutBranchesInput, orderTackingUncheckedUpdateWithoutBranchesInput>
    create: XOR<orderTackingCreateWithoutBranchesInput, orderTackingUncheckedCreateWithoutBranchesInput>
  }

  export type orderTackingUpdateWithWhereUniqueWithoutBranchesInput = {
    where: orderTackingWhereUniqueInput
    data: XOR<orderTackingUpdateWithoutBranchesInput, orderTackingUncheckedUpdateWithoutBranchesInput>
  }

  export type orderTackingUpdateManyWithWhereWithoutBranchesInput = {
    where: orderTackingScalarWhereInput
    data: XOR<orderTackingUpdateManyMutationInput, orderTackingUncheckedUpdateManyWithoutBranchesInput>
  }

  export type orderTackingScalarWhereInput = {
    AND?: orderTackingScalarWhereInput | orderTackingScalarWhereInput[]
    OR?: orderTackingScalarWhereInput[]
    NOT?: orderTackingScalarWhereInput | orderTackingScalarWhereInput[]
    ID?: StringFilter<"orderTacking"> | string
    Number?: StringNullableFilter<"orderTacking"> | string | null
    PrimaryPhoneNumber?: StringNullableFilter<"orderTacking"> | string | null
    SecondaryName?: StringNullableFilter<"orderTacking"> | string | null
    SecondaryPhoneNumber?: StringNullableFilter<"orderTacking"> | string | null
    OrderID?: StringNullableFilter<"orderTacking"> | string | null
    BranchesID?: StringNullableFilter<"orderTacking"> | string | null
    TrackingStatusID?: StringNullableFilter<"orderTacking"> | string | null
    Status?: StringNullableFilter<"orderTacking"> | string | null
    IsActive?: BoolFilter<"orderTacking"> | boolean
    CreatedAt?: DateTimeFilter<"orderTacking"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderTacking"> | Date | string | null
  }

  export type branchesCreateWithoutBranchesKeyInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressCreateNestedOneWithoutBranchesInput
    User?: usersCreateNestedOneWithoutBranchesInput
    BranchesSettings?: branchesSettingsCreateNestedManyWithoutBranchesInput
    Otp?: otpCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryCreateNestedManyWithoutBranchesInput
    Order?: orderCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutBranchesKeyInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressUncheckedCreateNestedOneWithoutBranchesInput
    User?: usersUncheckedCreateNestedOneWithoutBranchesInput
    BranchesSettings?: branchesSettingsUncheckedCreateNestedManyWithoutBranchesInput
    Otp?: otpUncheckedCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryUncheckedCreateNestedManyWithoutBranchesInput
    Order?: orderUncheckedCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutBranchesKeyInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutBranchesKeyInput, branchesUncheckedCreateWithoutBranchesKeyInput>
  }

  export type branchesUpsertWithoutBranchesKeyInput = {
    update: XOR<branchesUpdateWithoutBranchesKeyInput, branchesUncheckedUpdateWithoutBranchesKeyInput>
    create: XOR<branchesCreateWithoutBranchesKeyInput, branchesUncheckedCreateWithoutBranchesKeyInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutBranchesKeyInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutBranchesKeyInput, branchesUncheckedUpdateWithoutBranchesKeyInput>
  }

  export type branchesUpdateWithoutBranchesKeyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUpdateOneWithoutBranchesNestedInput
    User?: usersUpdateOneWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUpdateManyWithoutBranchesNestedInput
    Otp?: otpUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUpdateManyWithoutBranchesNestedInput
    Order?: orderUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutBranchesKeyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUncheckedUpdateOneWithoutBranchesNestedInput
    User?: usersUncheckedUpdateOneWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUncheckedUpdateManyWithoutBranchesNestedInput
    Otp?: otpUncheckedUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUncheckedUpdateManyWithoutBranchesNestedInput
    Order?: orderUncheckedUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type branchesCreateWithoutBranchesSettingsInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressCreateNestedOneWithoutBranchesInput
    User?: usersCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyCreateNestedManyWithoutBranchesInput
    Otp?: otpCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryCreateNestedManyWithoutBranchesInput
    Order?: orderCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutBranchesSettingsInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressUncheckedCreateNestedOneWithoutBranchesInput
    User?: usersUncheckedCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyUncheckedCreateNestedManyWithoutBranchesInput
    Otp?: otpUncheckedCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryUncheckedCreateNestedManyWithoutBranchesInput
    Order?: orderUncheckedCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutBranchesSettingsInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutBranchesSettingsInput, branchesUncheckedCreateWithoutBranchesSettingsInput>
  }

  export type branchesUpsertWithoutBranchesSettingsInput = {
    update: XOR<branchesUpdateWithoutBranchesSettingsInput, branchesUncheckedUpdateWithoutBranchesSettingsInput>
    create: XOR<branchesCreateWithoutBranchesSettingsInput, branchesUncheckedCreateWithoutBranchesSettingsInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutBranchesSettingsInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutBranchesSettingsInput, branchesUncheckedUpdateWithoutBranchesSettingsInput>
  }

  export type branchesUpdateWithoutBranchesSettingsInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUpdateOneWithoutBranchesNestedInput
    User?: usersUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUpdateManyWithoutBranchesNestedInput
    Otp?: otpUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUpdateManyWithoutBranchesNestedInput
    Order?: orderUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutBranchesSettingsInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUncheckedUpdateOneWithoutBranchesNestedInput
    User?: usersUncheckedUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUncheckedUpdateManyWithoutBranchesNestedInput
    Otp?: otpUncheckedUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUncheckedUpdateManyWithoutBranchesNestedInput
    Order?: orderUncheckedUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type usersCreateWithoutWalletInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutUserInput
    RecipientPayment?: orderPaymentCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileCreateNestedManyWithoutAdminInput
    UserProfile?: profileCreateNestedOneWithoutUserInput
    OTP?: otpCreateNestedManyWithoutUsersInput
    Roles?: usersRolesCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordCreateNestedManyWithoutUsersInput
    Notifications?: notificationsCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesCreateNestedManyWithoutUsersInput
    Order?: orderCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalCreateNestedManyWithoutRecipientUserInput
  }

  export type usersUncheckedCreateWithoutWalletInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    BranchesID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    RecipientPayment?: orderPaymentUncheckedCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileUncheckedCreateNestedManyWithoutAdminInput
    UserProfile?: profileUncheckedCreateNestedOneWithoutUserInput
    OTP?: otpUncheckedCreateNestedManyWithoutUsersInput
    Roles?: usersRolesUncheckedCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesUncheckedCreateNestedManyWithoutUsersInput
    Order?: orderUncheckedCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalUncheckedCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalUncheckedCreateNestedManyWithoutRecipientUserInput
  }

  export type usersCreateOrConnectWithoutWalletInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutWalletInput, usersUncheckedCreateWithoutWalletInput>
  }

  export type transactionCreateWithoutPaidToInput = {
    ID?: string
    Type?: string | null
    Info?: string | null
    Status?: string | null
    Result?: number | null
    Balance?: number | null
    IsPayment?: boolean | null
    IsReceived?: boolean | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    OrderPayment?: orderPaymentCreateNestedOneWithoutTransactionInput
    PaidBy?: walletCreateNestedOneWithoutPaymentInput
  }

  export type transactionUncheckedCreateWithoutPaidToInput = {
    ID?: string
    Type?: string | null
    Info?: string | null
    Status?: string | null
    Result?: number | null
    Balance?: number | null
    IsPayment?: boolean | null
    IsReceived?: boolean | null
    OrderPaymentID?: string | null
    PaidByID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type transactionCreateOrConnectWithoutPaidToInput = {
    where: transactionWhereUniqueInput
    create: XOR<transactionCreateWithoutPaidToInput, transactionUncheckedCreateWithoutPaidToInput>
  }

  export type transactionCreateManyPaidToInputEnvelope = {
    data: transactionCreateManyPaidToInput | transactionCreateManyPaidToInput[]
    skipDuplicates?: boolean
  }

  export type transactionCreateWithoutPaidByInput = {
    ID?: string
    Type?: string | null
    Info?: string | null
    Status?: string | null
    Result?: number | null
    Balance?: number | null
    IsPayment?: boolean | null
    IsReceived?: boolean | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    OrderPayment?: orderPaymentCreateNestedOneWithoutTransactionInput
    PaidTo?: walletCreateNestedOneWithoutReceiveInput
  }

  export type transactionUncheckedCreateWithoutPaidByInput = {
    ID?: string
    Type?: string | null
    Info?: string | null
    Status?: string | null
    Result?: number | null
    Balance?: number | null
    IsPayment?: boolean | null
    IsReceived?: boolean | null
    OrderPaymentID?: string | null
    PaidToID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type transactionCreateOrConnectWithoutPaidByInput = {
    where: transactionWhereUniqueInput
    create: XOR<transactionCreateWithoutPaidByInput, transactionUncheckedCreateWithoutPaidByInput>
  }

  export type transactionCreateManyPaidByInputEnvelope = {
    data: transactionCreateManyPaidByInput | transactionCreateManyPaidByInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutWalletInput = {
    update: XOR<usersUpdateWithoutWalletInput, usersUncheckedUpdateWithoutWalletInput>
    create: XOR<usersCreateWithoutWalletInput, usersUncheckedCreateWithoutWalletInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutWalletInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutWalletInput, usersUncheckedUpdateWithoutWalletInput>
  }

  export type usersUpdateWithoutWalletInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutUserNestedInput
    RecipientPayment?: orderPaymentUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUpdateOneWithoutUserNestedInput
    OTP?: otpUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUpdateManyWithoutUsersNestedInput
    Order?: orderUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersUncheckedUpdateWithoutWalletInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RecipientPayment?: orderPaymentUncheckedUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUncheckedUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUncheckedUpdateOneWithoutUserNestedInput
    OTP?: otpUncheckedUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUncheckedUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUncheckedUpdateManyWithoutUsersNestedInput
    Order?: orderUncheckedUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUncheckedUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUncheckedUpdateManyWithoutRecipientUserNestedInput
  }

  export type transactionUpsertWithWhereUniqueWithoutPaidToInput = {
    where: transactionWhereUniqueInput
    update: XOR<transactionUpdateWithoutPaidToInput, transactionUncheckedUpdateWithoutPaidToInput>
    create: XOR<transactionCreateWithoutPaidToInput, transactionUncheckedCreateWithoutPaidToInput>
  }

  export type transactionUpdateWithWhereUniqueWithoutPaidToInput = {
    where: transactionWhereUniqueInput
    data: XOR<transactionUpdateWithoutPaidToInput, transactionUncheckedUpdateWithoutPaidToInput>
  }

  export type transactionUpdateManyWithWhereWithoutPaidToInput = {
    where: transactionScalarWhereInput
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyWithoutPaidToInput>
  }

  export type transactionScalarWhereInput = {
    AND?: transactionScalarWhereInput | transactionScalarWhereInput[]
    OR?: transactionScalarWhereInput[]
    NOT?: transactionScalarWhereInput | transactionScalarWhereInput[]
    ID?: StringFilter<"transaction"> | string
    Type?: StringNullableFilter<"transaction"> | string | null
    Info?: StringNullableFilter<"transaction"> | string | null
    Status?: StringNullableFilter<"transaction"> | string | null
    Result?: FloatNullableFilter<"transaction"> | number | null
    Balance?: FloatNullableFilter<"transaction"> | number | null
    IsPayment?: BoolNullableFilter<"transaction"> | boolean | null
    IsReceived?: BoolNullableFilter<"transaction"> | boolean | null
    OrderPaymentID?: StringNullableFilter<"transaction"> | string | null
    PaidByID?: StringNullableFilter<"transaction"> | string | null
    PaidToID?: StringNullableFilter<"transaction"> | string | null
    IsActive?: BoolFilter<"transaction"> | boolean
    CreatedAt?: DateTimeFilter<"transaction"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"transaction"> | Date | string | null
  }

  export type transactionUpsertWithWhereUniqueWithoutPaidByInput = {
    where: transactionWhereUniqueInput
    update: XOR<transactionUpdateWithoutPaidByInput, transactionUncheckedUpdateWithoutPaidByInput>
    create: XOR<transactionCreateWithoutPaidByInput, transactionUncheckedCreateWithoutPaidByInput>
  }

  export type transactionUpdateWithWhereUniqueWithoutPaidByInput = {
    where: transactionWhereUniqueInput
    data: XOR<transactionUpdateWithoutPaidByInput, transactionUncheckedUpdateWithoutPaidByInput>
  }

  export type transactionUpdateManyWithWhereWithoutPaidByInput = {
    where: transactionScalarWhereInput
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyWithoutPaidByInput>
  }

  export type orderPaymentCreateWithoutTransactionInput = {
    ID?: string
    PaymentStatus?: string | null
    AmountDeliver?: number | null
    IsPaid?: boolean
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Order?: orderCreateNestedOneWithoutPaymentInput
    PaidTo?: usersCreateNestedOneWithoutRecipientPaymentInput
  }

  export type orderPaymentUncheckedCreateWithoutTransactionInput = {
    ID?: string
    PaymentStatus?: string | null
    AmountDeliver?: number | null
    IsPaid?: boolean
    OrderID?: string | null
    PaidToID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderPaymentCreateOrConnectWithoutTransactionInput = {
    where: orderPaymentWhereUniqueInput
    create: XOR<orderPaymentCreateWithoutTransactionInput, orderPaymentUncheckedCreateWithoutTransactionInput>
  }

  export type walletCreateWithoutPaymentInput = {
    ID?: string
    Balance?: number | null
    Title?: string | null
    Description?: string | null
    IsReal?: boolean | null
    Status?: string | null
    Remask?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    User?: usersCreateNestedOneWithoutWalletInput
    Receive?: transactionCreateNestedManyWithoutPaidToInput
  }

  export type walletUncheckedCreateWithoutPaymentInput = {
    ID?: string
    Balance?: number | null
    Title?: string | null
    Description?: string | null
    IsReal?: boolean | null
    UserID?: string | null
    Status?: string | null
    Remask?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Receive?: transactionUncheckedCreateNestedManyWithoutPaidToInput
  }

  export type walletCreateOrConnectWithoutPaymentInput = {
    where: walletWhereUniqueInput
    create: XOR<walletCreateWithoutPaymentInput, walletUncheckedCreateWithoutPaymentInput>
  }

  export type walletCreateWithoutReceiveInput = {
    ID?: string
    Balance?: number | null
    Title?: string | null
    Description?: string | null
    IsReal?: boolean | null
    Status?: string | null
    Remask?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    User?: usersCreateNestedOneWithoutWalletInput
    Payment?: transactionCreateNestedManyWithoutPaidByInput
  }

  export type walletUncheckedCreateWithoutReceiveInput = {
    ID?: string
    Balance?: number | null
    Title?: string | null
    Description?: string | null
    IsReal?: boolean | null
    UserID?: string | null
    Status?: string | null
    Remask?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Payment?: transactionUncheckedCreateNestedManyWithoutPaidByInput
  }

  export type walletCreateOrConnectWithoutReceiveInput = {
    where: walletWhereUniqueInput
    create: XOR<walletCreateWithoutReceiveInput, walletUncheckedCreateWithoutReceiveInput>
  }

  export type orderPaymentUpsertWithoutTransactionInput = {
    update: XOR<orderPaymentUpdateWithoutTransactionInput, orderPaymentUncheckedUpdateWithoutTransactionInput>
    create: XOR<orderPaymentCreateWithoutTransactionInput, orderPaymentUncheckedCreateWithoutTransactionInput>
    where?: orderPaymentWhereInput
  }

  export type orderPaymentUpdateToOneWithWhereWithoutTransactionInput = {
    where?: orderPaymentWhereInput
    data: XOR<orderPaymentUpdateWithoutTransactionInput, orderPaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type orderPaymentUpdateWithoutTransactionInput = {
    ID?: StringFieldUpdateOperationsInput | string
    PaymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AmountDeliver?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPaid?: BoolFieldUpdateOperationsInput | boolean
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Order?: orderUpdateOneWithoutPaymentNestedInput
    PaidTo?: usersUpdateOneWithoutRecipientPaymentNestedInput
  }

  export type orderPaymentUncheckedUpdateWithoutTransactionInput = {
    ID?: StringFieldUpdateOperationsInput | string
    PaymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AmountDeliver?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPaid?: BoolFieldUpdateOperationsInput | boolean
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    PaidToID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type walletUpsertWithoutPaymentInput = {
    update: XOR<walletUpdateWithoutPaymentInput, walletUncheckedUpdateWithoutPaymentInput>
    create: XOR<walletCreateWithoutPaymentInput, walletUncheckedCreateWithoutPaymentInput>
    where?: walletWhereInput
  }

  export type walletUpdateToOneWithWhereWithoutPaymentInput = {
    where?: walletWhereInput
    data: XOR<walletUpdateWithoutPaymentInput, walletUncheckedUpdateWithoutPaymentInput>
  }

  export type walletUpdateWithoutPaymentInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsReal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: usersUpdateOneWithoutWalletNestedInput
    Receive?: transactionUpdateManyWithoutPaidToNestedInput
  }

  export type walletUncheckedUpdateWithoutPaymentInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsReal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Receive?: transactionUncheckedUpdateManyWithoutPaidToNestedInput
  }

  export type walletUpsertWithoutReceiveInput = {
    update: XOR<walletUpdateWithoutReceiveInput, walletUncheckedUpdateWithoutReceiveInput>
    create: XOR<walletCreateWithoutReceiveInput, walletUncheckedCreateWithoutReceiveInput>
    where?: walletWhereInput
  }

  export type walletUpdateToOneWithWhereWithoutReceiveInput = {
    where?: walletWhereInput
    data: XOR<walletUpdateWithoutReceiveInput, walletUncheckedUpdateWithoutReceiveInput>
  }

  export type walletUpdateWithoutReceiveInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsReal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: usersUpdateOneWithoutWalletNestedInput
    Payment?: transactionUpdateManyWithoutPaidByNestedInput
  }

  export type walletUncheckedUpdateWithoutReceiveInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsReal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Payment?: transactionUncheckedUpdateManyWithoutPaidByNestedInput
  }

  export type branchesCreateWithoutUserInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyCreateNestedManyWithoutBranchesInput
    BranchesSettings?: branchesSettingsCreateNestedManyWithoutBranchesInput
    Otp?: otpCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryCreateNestedManyWithoutBranchesInput
    Order?: orderCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutUserInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressUncheckedCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyUncheckedCreateNestedManyWithoutBranchesInput
    BranchesSettings?: branchesSettingsUncheckedCreateNestedManyWithoutBranchesInput
    Otp?: otpUncheckedCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryUncheckedCreateNestedManyWithoutBranchesInput
    Order?: orderUncheckedCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutUserInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutUserInput, branchesUncheckedCreateWithoutUserInput>
  }

  export type walletCreateWithoutUserInput = {
    ID?: string
    Balance?: number | null
    Title?: string | null
    Description?: string | null
    IsReal?: boolean | null
    Status?: string | null
    Remask?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Receive?: transactionCreateNestedManyWithoutPaidToInput
    Payment?: transactionCreateNestedManyWithoutPaidByInput
  }

  export type walletUncheckedCreateWithoutUserInput = {
    ID?: string
    Balance?: number | null
    Title?: string | null
    Description?: string | null
    IsReal?: boolean | null
    Status?: string | null
    Remask?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Receive?: transactionUncheckedCreateNestedManyWithoutPaidToInput
    Payment?: transactionUncheckedCreateNestedManyWithoutPaidByInput
  }

  export type walletCreateOrConnectWithoutUserInput = {
    where: walletWhereUniqueInput
    create: XOR<walletCreateWithoutUserInput, walletUncheckedCreateWithoutUserInput>
  }

  export type walletCreateManyUserInputEnvelope = {
    data: walletCreateManyUserInput | walletCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type orderPaymentCreateWithoutPaidToInput = {
    ID?: string
    PaymentStatus?: string | null
    AmountDeliver?: number | null
    IsPaid?: boolean
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Order?: orderCreateNestedOneWithoutPaymentInput
    Transaction?: transactionCreateNestedOneWithoutOrderPaymentInput
  }

  export type orderPaymentUncheckedCreateWithoutPaidToInput = {
    ID?: string
    PaymentStatus?: string | null
    AmountDeliver?: number | null
    IsPaid?: boolean
    OrderID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Transaction?: transactionUncheckedCreateNestedOneWithoutOrderPaymentInput
  }

  export type orderPaymentCreateOrConnectWithoutPaidToInput = {
    where: orderPaymentWhereUniqueInput
    create: XOR<orderPaymentCreateWithoutPaidToInput, orderPaymentUncheckedCreateWithoutPaidToInput>
  }

  export type orderPaymentCreateManyPaidToInputEnvelope = {
    data: orderPaymentCreateManyPaidToInput | orderPaymentCreateManyPaidToInput[]
    skipDuplicates?: boolean
  }

  export type profileCreateWithoutAdminInput = {
    ID?: string
    Gender?: string | null
    Name: string
    SurName: string
    ProfileURL?: string | null
    AdminPin?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    User?: usersCreateNestedOneWithoutUserProfileInput
    Address?: addressCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutAdminInput = {
    ID?: string
    Gender?: string | null
    Name: string
    SurName: string
    ProfileURL?: string | null
    UserID?: string | null
    AdminPin?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutAdminInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutAdminInput, profileUncheckedCreateWithoutAdminInput>
  }

  export type profileCreateManyAdminInputEnvelope = {
    data: profileCreateManyAdminInput | profileCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type profileCreateWithoutUserInput = {
    ID?: string
    Gender?: string | null
    Name: string
    SurName: string
    ProfileURL?: string | null
    AdminPin?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Admin?: usersCreateNestedOneWithoutAdminProfileInput
    Address?: addressCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutUserInput = {
    ID?: string
    Gender?: string | null
    Name: string
    SurName: string
    ProfileURL?: string | null
    AdminID?: string | null
    AdminPin?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutUserInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
  }

  export type otpCreateWithoutUsersInput = {
    ID?: string
    OTP?: string | null
    IsVerify?: boolean
    UserName: string
    Type?: string | null
    Remask?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutOtpInput
  }

  export type otpUncheckedCreateWithoutUsersInput = {
    ID?: string
    OTP?: string | null
    IsVerify?: boolean
    UserName: string
    Type?: string | null
    Remask?: string | null
    BranchesID?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type otpCreateOrConnectWithoutUsersInput = {
    where: otpWhereUniqueInput
    create: XOR<otpCreateWithoutUsersInput, otpUncheckedCreateWithoutUsersInput>
  }

  export type otpCreateManyUsersInputEnvelope = {
    data: otpCreateManyUsersInput | otpCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type usersRolesCreateWithoutUsersInput = {
    ID?: string
    Titel?: string | null
    Type?: string | null
    Role: string
    Permission: string
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type usersRolesUncheckedCreateWithoutUsersInput = {
    ID?: string
    Titel?: string | null
    Type?: string | null
    Role: string
    Permission: string
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type usersRolesCreateOrConnectWithoutUsersInput = {
    where: usersRolesWhereUniqueInput
    create: XOR<usersRolesCreateWithoutUsersInput, usersRolesUncheckedCreateWithoutUsersInput>
  }

  export type usersRolesCreateManyUsersInputEnvelope = {
    data: usersRolesCreateManyUsersInput | usersRolesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type forgotPasswordCreateWithoutUsersInput = {
    ID?: string
    Titel?: string | null
    Token?: string | null
    OldPassword?: string | null
    OtpID?: string | null
    Provider?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type forgotPasswordUncheckedCreateWithoutUsersInput = {
    ID?: string
    Titel?: string | null
    Token?: string | null
    OldPassword?: string | null
    OtpID?: string | null
    Provider?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type forgotPasswordCreateOrConnectWithoutUsersInput = {
    where: forgotPasswordWhereUniqueInput
    create: XOR<forgotPasswordCreateWithoutUsersInput, forgotPasswordUncheckedCreateWithoutUsersInput>
  }

  export type forgotPasswordCreateManyUsersInputEnvelope = {
    data: forgotPasswordCreateManyUsersInput | forgotPasswordCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutUsersInput = {
    ID?: string
    Titel?: string | null
    Details?: string | null
    Type?: string | null
    Provider?: string | null
    Remask?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutNotificationsInput
  }

  export type notificationsUncheckedCreateWithoutUsersInput = {
    ID?: string
    Titel?: string | null
    Details?: string | null
    Type?: string | null
    Provider?: string | null
    Remask?: string | null
    BranchesID?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type notificationsCreateOrConnectWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput>
  }

  export type notificationsCreateManyUsersInputEnvelope = {
    data: notificationsCreateManyUsersInput | notificationsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type usersActivitiesCreateWithoutUsersInput = {
    ID?: string
    Activity?: string | null
    IP?: string | null
    MacAddress?: string | null
    UDID?: string | null
    Remask?: string | null
    Log?: string | null
    Error?: string | null
    Messages?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    ThreadingOrder?: orderThreadingCreateNestedOneWithoutActivitieInput
  }

  export type usersActivitiesUncheckedCreateWithoutUsersInput = {
    ID?: string
    Activity?: string | null
    IP?: string | null
    MacAddress?: string | null
    UDID?: string | null
    Remask?: string | null
    Log?: string | null
    Error?: string | null
    Messages?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    ThreadingOrder?: orderThreadingUncheckedCreateNestedOneWithoutActivitieInput
  }

  export type usersActivitiesCreateOrConnectWithoutUsersInput = {
    where: usersActivitiesWhereUniqueInput
    create: XOR<usersActivitiesCreateWithoutUsersInput, usersActivitiesUncheckedCreateWithoutUsersInput>
  }

  export type usersActivitiesCreateManyUsersInputEnvelope = {
    data: usersActivitiesCreateManyUsersInput | usersActivitiesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type orderCreateWithoutCreateByInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Category?: orderCategoryCreateNestedOneWithoutOrderInput
    Personal?: orderPersonalCreateNestedOneWithoutOrderInput
    Details?: orderDetailsCreateNestedOneWithoutOrderInput
    Payment?: orderPaymentCreateNestedOneWithoutOrderInput
    Branches?: branchesCreateNestedOneWithoutOrderInput
    Tacking?: orderTackingCreateNestedManyWithoutOrderInput
    Threading?: orderThreadingCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutCreateByInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    CategoryID?: string | null
    BranchesID?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Personal?: orderPersonalUncheckedCreateNestedOneWithoutOrderInput
    Details?: orderDetailsUncheckedCreateNestedOneWithoutOrderInput
    Payment?: orderPaymentUncheckedCreateNestedOneWithoutOrderInput
    Tacking?: orderTackingUncheckedCreateNestedManyWithoutOrderInput
    Threading?: orderThreadingUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutCreateByInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutCreateByInput, orderUncheckedCreateWithoutCreateByInput>
  }

  export type orderCreateManyCreateByInputEnvelope = {
    data: orderCreateManyCreateByInput | orderCreateManyCreateByInput[]
    skipDuplicates?: boolean
  }

  export type orderPersonalCreateWithoutSenderUserInput = {
    ID?: string
    SenderName?: string | null
    SenderPhoneNumber?: string | null
    RecipientName?: string | null
    RecipientPhoneNumber?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    RecipientUser?: usersCreateNestedOneWithoutRecipientOrderInput
    Order?: orderCreateNestedOneWithoutPersonalInput
  }

  export type orderPersonalUncheckedCreateWithoutSenderUserInput = {
    ID?: string
    SenderName?: string | null
    SenderPhoneNumber?: string | null
    RecipientName?: string | null
    RecipientPhoneNumber?: string | null
    RecipientID?: string | null
    OrderID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderPersonalCreateOrConnectWithoutSenderUserInput = {
    where: orderPersonalWhereUniqueInput
    create: XOR<orderPersonalCreateWithoutSenderUserInput, orderPersonalUncheckedCreateWithoutSenderUserInput>
  }

  export type orderPersonalCreateManySenderUserInputEnvelope = {
    data: orderPersonalCreateManySenderUserInput | orderPersonalCreateManySenderUserInput[]
    skipDuplicates?: boolean
  }

  export type orderPersonalCreateWithoutRecipientUserInput = {
    ID?: string
    SenderName?: string | null
    SenderPhoneNumber?: string | null
    RecipientName?: string | null
    RecipientPhoneNumber?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    SenderUser?: usersCreateNestedOneWithoutSenderOrderInput
    Order?: orderCreateNestedOneWithoutPersonalInput
  }

  export type orderPersonalUncheckedCreateWithoutRecipientUserInput = {
    ID?: string
    SenderName?: string | null
    SenderPhoneNumber?: string | null
    SenderUserID?: string | null
    RecipientName?: string | null
    RecipientPhoneNumber?: string | null
    OrderID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderPersonalCreateOrConnectWithoutRecipientUserInput = {
    where: orderPersonalWhereUniqueInput
    create: XOR<orderPersonalCreateWithoutRecipientUserInput, orderPersonalUncheckedCreateWithoutRecipientUserInput>
  }

  export type orderPersonalCreateManyRecipientUserInputEnvelope = {
    data: orderPersonalCreateManyRecipientUserInput | orderPersonalCreateManyRecipientUserInput[]
    skipDuplicates?: boolean
  }

  export type branchesUpsertWithoutUserInput = {
    update: XOR<branchesUpdateWithoutUserInput, branchesUncheckedUpdateWithoutUserInput>
    create: XOR<branchesCreateWithoutUserInput, branchesUncheckedCreateWithoutUserInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutUserInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutUserInput, branchesUncheckedUpdateWithoutUserInput>
  }

  export type branchesUpdateWithoutUserInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUpdateManyWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUpdateManyWithoutBranchesNestedInput
    Otp?: otpUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUpdateManyWithoutBranchesNestedInput
    Order?: orderUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutUserInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUncheckedUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUncheckedUpdateManyWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUncheckedUpdateManyWithoutBranchesNestedInput
    Otp?: otpUncheckedUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUncheckedUpdateManyWithoutBranchesNestedInput
    Order?: orderUncheckedUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type walletUpsertWithWhereUniqueWithoutUserInput = {
    where: walletWhereUniqueInput
    update: XOR<walletUpdateWithoutUserInput, walletUncheckedUpdateWithoutUserInput>
    create: XOR<walletCreateWithoutUserInput, walletUncheckedCreateWithoutUserInput>
  }

  export type walletUpdateWithWhereUniqueWithoutUserInput = {
    where: walletWhereUniqueInput
    data: XOR<walletUpdateWithoutUserInput, walletUncheckedUpdateWithoutUserInput>
  }

  export type walletUpdateManyWithWhereWithoutUserInput = {
    where: walletScalarWhereInput
    data: XOR<walletUpdateManyMutationInput, walletUncheckedUpdateManyWithoutUserInput>
  }

  export type walletScalarWhereInput = {
    AND?: walletScalarWhereInput | walletScalarWhereInput[]
    OR?: walletScalarWhereInput[]
    NOT?: walletScalarWhereInput | walletScalarWhereInput[]
    ID?: StringFilter<"wallet"> | string
    Balance?: FloatNullableFilter<"wallet"> | number | null
    Title?: StringNullableFilter<"wallet"> | string | null
    Description?: StringNullableFilter<"wallet"> | string | null
    IsReal?: BoolNullableFilter<"wallet"> | boolean | null
    UserID?: StringNullableFilter<"wallet"> | string | null
    Status?: StringNullableFilter<"wallet"> | string | null
    Remask?: StringNullableFilter<"wallet"> | string | null
    IsActive?: BoolFilter<"wallet"> | boolean
    CreatedAt?: DateTimeFilter<"wallet"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"wallet"> | Date | string | null
  }

  export type orderPaymentUpsertWithWhereUniqueWithoutPaidToInput = {
    where: orderPaymentWhereUniqueInput
    update: XOR<orderPaymentUpdateWithoutPaidToInput, orderPaymentUncheckedUpdateWithoutPaidToInput>
    create: XOR<orderPaymentCreateWithoutPaidToInput, orderPaymentUncheckedCreateWithoutPaidToInput>
  }

  export type orderPaymentUpdateWithWhereUniqueWithoutPaidToInput = {
    where: orderPaymentWhereUniqueInput
    data: XOR<orderPaymentUpdateWithoutPaidToInput, orderPaymentUncheckedUpdateWithoutPaidToInput>
  }

  export type orderPaymentUpdateManyWithWhereWithoutPaidToInput = {
    where: orderPaymentScalarWhereInput
    data: XOR<orderPaymentUpdateManyMutationInput, orderPaymentUncheckedUpdateManyWithoutPaidToInput>
  }

  export type orderPaymentScalarWhereInput = {
    AND?: orderPaymentScalarWhereInput | orderPaymentScalarWhereInput[]
    OR?: orderPaymentScalarWhereInput[]
    NOT?: orderPaymentScalarWhereInput | orderPaymentScalarWhereInput[]
    ID?: StringFilter<"orderPayment"> | string
    PaymentStatus?: StringNullableFilter<"orderPayment"> | string | null
    AmountDeliver?: FloatNullableFilter<"orderPayment"> | number | null
    IsPaid?: BoolFilter<"orderPayment"> | boolean
    OrderID?: StringNullableFilter<"orderPayment"> | string | null
    PaidToID?: StringNullableFilter<"orderPayment"> | string | null
    Status?: StringNullableFilter<"orderPayment"> | string | null
    IsActive?: BoolFilter<"orderPayment"> | boolean
    CreatedAt?: DateTimeFilter<"orderPayment"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderPayment"> | Date | string | null
  }

  export type profileUpsertWithWhereUniqueWithoutAdminInput = {
    where: profileWhereUniqueInput
    update: XOR<profileUpdateWithoutAdminInput, profileUncheckedUpdateWithoutAdminInput>
    create: XOR<profileCreateWithoutAdminInput, profileUncheckedCreateWithoutAdminInput>
  }

  export type profileUpdateWithWhereUniqueWithoutAdminInput = {
    where: profileWhereUniqueInput
    data: XOR<profileUpdateWithoutAdminInput, profileUncheckedUpdateWithoutAdminInput>
  }

  export type profileUpdateManyWithWhereWithoutAdminInput = {
    where: profileScalarWhereInput
    data: XOR<profileUpdateManyMutationInput, profileUncheckedUpdateManyWithoutAdminInput>
  }

  export type profileScalarWhereInput = {
    AND?: profileScalarWhereInput | profileScalarWhereInput[]
    OR?: profileScalarWhereInput[]
    NOT?: profileScalarWhereInput | profileScalarWhereInput[]
    ID?: StringFilter<"profile"> | string
    Gender?: StringNullableFilter<"profile"> | string | null
    Name?: StringFilter<"profile"> | string
    SurName?: StringFilter<"profile"> | string
    ProfileURL?: StringNullableFilter<"profile"> | string | null
    UserID?: StringNullableFilter<"profile"> | string | null
    AdminID?: StringNullableFilter<"profile"> | string | null
    AdminPin?: StringNullableFilter<"profile"> | string | null
    Remask?: StringNullableFilter<"profile"> | string | null
    Status?: StringNullableFilter<"profile"> | string | null
    IsActive?: BoolFilter<"profile"> | boolean
    CreatedAt?: DateTimeFilter<"profile"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"profile"> | Date | string | null
  }

  export type profileUpsertWithoutUserInput = {
    update: XOR<profileUpdateWithoutUserInput, profileUncheckedUpdateWithoutUserInput>
    create: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutUserInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutUserInput, profileUncheckedUpdateWithoutUserInput>
  }

  export type profileUpdateWithoutUserInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    SurName?: StringFieldUpdateOperationsInput | string
    ProfileURL?: NullableStringFieldUpdateOperationsInput | string | null
    AdminPin?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Admin?: usersUpdateOneWithoutAdminProfileNestedInput
    Address?: addressUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutUserInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    SurName?: StringFieldUpdateOperationsInput | string
    ProfileURL?: NullableStringFieldUpdateOperationsInput | string | null
    AdminID?: NullableStringFieldUpdateOperationsInput | string | null
    AdminPin?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type otpUpsertWithWhereUniqueWithoutUsersInput = {
    where: otpWhereUniqueInput
    update: XOR<otpUpdateWithoutUsersInput, otpUncheckedUpdateWithoutUsersInput>
    create: XOR<otpCreateWithoutUsersInput, otpUncheckedCreateWithoutUsersInput>
  }

  export type otpUpdateWithWhereUniqueWithoutUsersInput = {
    where: otpWhereUniqueInput
    data: XOR<otpUpdateWithoutUsersInput, otpUncheckedUpdateWithoutUsersInput>
  }

  export type otpUpdateManyWithWhereWithoutUsersInput = {
    where: otpScalarWhereInput
    data: XOR<otpUpdateManyMutationInput, otpUncheckedUpdateManyWithoutUsersInput>
  }

  export type usersRolesUpsertWithWhereUniqueWithoutUsersInput = {
    where: usersRolesWhereUniqueInput
    update: XOR<usersRolesUpdateWithoutUsersInput, usersRolesUncheckedUpdateWithoutUsersInput>
    create: XOR<usersRolesCreateWithoutUsersInput, usersRolesUncheckedCreateWithoutUsersInput>
  }

  export type usersRolesUpdateWithWhereUniqueWithoutUsersInput = {
    where: usersRolesWhereUniqueInput
    data: XOR<usersRolesUpdateWithoutUsersInput, usersRolesUncheckedUpdateWithoutUsersInput>
  }

  export type usersRolesUpdateManyWithWhereWithoutUsersInput = {
    where: usersRolesScalarWhereInput
    data: XOR<usersRolesUpdateManyMutationInput, usersRolesUncheckedUpdateManyWithoutUsersInput>
  }

  export type usersRolesScalarWhereInput = {
    AND?: usersRolesScalarWhereInput | usersRolesScalarWhereInput[]
    OR?: usersRolesScalarWhereInput[]
    NOT?: usersRolesScalarWhereInput | usersRolesScalarWhereInput[]
    ID?: StringFilter<"usersRoles"> | string
    Titel?: StringNullableFilter<"usersRoles"> | string | null
    Type?: StringNullableFilter<"usersRoles"> | string | null
    Role?: StringFilter<"usersRoles"> | string
    Permission?: StringFilter<"usersRoles"> | string
    Remask?: StringNullableFilter<"usersRoles"> | string | null
    UsersID?: StringNullableFilter<"usersRoles"> | string | null
    Status?: StringNullableFilter<"usersRoles"> | string | null
    IsActive?: BoolFilter<"usersRoles"> | boolean
    CreatedAt?: DateTimeFilter<"usersRoles"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"usersRoles"> | Date | string | null
  }

  export type forgotPasswordUpsertWithWhereUniqueWithoutUsersInput = {
    where: forgotPasswordWhereUniqueInput
    update: XOR<forgotPasswordUpdateWithoutUsersInput, forgotPasswordUncheckedUpdateWithoutUsersInput>
    create: XOR<forgotPasswordCreateWithoutUsersInput, forgotPasswordUncheckedCreateWithoutUsersInput>
  }

  export type forgotPasswordUpdateWithWhereUniqueWithoutUsersInput = {
    where: forgotPasswordWhereUniqueInput
    data: XOR<forgotPasswordUpdateWithoutUsersInput, forgotPasswordUncheckedUpdateWithoutUsersInput>
  }

  export type forgotPasswordUpdateManyWithWhereWithoutUsersInput = {
    where: forgotPasswordScalarWhereInput
    data: XOR<forgotPasswordUpdateManyMutationInput, forgotPasswordUncheckedUpdateManyWithoutUsersInput>
  }

  export type forgotPasswordScalarWhereInput = {
    AND?: forgotPasswordScalarWhereInput | forgotPasswordScalarWhereInput[]
    OR?: forgotPasswordScalarWhereInput[]
    NOT?: forgotPasswordScalarWhereInput | forgotPasswordScalarWhereInput[]
    ID?: StringFilter<"forgotPassword"> | string
    Titel?: StringNullableFilter<"forgotPassword"> | string | null
    Token?: StringNullableFilter<"forgotPassword"> | string | null
    OldPassword?: StringNullableFilter<"forgotPassword"> | string | null
    OtpID?: StringNullableFilter<"forgotPassword"> | string | null
    Provider?: StringNullableFilter<"forgotPassword"> | string | null
    Remask?: StringNullableFilter<"forgotPassword"> | string | null
    UsersID?: StringNullableFilter<"forgotPassword"> | string | null
    Status?: StringNullableFilter<"forgotPassword"> | string | null
    IsActive?: BoolFilter<"forgotPassword"> | boolean
    CreatedAt?: DateTimeFilter<"forgotPassword"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"forgotPassword"> | Date | string | null
  }

  export type notificationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutUsersInput, notificationsUncheckedUpdateWithoutUsersInput>
    create: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutUsersInput, notificationsUncheckedUpdateWithoutUsersInput>
  }

  export type notificationsUpdateManyWithWhereWithoutUsersInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutUsersInput>
  }

  export type usersActivitiesUpsertWithWhereUniqueWithoutUsersInput = {
    where: usersActivitiesWhereUniqueInput
    update: XOR<usersActivitiesUpdateWithoutUsersInput, usersActivitiesUncheckedUpdateWithoutUsersInput>
    create: XOR<usersActivitiesCreateWithoutUsersInput, usersActivitiesUncheckedCreateWithoutUsersInput>
  }

  export type usersActivitiesUpdateWithWhereUniqueWithoutUsersInput = {
    where: usersActivitiesWhereUniqueInput
    data: XOR<usersActivitiesUpdateWithoutUsersInput, usersActivitiesUncheckedUpdateWithoutUsersInput>
  }

  export type usersActivitiesUpdateManyWithWhereWithoutUsersInput = {
    where: usersActivitiesScalarWhereInput
    data: XOR<usersActivitiesUpdateManyMutationInput, usersActivitiesUncheckedUpdateManyWithoutUsersInput>
  }

  export type usersActivitiesScalarWhereInput = {
    AND?: usersActivitiesScalarWhereInput | usersActivitiesScalarWhereInput[]
    OR?: usersActivitiesScalarWhereInput[]
    NOT?: usersActivitiesScalarWhereInput | usersActivitiesScalarWhereInput[]
    ID?: StringFilter<"usersActivities"> | string
    Activity?: StringNullableFilter<"usersActivities"> | string | null
    IP?: StringNullableFilter<"usersActivities"> | string | null
    MacAddress?: StringNullableFilter<"usersActivities"> | string | null
    UDID?: StringNullableFilter<"usersActivities"> | string | null
    Remask?: StringNullableFilter<"usersActivities"> | string | null
    Log?: StringNullableFilter<"usersActivities"> | string | null
    Error?: StringNullableFilter<"usersActivities"> | string | null
    Messages?: StringNullableFilter<"usersActivities"> | string | null
    UsersID?: StringNullableFilter<"usersActivities"> | string | null
    Status?: StringNullableFilter<"usersActivities"> | string | null
    IsActive?: BoolFilter<"usersActivities"> | boolean
    CreatedAt?: DateTimeFilter<"usersActivities"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"usersActivities"> | Date | string | null
  }

  export type orderUpsertWithWhereUniqueWithoutCreateByInput = {
    where: orderWhereUniqueInput
    update: XOR<orderUpdateWithoutCreateByInput, orderUncheckedUpdateWithoutCreateByInput>
    create: XOR<orderCreateWithoutCreateByInput, orderUncheckedCreateWithoutCreateByInput>
  }

  export type orderUpdateWithWhereUniqueWithoutCreateByInput = {
    where: orderWhereUniqueInput
    data: XOR<orderUpdateWithoutCreateByInput, orderUncheckedUpdateWithoutCreateByInput>
  }

  export type orderUpdateManyWithWhereWithoutCreateByInput = {
    where: orderScalarWhereInput
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyWithoutCreateByInput>
  }

  export type orderPersonalUpsertWithWhereUniqueWithoutSenderUserInput = {
    where: orderPersonalWhereUniqueInput
    update: XOR<orderPersonalUpdateWithoutSenderUserInput, orderPersonalUncheckedUpdateWithoutSenderUserInput>
    create: XOR<orderPersonalCreateWithoutSenderUserInput, orderPersonalUncheckedCreateWithoutSenderUserInput>
  }

  export type orderPersonalUpdateWithWhereUniqueWithoutSenderUserInput = {
    where: orderPersonalWhereUniqueInput
    data: XOR<orderPersonalUpdateWithoutSenderUserInput, orderPersonalUncheckedUpdateWithoutSenderUserInput>
  }

  export type orderPersonalUpdateManyWithWhereWithoutSenderUserInput = {
    where: orderPersonalScalarWhereInput
    data: XOR<orderPersonalUpdateManyMutationInput, orderPersonalUncheckedUpdateManyWithoutSenderUserInput>
  }

  export type orderPersonalScalarWhereInput = {
    AND?: orderPersonalScalarWhereInput | orderPersonalScalarWhereInput[]
    OR?: orderPersonalScalarWhereInput[]
    NOT?: orderPersonalScalarWhereInput | orderPersonalScalarWhereInput[]
    ID?: StringFilter<"orderPersonal"> | string
    SenderName?: StringNullableFilter<"orderPersonal"> | string | null
    SenderPhoneNumber?: StringNullableFilter<"orderPersonal"> | string | null
    SenderUserID?: StringNullableFilter<"orderPersonal"> | string | null
    RecipientName?: StringNullableFilter<"orderPersonal"> | string | null
    RecipientPhoneNumber?: StringNullableFilter<"orderPersonal"> | string | null
    RecipientID?: StringNullableFilter<"orderPersonal"> | string | null
    OrderID?: StringNullableFilter<"orderPersonal"> | string | null
    Status?: StringNullableFilter<"orderPersonal"> | string | null
    IsActive?: BoolFilter<"orderPersonal"> | boolean
    CreatedAt?: DateTimeFilter<"orderPersonal"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderPersonal"> | Date | string | null
  }

  export type orderPersonalUpsertWithWhereUniqueWithoutRecipientUserInput = {
    where: orderPersonalWhereUniqueInput
    update: XOR<orderPersonalUpdateWithoutRecipientUserInput, orderPersonalUncheckedUpdateWithoutRecipientUserInput>
    create: XOR<orderPersonalCreateWithoutRecipientUserInput, orderPersonalUncheckedCreateWithoutRecipientUserInput>
  }

  export type orderPersonalUpdateWithWhereUniqueWithoutRecipientUserInput = {
    where: orderPersonalWhereUniqueInput
    data: XOR<orderPersonalUpdateWithoutRecipientUserInput, orderPersonalUncheckedUpdateWithoutRecipientUserInput>
  }

  export type orderPersonalUpdateManyWithWhereWithoutRecipientUserInput = {
    where: orderPersonalScalarWhereInput
    data: XOR<orderPersonalUpdateManyMutationInput, orderPersonalUncheckedUpdateManyWithoutRecipientUserInput>
  }

  export type usersCreateWithoutUserProfileInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutUserInput
    Wallet?: walletCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileCreateNestedManyWithoutAdminInput
    OTP?: otpCreateNestedManyWithoutUsersInput
    Roles?: usersRolesCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordCreateNestedManyWithoutUsersInput
    Notifications?: notificationsCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesCreateNestedManyWithoutUsersInput
    Order?: orderCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalCreateNestedManyWithoutRecipientUserInput
  }

  export type usersUncheckedCreateWithoutUserProfileInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    BranchesID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Wallet?: walletUncheckedCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentUncheckedCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileUncheckedCreateNestedManyWithoutAdminInput
    OTP?: otpUncheckedCreateNestedManyWithoutUsersInput
    Roles?: usersRolesUncheckedCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesUncheckedCreateNestedManyWithoutUsersInput
    Order?: orderUncheckedCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalUncheckedCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalUncheckedCreateNestedManyWithoutRecipientUserInput
  }

  export type usersCreateOrConnectWithoutUserProfileInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUserProfileInput, usersUncheckedCreateWithoutUserProfileInput>
  }

  export type usersCreateWithoutAdminProfileInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutUserInput
    Wallet?: walletCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentCreateNestedManyWithoutPaidToInput
    UserProfile?: profileCreateNestedOneWithoutUserInput
    OTP?: otpCreateNestedManyWithoutUsersInput
    Roles?: usersRolesCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordCreateNestedManyWithoutUsersInput
    Notifications?: notificationsCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesCreateNestedManyWithoutUsersInput
    Order?: orderCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalCreateNestedManyWithoutRecipientUserInput
  }

  export type usersUncheckedCreateWithoutAdminProfileInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    BranchesID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Wallet?: walletUncheckedCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentUncheckedCreateNestedManyWithoutPaidToInput
    UserProfile?: profileUncheckedCreateNestedOneWithoutUserInput
    OTP?: otpUncheckedCreateNestedManyWithoutUsersInput
    Roles?: usersRolesUncheckedCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesUncheckedCreateNestedManyWithoutUsersInput
    Order?: orderUncheckedCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalUncheckedCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalUncheckedCreateNestedManyWithoutRecipientUserInput
  }

  export type usersCreateOrConnectWithoutAdminProfileInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAdminProfileInput, usersUncheckedCreateWithoutAdminProfileInput>
  }

  export type addressCreateWithoutProfileInput = {
    ID?: string
    Address: string
    IsDefault?: boolean | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Province?: provinceCreateNestedOneWithoutAddressInput
    District?: districtCreateNestedOneWithoutAddressInput
    Branches?: branchesCreateNestedOneWithoutAddressInput
  }

  export type addressUncheckedCreateWithoutProfileInput = {
    ID?: string
    Address: string
    ProvinceID?: string | null
    DistrictID?: string | null
    BranchesID?: string | null
    IsDefault?: boolean | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type addressCreateOrConnectWithoutProfileInput = {
    where: addressWhereUniqueInput
    create: XOR<addressCreateWithoutProfileInput, addressUncheckedCreateWithoutProfileInput>
  }

  export type addressCreateManyProfileInputEnvelope = {
    data: addressCreateManyProfileInput | addressCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutUserProfileInput = {
    update: XOR<usersUpdateWithoutUserProfileInput, usersUncheckedUpdateWithoutUserProfileInput>
    create: XOR<usersCreateWithoutUserProfileInput, usersUncheckedCreateWithoutUserProfileInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUserProfileInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUserProfileInput, usersUncheckedUpdateWithoutUserProfileInput>
  }

  export type usersUpdateWithoutUserProfileInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutUserNestedInput
    Wallet?: walletUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUpdateManyWithoutAdminNestedInput
    OTP?: otpUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUpdateManyWithoutUsersNestedInput
    Order?: orderUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersUncheckedUpdateWithoutUserProfileInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Wallet?: walletUncheckedUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUncheckedUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUncheckedUpdateManyWithoutAdminNestedInput
    OTP?: otpUncheckedUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUncheckedUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUncheckedUpdateManyWithoutUsersNestedInput
    Order?: orderUncheckedUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUncheckedUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUncheckedUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersUpsertWithoutAdminProfileInput = {
    update: XOR<usersUpdateWithoutAdminProfileInput, usersUncheckedUpdateWithoutAdminProfileInput>
    create: XOR<usersCreateWithoutAdminProfileInput, usersUncheckedCreateWithoutAdminProfileInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAdminProfileInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAdminProfileInput, usersUncheckedUpdateWithoutAdminProfileInput>
  }

  export type usersUpdateWithoutAdminProfileInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutUserNestedInput
    Wallet?: walletUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUpdateManyWithoutPaidToNestedInput
    UserProfile?: profileUpdateOneWithoutUserNestedInput
    OTP?: otpUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUpdateManyWithoutUsersNestedInput
    Order?: orderUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersUncheckedUpdateWithoutAdminProfileInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Wallet?: walletUncheckedUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUncheckedUpdateManyWithoutPaidToNestedInput
    UserProfile?: profileUncheckedUpdateOneWithoutUserNestedInput
    OTP?: otpUncheckedUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUncheckedUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUncheckedUpdateManyWithoutUsersNestedInput
    Order?: orderUncheckedUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUncheckedUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUncheckedUpdateManyWithoutRecipientUserNestedInput
  }

  export type addressUpsertWithWhereUniqueWithoutProfileInput = {
    where: addressWhereUniqueInput
    update: XOR<addressUpdateWithoutProfileInput, addressUncheckedUpdateWithoutProfileInput>
    create: XOR<addressCreateWithoutProfileInput, addressUncheckedCreateWithoutProfileInput>
  }

  export type addressUpdateWithWhereUniqueWithoutProfileInput = {
    where: addressWhereUniqueInput
    data: XOR<addressUpdateWithoutProfileInput, addressUncheckedUpdateWithoutProfileInput>
  }

  export type addressUpdateManyWithWhereWithoutProfileInput = {
    where: addressScalarWhereInput
    data: XOR<addressUpdateManyMutationInput, addressUncheckedUpdateManyWithoutProfileInput>
  }

  export type usersCreateWithoutOTPInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutUserInput
    Wallet?: walletCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileCreateNestedManyWithoutAdminInput
    UserProfile?: profileCreateNestedOneWithoutUserInput
    Roles?: usersRolesCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordCreateNestedManyWithoutUsersInput
    Notifications?: notificationsCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesCreateNestedManyWithoutUsersInput
    Order?: orderCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalCreateNestedManyWithoutRecipientUserInput
  }

  export type usersUncheckedCreateWithoutOTPInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    BranchesID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Wallet?: walletUncheckedCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentUncheckedCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileUncheckedCreateNestedManyWithoutAdminInput
    UserProfile?: profileUncheckedCreateNestedOneWithoutUserInput
    Roles?: usersRolesUncheckedCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesUncheckedCreateNestedManyWithoutUsersInput
    Order?: orderUncheckedCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalUncheckedCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalUncheckedCreateNestedManyWithoutRecipientUserInput
  }

  export type usersCreateOrConnectWithoutOTPInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutOTPInput, usersUncheckedCreateWithoutOTPInput>
  }

  export type branchesCreateWithoutOtpInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressCreateNestedOneWithoutBranchesInput
    User?: usersCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyCreateNestedManyWithoutBranchesInput
    BranchesSettings?: branchesSettingsCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryCreateNestedManyWithoutBranchesInput
    Order?: orderCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutOtpInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressUncheckedCreateNestedOneWithoutBranchesInput
    User?: usersUncheckedCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyUncheckedCreateNestedManyWithoutBranchesInput
    BranchesSettings?: branchesSettingsUncheckedCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryUncheckedCreateNestedManyWithoutBranchesInput
    Order?: orderUncheckedCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutOtpInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutOtpInput, branchesUncheckedCreateWithoutOtpInput>
  }

  export type usersUpsertWithoutOTPInput = {
    update: XOR<usersUpdateWithoutOTPInput, usersUncheckedUpdateWithoutOTPInput>
    create: XOR<usersCreateWithoutOTPInput, usersUncheckedCreateWithoutOTPInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutOTPInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutOTPInput, usersUncheckedUpdateWithoutOTPInput>
  }

  export type usersUpdateWithoutOTPInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutUserNestedInput
    Wallet?: walletUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUpdateOneWithoutUserNestedInput
    Roles?: usersRolesUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUpdateManyWithoutUsersNestedInput
    Order?: orderUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersUncheckedUpdateWithoutOTPInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Wallet?: walletUncheckedUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUncheckedUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUncheckedUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUncheckedUpdateOneWithoutUserNestedInput
    Roles?: usersRolesUncheckedUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUncheckedUpdateManyWithoutUsersNestedInput
    Order?: orderUncheckedUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUncheckedUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUncheckedUpdateManyWithoutRecipientUserNestedInput
  }

  export type branchesUpsertWithoutOtpInput = {
    update: XOR<branchesUpdateWithoutOtpInput, branchesUncheckedUpdateWithoutOtpInput>
    create: XOR<branchesCreateWithoutOtpInput, branchesUncheckedCreateWithoutOtpInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutOtpInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutOtpInput, branchesUncheckedUpdateWithoutOtpInput>
  }

  export type branchesUpdateWithoutOtpInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUpdateOneWithoutBranchesNestedInput
    User?: usersUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUpdateManyWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUpdateManyWithoutBranchesNestedInput
    Order?: orderUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutOtpInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUncheckedUpdateOneWithoutBranchesNestedInput
    User?: usersUncheckedUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUncheckedUpdateManyWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUncheckedUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUncheckedUpdateManyWithoutBranchesNestedInput
    Order?: orderUncheckedUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type usersCreateWithoutNotificationsInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutUserInput
    Wallet?: walletCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileCreateNestedManyWithoutAdminInput
    UserProfile?: profileCreateNestedOneWithoutUserInput
    OTP?: otpCreateNestedManyWithoutUsersInput
    Roles?: usersRolesCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesCreateNestedManyWithoutUsersInput
    Order?: orderCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalCreateNestedManyWithoutRecipientUserInput
  }

  export type usersUncheckedCreateWithoutNotificationsInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    BranchesID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Wallet?: walletUncheckedCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentUncheckedCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileUncheckedCreateNestedManyWithoutAdminInput
    UserProfile?: profileUncheckedCreateNestedOneWithoutUserInput
    OTP?: otpUncheckedCreateNestedManyWithoutUsersInput
    Roles?: usersRolesUncheckedCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordUncheckedCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesUncheckedCreateNestedManyWithoutUsersInput
    Order?: orderUncheckedCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalUncheckedCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalUncheckedCreateNestedManyWithoutRecipientUserInput
  }

  export type usersCreateOrConnectWithoutNotificationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
  }

  export type branchesCreateWithoutNotificationsInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressCreateNestedOneWithoutBranchesInput
    User?: usersCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyCreateNestedManyWithoutBranchesInput
    BranchesSettings?: branchesSettingsCreateNestedManyWithoutBranchesInput
    Otp?: otpCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryCreateNestedManyWithoutBranchesInput
    Order?: orderCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutNotificationsInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressUncheckedCreateNestedOneWithoutBranchesInput
    User?: usersUncheckedCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyUncheckedCreateNestedManyWithoutBranchesInput
    BranchesSettings?: branchesSettingsUncheckedCreateNestedManyWithoutBranchesInput
    Otp?: otpUncheckedCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryUncheckedCreateNestedManyWithoutBranchesInput
    Order?: orderUncheckedCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutNotificationsInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutNotificationsInput, branchesUncheckedCreateWithoutNotificationsInput>
  }

  export type usersUpsertWithoutNotificationsInput = {
    update: XOR<usersUpdateWithoutNotificationsInput, usersUncheckedUpdateWithoutNotificationsInput>
    create: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotificationsInput, usersUncheckedUpdateWithoutNotificationsInput>
  }

  export type usersUpdateWithoutNotificationsInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutUserNestedInput
    Wallet?: walletUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUpdateOneWithoutUserNestedInput
    OTP?: otpUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUpdateManyWithoutUsersNestedInput
    Order?: orderUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersUncheckedUpdateWithoutNotificationsInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Wallet?: walletUncheckedUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUncheckedUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUncheckedUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUncheckedUpdateOneWithoutUserNestedInput
    OTP?: otpUncheckedUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUncheckedUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUncheckedUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUncheckedUpdateManyWithoutUsersNestedInput
    Order?: orderUncheckedUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUncheckedUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUncheckedUpdateManyWithoutRecipientUserNestedInput
  }

  export type branchesUpsertWithoutNotificationsInput = {
    update: XOR<branchesUpdateWithoutNotificationsInput, branchesUncheckedUpdateWithoutNotificationsInput>
    create: XOR<branchesCreateWithoutNotificationsInput, branchesUncheckedCreateWithoutNotificationsInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutNotificationsInput, branchesUncheckedUpdateWithoutNotificationsInput>
  }

  export type branchesUpdateWithoutNotificationsInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUpdateOneWithoutBranchesNestedInput
    User?: usersUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUpdateManyWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUpdateManyWithoutBranchesNestedInput
    Otp?: otpUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUpdateManyWithoutBranchesNestedInput
    Order?: orderUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutNotificationsInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUncheckedUpdateOneWithoutBranchesNestedInput
    User?: usersUncheckedUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUncheckedUpdateManyWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUncheckedUpdateManyWithoutBranchesNestedInput
    Otp?: otpUncheckedUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUncheckedUpdateManyWithoutBranchesNestedInput
    Order?: orderUncheckedUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type usersCreateWithoutForgotInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutUserInput
    Wallet?: walletCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileCreateNestedManyWithoutAdminInput
    UserProfile?: profileCreateNestedOneWithoutUserInput
    OTP?: otpCreateNestedManyWithoutUsersInput
    Roles?: usersRolesCreateNestedManyWithoutUsersInput
    Notifications?: notificationsCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesCreateNestedManyWithoutUsersInput
    Order?: orderCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalCreateNestedManyWithoutRecipientUserInput
  }

  export type usersUncheckedCreateWithoutForgotInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    BranchesID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Wallet?: walletUncheckedCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentUncheckedCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileUncheckedCreateNestedManyWithoutAdminInput
    UserProfile?: profileUncheckedCreateNestedOneWithoutUserInput
    OTP?: otpUncheckedCreateNestedManyWithoutUsersInput
    Roles?: usersRolesUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesUncheckedCreateNestedManyWithoutUsersInput
    Order?: orderUncheckedCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalUncheckedCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalUncheckedCreateNestedManyWithoutRecipientUserInput
  }

  export type usersCreateOrConnectWithoutForgotInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutForgotInput, usersUncheckedCreateWithoutForgotInput>
  }

  export type usersUpsertWithoutForgotInput = {
    update: XOR<usersUpdateWithoutForgotInput, usersUncheckedUpdateWithoutForgotInput>
    create: XOR<usersCreateWithoutForgotInput, usersUncheckedCreateWithoutForgotInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutForgotInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutForgotInput, usersUncheckedUpdateWithoutForgotInput>
  }

  export type usersUpdateWithoutForgotInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutUserNestedInput
    Wallet?: walletUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUpdateOneWithoutUserNestedInput
    OTP?: otpUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUpdateManyWithoutUsersNestedInput
    Order?: orderUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersUncheckedUpdateWithoutForgotInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Wallet?: walletUncheckedUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUncheckedUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUncheckedUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUncheckedUpdateOneWithoutUserNestedInput
    OTP?: otpUncheckedUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUncheckedUpdateManyWithoutUsersNestedInput
    Order?: orderUncheckedUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUncheckedUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUncheckedUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersCreateWithoutRolesInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutUserInput
    Wallet?: walletCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileCreateNestedManyWithoutAdminInput
    UserProfile?: profileCreateNestedOneWithoutUserInput
    OTP?: otpCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordCreateNestedManyWithoutUsersInput
    Notifications?: notificationsCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesCreateNestedManyWithoutUsersInput
    Order?: orderCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalCreateNestedManyWithoutRecipientUserInput
  }

  export type usersUncheckedCreateWithoutRolesInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    BranchesID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Wallet?: walletUncheckedCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentUncheckedCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileUncheckedCreateNestedManyWithoutAdminInput
    UserProfile?: profileUncheckedCreateNestedOneWithoutUserInput
    OTP?: otpUncheckedCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesUncheckedCreateNestedManyWithoutUsersInput
    Order?: orderUncheckedCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalUncheckedCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalUncheckedCreateNestedManyWithoutRecipientUserInput
  }

  export type usersCreateOrConnectWithoutRolesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput>
  }

  export type usersUpsertWithoutRolesInput = {
    update: XOR<usersUpdateWithoutRolesInput, usersUncheckedUpdateWithoutRolesInput>
    create: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutRolesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutRolesInput, usersUncheckedUpdateWithoutRolesInput>
  }

  export type usersUpdateWithoutRolesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutUserNestedInput
    Wallet?: walletUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUpdateOneWithoutUserNestedInput
    OTP?: otpUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUpdateManyWithoutUsersNestedInput
    Order?: orderUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersUncheckedUpdateWithoutRolesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Wallet?: walletUncheckedUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUncheckedUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUncheckedUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUncheckedUpdateOneWithoutUserNestedInput
    OTP?: otpUncheckedUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUncheckedUpdateManyWithoutUsersNestedInput
    Order?: orderUncheckedUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUncheckedUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUncheckedUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersCreateWithoutActivitiesInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutUserInput
    Wallet?: walletCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileCreateNestedManyWithoutAdminInput
    UserProfile?: profileCreateNestedOneWithoutUserInput
    OTP?: otpCreateNestedManyWithoutUsersInput
    Roles?: usersRolesCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordCreateNestedManyWithoutUsersInput
    Notifications?: notificationsCreateNestedManyWithoutUsersInput
    Order?: orderCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalCreateNestedManyWithoutRecipientUserInput
  }

  export type usersUncheckedCreateWithoutActivitiesInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    BranchesID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Wallet?: walletUncheckedCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentUncheckedCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileUncheckedCreateNestedManyWithoutAdminInput
    UserProfile?: profileUncheckedCreateNestedOneWithoutUserInput
    OTP?: otpUncheckedCreateNestedManyWithoutUsersInput
    Roles?: usersRolesUncheckedCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    Order?: orderUncheckedCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalUncheckedCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalUncheckedCreateNestedManyWithoutRecipientUserInput
  }

  export type usersCreateOrConnectWithoutActivitiesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutActivitiesInput, usersUncheckedCreateWithoutActivitiesInput>
  }

  export type orderThreadingCreateWithoutActivitieInput = {
    ID?: string
    Tasks?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Order?: orderCreateNestedOneWithoutThreadingInput
  }

  export type orderThreadingUncheckedCreateWithoutActivitieInput = {
    ID?: string
    Tasks?: string | null
    OrderID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderThreadingCreateOrConnectWithoutActivitieInput = {
    where: orderThreadingWhereUniqueInput
    create: XOR<orderThreadingCreateWithoutActivitieInput, orderThreadingUncheckedCreateWithoutActivitieInput>
  }

  export type usersUpsertWithoutActivitiesInput = {
    update: XOR<usersUpdateWithoutActivitiesInput, usersUncheckedUpdateWithoutActivitiesInput>
    create: XOR<usersCreateWithoutActivitiesInput, usersUncheckedCreateWithoutActivitiesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutActivitiesInput, usersUncheckedUpdateWithoutActivitiesInput>
  }

  export type usersUpdateWithoutActivitiesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutUserNestedInput
    Wallet?: walletUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUpdateOneWithoutUserNestedInput
    OTP?: otpUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUpdateManyWithoutUsersNestedInput
    Order?: orderUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersUncheckedUpdateWithoutActivitiesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Wallet?: walletUncheckedUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUncheckedUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUncheckedUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUncheckedUpdateOneWithoutUserNestedInput
    OTP?: otpUncheckedUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUncheckedUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    Order?: orderUncheckedUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUncheckedUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUncheckedUpdateManyWithoutRecipientUserNestedInput
  }

  export type orderThreadingUpsertWithoutActivitieInput = {
    update: XOR<orderThreadingUpdateWithoutActivitieInput, orderThreadingUncheckedUpdateWithoutActivitieInput>
    create: XOR<orderThreadingCreateWithoutActivitieInput, orderThreadingUncheckedCreateWithoutActivitieInput>
    where?: orderThreadingWhereInput
  }

  export type orderThreadingUpdateToOneWithWhereWithoutActivitieInput = {
    where?: orderThreadingWhereInput
    data: XOR<orderThreadingUpdateWithoutActivitieInput, orderThreadingUncheckedUpdateWithoutActivitieInput>
  }

  export type orderThreadingUpdateWithoutActivitieInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Tasks?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Order?: orderUpdateOneWithoutThreadingNestedInput
  }

  export type orderThreadingUncheckedUpdateWithoutActivitieInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Tasks?: NullableStringFieldUpdateOperationsInput | string | null
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type branchesCreateWithoutOrderCategoryInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressCreateNestedOneWithoutBranchesInput
    User?: usersCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyCreateNestedManyWithoutBranchesInput
    BranchesSettings?: branchesSettingsCreateNestedManyWithoutBranchesInput
    Otp?: otpCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsCreateNestedManyWithoutBranchesInput
    Order?: orderCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutOrderCategoryInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressUncheckedCreateNestedOneWithoutBranchesInput
    User?: usersUncheckedCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyUncheckedCreateNestedManyWithoutBranchesInput
    BranchesSettings?: branchesSettingsUncheckedCreateNestedManyWithoutBranchesInput
    Otp?: otpUncheckedCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutBranchesInput
    Order?: orderUncheckedCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutOrderCategoryInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutOrderCategoryInput, branchesUncheckedCreateWithoutOrderCategoryInput>
  }

  export type orderCreateWithoutCategoryInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Personal?: orderPersonalCreateNestedOneWithoutOrderInput
    Details?: orderDetailsCreateNestedOneWithoutOrderInput
    Payment?: orderPaymentCreateNestedOneWithoutOrderInput
    Branches?: branchesCreateNestedOneWithoutOrderInput
    CreateBy?: usersCreateNestedOneWithoutOrderInput
    Tacking?: orderTackingCreateNestedManyWithoutOrderInput
    Threading?: orderThreadingCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutCategoryInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    BranchesID?: string | null
    CreateByID?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Personal?: orderPersonalUncheckedCreateNestedOneWithoutOrderInput
    Details?: orderDetailsUncheckedCreateNestedOneWithoutOrderInput
    Payment?: orderPaymentUncheckedCreateNestedOneWithoutOrderInput
    Tacking?: orderTackingUncheckedCreateNestedManyWithoutOrderInput
    Threading?: orderThreadingUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutCategoryInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutCategoryInput, orderUncheckedCreateWithoutCategoryInput>
  }

  export type orderCreateManyCategoryInputEnvelope = {
    data: orderCreateManyCategoryInput | orderCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type branchesUpsertWithoutOrderCategoryInput = {
    update: XOR<branchesUpdateWithoutOrderCategoryInput, branchesUncheckedUpdateWithoutOrderCategoryInput>
    create: XOR<branchesCreateWithoutOrderCategoryInput, branchesUncheckedCreateWithoutOrderCategoryInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutOrderCategoryInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutOrderCategoryInput, branchesUncheckedUpdateWithoutOrderCategoryInput>
  }

  export type branchesUpdateWithoutOrderCategoryInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUpdateOneWithoutBranchesNestedInput
    User?: usersUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUpdateManyWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUpdateManyWithoutBranchesNestedInput
    Otp?: otpUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUpdateManyWithoutBranchesNestedInput
    Order?: orderUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutOrderCategoryInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUncheckedUpdateOneWithoutBranchesNestedInput
    User?: usersUncheckedUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUncheckedUpdateManyWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUncheckedUpdateManyWithoutBranchesNestedInput
    Otp?: otpUncheckedUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutBranchesNestedInput
    Order?: orderUncheckedUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type orderUpsertWithWhereUniqueWithoutCategoryInput = {
    where: orderWhereUniqueInput
    update: XOR<orderUpdateWithoutCategoryInput, orderUncheckedUpdateWithoutCategoryInput>
    create: XOR<orderCreateWithoutCategoryInput, orderUncheckedCreateWithoutCategoryInput>
  }

  export type orderUpdateWithWhereUniqueWithoutCategoryInput = {
    where: orderWhereUniqueInput
    data: XOR<orderUpdateWithoutCategoryInput, orderUncheckedUpdateWithoutCategoryInput>
  }

  export type orderUpdateManyWithWhereWithoutCategoryInput = {
    where: orderScalarWhereInput
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyWithoutCategoryInput>
  }

  export type orderCategoryCreateWithoutOrderInput = {
    ID?: string
    TypeCode?: string | null
    TypeNmae?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutOrderCategoryInput
  }

  export type orderCategoryUncheckedCreateWithoutOrderInput = {
    ID?: string
    TypeCode?: string | null
    TypeNmae?: string | null
    Remask?: string | null
    BranchesID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderCategoryCreateOrConnectWithoutOrderInput = {
    where: orderCategoryWhereUniqueInput
    create: XOR<orderCategoryCreateWithoutOrderInput, orderCategoryUncheckedCreateWithoutOrderInput>
  }

  export type orderPersonalCreateWithoutOrderInput = {
    ID?: string
    SenderName?: string | null
    SenderPhoneNumber?: string | null
    RecipientName?: string | null
    RecipientPhoneNumber?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    SenderUser?: usersCreateNestedOneWithoutSenderOrderInput
    RecipientUser?: usersCreateNestedOneWithoutRecipientOrderInput
  }

  export type orderPersonalUncheckedCreateWithoutOrderInput = {
    ID?: string
    SenderName?: string | null
    SenderPhoneNumber?: string | null
    SenderUserID?: string | null
    RecipientName?: string | null
    RecipientPhoneNumber?: string | null
    RecipientID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderPersonalCreateOrConnectWithoutOrderInput = {
    where: orderPersonalWhereUniqueInput
    create: XOR<orderPersonalCreateWithoutOrderInput, orderPersonalUncheckedCreateWithoutOrderInput>
  }

  export type orderDetailsCreateWithoutOrderInput = {
    ID?: string
    Detail?: string | null
    AmountX?: number | null
    AmountY?: number | null
    AmountH?: number | null
    AmountW?: number | null
    Amount?: number | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderDetailsUncheckedCreateWithoutOrderInput = {
    ID?: string
    Detail?: string | null
    AmountX?: number | null
    AmountY?: number | null
    AmountH?: number | null
    AmountW?: number | null
    Amount?: number | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderDetailsCreateOrConnectWithoutOrderInput = {
    where: orderDetailsWhereUniqueInput
    create: XOR<orderDetailsCreateWithoutOrderInput, orderDetailsUncheckedCreateWithoutOrderInput>
  }

  export type orderPaymentCreateWithoutOrderInput = {
    ID?: string
    PaymentStatus?: string | null
    AmountDeliver?: number | null
    IsPaid?: boolean
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    PaidTo?: usersCreateNestedOneWithoutRecipientPaymentInput
    Transaction?: transactionCreateNestedOneWithoutOrderPaymentInput
  }

  export type orderPaymentUncheckedCreateWithoutOrderInput = {
    ID?: string
    PaymentStatus?: string | null
    AmountDeliver?: number | null
    IsPaid?: boolean
    PaidToID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Transaction?: transactionUncheckedCreateNestedOneWithoutOrderPaymentInput
  }

  export type orderPaymentCreateOrConnectWithoutOrderInput = {
    where: orderPaymentWhereUniqueInput
    create: XOR<orderPaymentCreateWithoutOrderInput, orderPaymentUncheckedCreateWithoutOrderInput>
  }

  export type branchesCreateWithoutOrderInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressCreateNestedOneWithoutBranchesInput
    User?: usersCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyCreateNestedManyWithoutBranchesInput
    BranchesSettings?: branchesSettingsCreateNestedManyWithoutBranchesInput
    Otp?: otpCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutOrderInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressUncheckedCreateNestedOneWithoutBranchesInput
    User?: usersUncheckedCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyUncheckedCreateNestedManyWithoutBranchesInput
    BranchesSettings?: branchesSettingsUncheckedCreateNestedManyWithoutBranchesInput
    Otp?: otpUncheckedCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryUncheckedCreateNestedManyWithoutBranchesInput
    Tracking?: orderTackingUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutOrderInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutOrderInput, branchesUncheckedCreateWithoutOrderInput>
  }

  export type usersCreateWithoutOrderInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutUserInput
    Wallet?: walletCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileCreateNestedManyWithoutAdminInput
    UserProfile?: profileCreateNestedOneWithoutUserInput
    OTP?: otpCreateNestedManyWithoutUsersInput
    Roles?: usersRolesCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordCreateNestedManyWithoutUsersInput
    Notifications?: notificationsCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesCreateNestedManyWithoutUsersInput
    SenderOrder?: orderPersonalCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalCreateNestedManyWithoutRecipientUserInput
  }

  export type usersUncheckedCreateWithoutOrderInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    BranchesID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Wallet?: walletUncheckedCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentUncheckedCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileUncheckedCreateNestedManyWithoutAdminInput
    UserProfile?: profileUncheckedCreateNestedOneWithoutUserInput
    OTP?: otpUncheckedCreateNestedManyWithoutUsersInput
    Roles?: usersRolesUncheckedCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesUncheckedCreateNestedManyWithoutUsersInput
    SenderOrder?: orderPersonalUncheckedCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalUncheckedCreateNestedManyWithoutRecipientUserInput
  }

  export type usersCreateOrConnectWithoutOrderInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutOrderInput, usersUncheckedCreateWithoutOrderInput>
  }

  export type orderTackingCreateWithoutOrderInput = {
    ID?: string
    Number?: string | null
    PrimaryPhoneNumber?: string | null
    SecondaryName?: string | null
    SecondaryPhoneNumber?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutTrackingInput
    TrackingStatus?: tackingStatusCreateNestedOneWithoutTrackingInput
  }

  export type orderTackingUncheckedCreateWithoutOrderInput = {
    ID?: string
    Number?: string | null
    PrimaryPhoneNumber?: string | null
    SecondaryName?: string | null
    SecondaryPhoneNumber?: string | null
    BranchesID?: string | null
    TrackingStatusID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderTackingCreateOrConnectWithoutOrderInput = {
    where: orderTackingWhereUniqueInput
    create: XOR<orderTackingCreateWithoutOrderInput, orderTackingUncheckedCreateWithoutOrderInput>
  }

  export type orderTackingCreateManyOrderInputEnvelope = {
    data: orderTackingCreateManyOrderInput | orderTackingCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type orderThreadingCreateWithoutOrderInput = {
    ID?: string
    Tasks?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Activitie?: usersActivitiesCreateNestedOneWithoutThreadingOrderInput
  }

  export type orderThreadingUncheckedCreateWithoutOrderInput = {
    ID?: string
    Tasks?: string | null
    ActivitieID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderThreadingCreateOrConnectWithoutOrderInput = {
    where: orderThreadingWhereUniqueInput
    create: XOR<orderThreadingCreateWithoutOrderInput, orderThreadingUncheckedCreateWithoutOrderInput>
  }

  export type orderThreadingCreateManyOrderInputEnvelope = {
    data: orderThreadingCreateManyOrderInput | orderThreadingCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type orderCategoryUpsertWithoutOrderInput = {
    update: XOR<orderCategoryUpdateWithoutOrderInput, orderCategoryUncheckedUpdateWithoutOrderInput>
    create: XOR<orderCategoryCreateWithoutOrderInput, orderCategoryUncheckedCreateWithoutOrderInput>
    where?: orderCategoryWhereInput
  }

  export type orderCategoryUpdateToOneWithWhereWithoutOrderInput = {
    where?: orderCategoryWhereInput
    data: XOR<orderCategoryUpdateWithoutOrderInput, orderCategoryUncheckedUpdateWithoutOrderInput>
  }

  export type orderCategoryUpdateWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    TypeCode?: NullableStringFieldUpdateOperationsInput | string | null
    TypeNmae?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutOrderCategoryNestedInput
  }

  export type orderCategoryUncheckedUpdateWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    TypeCode?: NullableStringFieldUpdateOperationsInput | string | null
    TypeNmae?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderPersonalUpsertWithoutOrderInput = {
    update: XOR<orderPersonalUpdateWithoutOrderInput, orderPersonalUncheckedUpdateWithoutOrderInput>
    create: XOR<orderPersonalCreateWithoutOrderInput, orderPersonalUncheckedCreateWithoutOrderInput>
    where?: orderPersonalWhereInput
  }

  export type orderPersonalUpdateToOneWithWhereWithoutOrderInput = {
    where?: orderPersonalWhereInput
    data: XOR<orderPersonalUpdateWithoutOrderInput, orderPersonalUncheckedUpdateWithoutOrderInput>
  }

  export type orderPersonalUpdateWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    SenderPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientName?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SenderUser?: usersUpdateOneWithoutSenderOrderNestedInput
    RecipientUser?: usersUpdateOneWithoutRecipientOrderNestedInput
  }

  export type orderPersonalUncheckedUpdateWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    SenderPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SenderUserID?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientName?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderDetailsUpsertWithoutOrderInput = {
    update: XOR<orderDetailsUpdateWithoutOrderInput, orderDetailsUncheckedUpdateWithoutOrderInput>
    create: XOR<orderDetailsCreateWithoutOrderInput, orderDetailsUncheckedCreateWithoutOrderInput>
    where?: orderDetailsWhereInput
  }

  export type orderDetailsUpdateToOneWithWhereWithoutOrderInput = {
    where?: orderDetailsWhereInput
    data: XOR<orderDetailsUpdateWithoutOrderInput, orderDetailsUncheckedUpdateWithoutOrderInput>
  }

  export type orderDetailsUpdateWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Detail?: NullableStringFieldUpdateOperationsInput | string | null
    AmountX?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountY?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountH?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountW?: NullableFloatFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderDetailsUncheckedUpdateWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Detail?: NullableStringFieldUpdateOperationsInput | string | null
    AmountX?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountY?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountH?: NullableFloatFieldUpdateOperationsInput | number | null
    AmountW?: NullableFloatFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderPaymentUpsertWithoutOrderInput = {
    update: XOR<orderPaymentUpdateWithoutOrderInput, orderPaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<orderPaymentCreateWithoutOrderInput, orderPaymentUncheckedCreateWithoutOrderInput>
    where?: orderPaymentWhereInput
  }

  export type orderPaymentUpdateToOneWithWhereWithoutOrderInput = {
    where?: orderPaymentWhereInput
    data: XOR<orderPaymentUpdateWithoutOrderInput, orderPaymentUncheckedUpdateWithoutOrderInput>
  }

  export type orderPaymentUpdateWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    PaymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AmountDeliver?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPaid?: BoolFieldUpdateOperationsInput | boolean
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PaidTo?: usersUpdateOneWithoutRecipientPaymentNestedInput
    Transaction?: transactionUpdateOneWithoutOrderPaymentNestedInput
  }

  export type orderPaymentUncheckedUpdateWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    PaymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AmountDeliver?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPaid?: BoolFieldUpdateOperationsInput | boolean
    PaidToID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Transaction?: transactionUncheckedUpdateOneWithoutOrderPaymentNestedInput
  }

  export type branchesUpsertWithoutOrderInput = {
    update: XOR<branchesUpdateWithoutOrderInput, branchesUncheckedUpdateWithoutOrderInput>
    create: XOR<branchesCreateWithoutOrderInput, branchesUncheckedCreateWithoutOrderInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutOrderInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutOrderInput, branchesUncheckedUpdateWithoutOrderInput>
  }

  export type branchesUpdateWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUpdateOneWithoutBranchesNestedInput
    User?: usersUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUpdateManyWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUpdateManyWithoutBranchesNestedInput
    Otp?: otpUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUncheckedUpdateOneWithoutBranchesNestedInput
    User?: usersUncheckedUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUncheckedUpdateManyWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUncheckedUpdateManyWithoutBranchesNestedInput
    Otp?: otpUncheckedUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUncheckedUpdateManyWithoutBranchesNestedInput
    Tracking?: orderTackingUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type usersUpsertWithoutOrderInput = {
    update: XOR<usersUpdateWithoutOrderInput, usersUncheckedUpdateWithoutOrderInput>
    create: XOR<usersCreateWithoutOrderInput, usersUncheckedCreateWithoutOrderInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutOrderInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutOrderInput, usersUncheckedUpdateWithoutOrderInput>
  }

  export type usersUpdateWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutUserNestedInput
    Wallet?: walletUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUpdateOneWithoutUserNestedInput
    OTP?: otpUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUpdateManyWithoutUsersNestedInput
    SenderOrder?: orderPersonalUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersUncheckedUpdateWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Wallet?: walletUncheckedUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUncheckedUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUncheckedUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUncheckedUpdateOneWithoutUserNestedInput
    OTP?: otpUncheckedUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUncheckedUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUncheckedUpdateManyWithoutUsersNestedInput
    SenderOrder?: orderPersonalUncheckedUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUncheckedUpdateManyWithoutRecipientUserNestedInput
  }

  export type orderTackingUpsertWithWhereUniqueWithoutOrderInput = {
    where: orderTackingWhereUniqueInput
    update: XOR<orderTackingUpdateWithoutOrderInput, orderTackingUncheckedUpdateWithoutOrderInput>
    create: XOR<orderTackingCreateWithoutOrderInput, orderTackingUncheckedCreateWithoutOrderInput>
  }

  export type orderTackingUpdateWithWhereUniqueWithoutOrderInput = {
    where: orderTackingWhereUniqueInput
    data: XOR<orderTackingUpdateWithoutOrderInput, orderTackingUncheckedUpdateWithoutOrderInput>
  }

  export type orderTackingUpdateManyWithWhereWithoutOrderInput = {
    where: orderTackingScalarWhereInput
    data: XOR<orderTackingUpdateManyMutationInput, orderTackingUncheckedUpdateManyWithoutOrderInput>
  }

  export type orderThreadingUpsertWithWhereUniqueWithoutOrderInput = {
    where: orderThreadingWhereUniqueInput
    update: XOR<orderThreadingUpdateWithoutOrderInput, orderThreadingUncheckedUpdateWithoutOrderInput>
    create: XOR<orderThreadingCreateWithoutOrderInput, orderThreadingUncheckedCreateWithoutOrderInput>
  }

  export type orderThreadingUpdateWithWhereUniqueWithoutOrderInput = {
    where: orderThreadingWhereUniqueInput
    data: XOR<orderThreadingUpdateWithoutOrderInput, orderThreadingUncheckedUpdateWithoutOrderInput>
  }

  export type orderThreadingUpdateManyWithWhereWithoutOrderInput = {
    where: orderThreadingScalarWhereInput
    data: XOR<orderThreadingUpdateManyMutationInput, orderThreadingUncheckedUpdateManyWithoutOrderInput>
  }

  export type orderThreadingScalarWhereInput = {
    AND?: orderThreadingScalarWhereInput | orderThreadingScalarWhereInput[]
    OR?: orderThreadingScalarWhereInput[]
    NOT?: orderThreadingScalarWhereInput | orderThreadingScalarWhereInput[]
    ID?: StringFilter<"orderThreading"> | string
    Tasks?: StringNullableFilter<"orderThreading"> | string | null
    ActivitieID?: StringNullableFilter<"orderThreading"> | string | null
    OrderID?: StringNullableFilter<"orderThreading"> | string | null
    Status?: StringNullableFilter<"orderThreading"> | string | null
    IsActive?: BoolFilter<"orderThreading"> | boolean
    CreatedAt?: DateTimeFilter<"orderThreading"> | Date | string
    UpdatedAt?: DateTimeNullableFilter<"orderThreading"> | Date | string | null
  }

  export type usersActivitiesCreateWithoutThreadingOrderInput = {
    ID?: string
    Activity?: string | null
    IP?: string | null
    MacAddress?: string | null
    UDID?: string | null
    Remask?: string | null
    Log?: string | null
    Error?: string | null
    Messages?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Users?: usersCreateNestedOneWithoutActivitiesInput
  }

  export type usersActivitiesUncheckedCreateWithoutThreadingOrderInput = {
    ID?: string
    Activity?: string | null
    IP?: string | null
    MacAddress?: string | null
    UDID?: string | null
    Remask?: string | null
    Log?: string | null
    Error?: string | null
    Messages?: string | null
    UsersID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type usersActivitiesCreateOrConnectWithoutThreadingOrderInput = {
    where: usersActivitiesWhereUniqueInput
    create: XOR<usersActivitiesCreateWithoutThreadingOrderInput, usersActivitiesUncheckedCreateWithoutThreadingOrderInput>
  }

  export type orderCreateWithoutThreadingInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Category?: orderCategoryCreateNestedOneWithoutOrderInput
    Personal?: orderPersonalCreateNestedOneWithoutOrderInput
    Details?: orderDetailsCreateNestedOneWithoutOrderInput
    Payment?: orderPaymentCreateNestedOneWithoutOrderInput
    Branches?: branchesCreateNestedOneWithoutOrderInput
    CreateBy?: usersCreateNestedOneWithoutOrderInput
    Tacking?: orderTackingCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutThreadingInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    CategoryID?: string | null
    BranchesID?: string | null
    CreateByID?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Personal?: orderPersonalUncheckedCreateNestedOneWithoutOrderInput
    Details?: orderDetailsUncheckedCreateNestedOneWithoutOrderInput
    Payment?: orderPaymentUncheckedCreateNestedOneWithoutOrderInput
    Tacking?: orderTackingUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutThreadingInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutThreadingInput, orderUncheckedCreateWithoutThreadingInput>
  }

  export type usersActivitiesUpsertWithoutThreadingOrderInput = {
    update: XOR<usersActivitiesUpdateWithoutThreadingOrderInput, usersActivitiesUncheckedUpdateWithoutThreadingOrderInput>
    create: XOR<usersActivitiesCreateWithoutThreadingOrderInput, usersActivitiesUncheckedCreateWithoutThreadingOrderInput>
    where?: usersActivitiesWhereInput
  }

  export type usersActivitiesUpdateToOneWithWhereWithoutThreadingOrderInput = {
    where?: usersActivitiesWhereInput
    data: XOR<usersActivitiesUpdateWithoutThreadingOrderInput, usersActivitiesUncheckedUpdateWithoutThreadingOrderInput>
  }

  export type usersActivitiesUpdateWithoutThreadingOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Activity?: NullableStringFieldUpdateOperationsInput | string | null
    IP?: NullableStringFieldUpdateOperationsInput | string | null
    MacAddress?: NullableStringFieldUpdateOperationsInput | string | null
    UDID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Log?: NullableStringFieldUpdateOperationsInput | string | null
    Error?: NullableStringFieldUpdateOperationsInput | string | null
    Messages?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: usersUpdateOneWithoutActivitiesNestedInput
  }

  export type usersActivitiesUncheckedUpdateWithoutThreadingOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Activity?: NullableStringFieldUpdateOperationsInput | string | null
    IP?: NullableStringFieldUpdateOperationsInput | string | null
    MacAddress?: NullableStringFieldUpdateOperationsInput | string | null
    UDID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Log?: NullableStringFieldUpdateOperationsInput | string | null
    Error?: NullableStringFieldUpdateOperationsInput | string | null
    Messages?: NullableStringFieldUpdateOperationsInput | string | null
    UsersID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderUpsertWithoutThreadingInput = {
    update: XOR<orderUpdateWithoutThreadingInput, orderUncheckedUpdateWithoutThreadingInput>
    create: XOR<orderCreateWithoutThreadingInput, orderUncheckedCreateWithoutThreadingInput>
    where?: orderWhereInput
  }

  export type orderUpdateToOneWithWhereWithoutThreadingInput = {
    where?: orderWhereInput
    data: XOR<orderUpdateWithoutThreadingInput, orderUncheckedUpdateWithoutThreadingInput>
  }

  export type orderUpdateWithoutThreadingInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Category?: orderCategoryUpdateOneWithoutOrderNestedInput
    Personal?: orderPersonalUpdateOneWithoutOrderNestedInput
    Details?: orderDetailsUpdateOneWithoutOrderNestedInput
    Payment?: orderPaymentUpdateOneWithoutOrderNestedInput
    Branches?: branchesUpdateOneWithoutOrderNestedInput
    CreateBy?: usersUpdateOneWithoutOrderNestedInput
    Tacking?: orderTackingUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutThreadingInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    CategoryID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    CreateByID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Personal?: orderPersonalUncheckedUpdateOneWithoutOrderNestedInput
    Details?: orderDetailsUncheckedUpdateOneWithoutOrderNestedInput
    Payment?: orderPaymentUncheckedUpdateOneWithoutOrderNestedInput
    Tacking?: orderTackingUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type usersCreateWithoutSenderOrderInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutUserInput
    Wallet?: walletCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileCreateNestedManyWithoutAdminInput
    UserProfile?: profileCreateNestedOneWithoutUserInput
    OTP?: otpCreateNestedManyWithoutUsersInput
    Roles?: usersRolesCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordCreateNestedManyWithoutUsersInput
    Notifications?: notificationsCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesCreateNestedManyWithoutUsersInput
    Order?: orderCreateNestedManyWithoutCreateByInput
    RecipientOrder?: orderPersonalCreateNestedManyWithoutRecipientUserInput
  }

  export type usersUncheckedCreateWithoutSenderOrderInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    BranchesID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Wallet?: walletUncheckedCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentUncheckedCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileUncheckedCreateNestedManyWithoutAdminInput
    UserProfile?: profileUncheckedCreateNestedOneWithoutUserInput
    OTP?: otpUncheckedCreateNestedManyWithoutUsersInput
    Roles?: usersRolesUncheckedCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesUncheckedCreateNestedManyWithoutUsersInput
    Order?: orderUncheckedCreateNestedManyWithoutCreateByInput
    RecipientOrder?: orderPersonalUncheckedCreateNestedManyWithoutRecipientUserInput
  }

  export type usersCreateOrConnectWithoutSenderOrderInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSenderOrderInput, usersUncheckedCreateWithoutSenderOrderInput>
  }

  export type usersCreateWithoutRecipientOrderInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutUserInput
    Wallet?: walletCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileCreateNestedManyWithoutAdminInput
    UserProfile?: profileCreateNestedOneWithoutUserInput
    OTP?: otpCreateNestedManyWithoutUsersInput
    Roles?: usersRolesCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordCreateNestedManyWithoutUsersInput
    Notifications?: notificationsCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesCreateNestedManyWithoutUsersInput
    Order?: orderCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalCreateNestedManyWithoutSenderUserInput
  }

  export type usersUncheckedCreateWithoutRecipientOrderInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    BranchesID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Wallet?: walletUncheckedCreateNestedManyWithoutUserInput
    RecipientPayment?: orderPaymentUncheckedCreateNestedManyWithoutPaidToInput
    AdminProfile?: profileUncheckedCreateNestedManyWithoutAdminInput
    UserProfile?: profileUncheckedCreateNestedOneWithoutUserInput
    OTP?: otpUncheckedCreateNestedManyWithoutUsersInput
    Roles?: usersRolesUncheckedCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesUncheckedCreateNestedManyWithoutUsersInput
    Order?: orderUncheckedCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalUncheckedCreateNestedManyWithoutSenderUserInput
  }

  export type usersCreateOrConnectWithoutRecipientOrderInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRecipientOrderInput, usersUncheckedCreateWithoutRecipientOrderInput>
  }

  export type orderCreateWithoutPersonalInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Category?: orderCategoryCreateNestedOneWithoutOrderInput
    Details?: orderDetailsCreateNestedOneWithoutOrderInput
    Payment?: orderPaymentCreateNestedOneWithoutOrderInput
    Branches?: branchesCreateNestedOneWithoutOrderInput
    CreateBy?: usersCreateNestedOneWithoutOrderInput
    Tacking?: orderTackingCreateNestedManyWithoutOrderInput
    Threading?: orderThreadingCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutPersonalInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    CategoryID?: string | null
    BranchesID?: string | null
    CreateByID?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Details?: orderDetailsUncheckedCreateNestedOneWithoutOrderInput
    Payment?: orderPaymentUncheckedCreateNestedOneWithoutOrderInput
    Tacking?: orderTackingUncheckedCreateNestedManyWithoutOrderInput
    Threading?: orderThreadingUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutPersonalInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutPersonalInput, orderUncheckedCreateWithoutPersonalInput>
  }

  export type usersUpsertWithoutSenderOrderInput = {
    update: XOR<usersUpdateWithoutSenderOrderInput, usersUncheckedUpdateWithoutSenderOrderInput>
    create: XOR<usersCreateWithoutSenderOrderInput, usersUncheckedCreateWithoutSenderOrderInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSenderOrderInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSenderOrderInput, usersUncheckedUpdateWithoutSenderOrderInput>
  }

  export type usersUpdateWithoutSenderOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutUserNestedInput
    Wallet?: walletUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUpdateOneWithoutUserNestedInput
    OTP?: otpUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUpdateManyWithoutUsersNestedInput
    Order?: orderUpdateManyWithoutCreateByNestedInput
    RecipientOrder?: orderPersonalUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersUncheckedUpdateWithoutSenderOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Wallet?: walletUncheckedUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUncheckedUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUncheckedUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUncheckedUpdateOneWithoutUserNestedInput
    OTP?: otpUncheckedUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUncheckedUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUncheckedUpdateManyWithoutUsersNestedInput
    Order?: orderUncheckedUpdateManyWithoutCreateByNestedInput
    RecipientOrder?: orderPersonalUncheckedUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersUpsertWithoutRecipientOrderInput = {
    update: XOR<usersUpdateWithoutRecipientOrderInput, usersUncheckedUpdateWithoutRecipientOrderInput>
    create: XOR<usersCreateWithoutRecipientOrderInput, usersUncheckedCreateWithoutRecipientOrderInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutRecipientOrderInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutRecipientOrderInput, usersUncheckedUpdateWithoutRecipientOrderInput>
  }

  export type usersUpdateWithoutRecipientOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutUserNestedInput
    Wallet?: walletUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUpdateOneWithoutUserNestedInput
    OTP?: otpUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUpdateManyWithoutUsersNestedInput
    Order?: orderUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUpdateManyWithoutSenderUserNestedInput
  }

  export type usersUncheckedUpdateWithoutRecipientOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Wallet?: walletUncheckedUpdateManyWithoutUserNestedInput
    RecipientPayment?: orderPaymentUncheckedUpdateManyWithoutPaidToNestedInput
    AdminProfile?: profileUncheckedUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUncheckedUpdateOneWithoutUserNestedInput
    OTP?: otpUncheckedUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUncheckedUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUncheckedUpdateManyWithoutUsersNestedInput
    Order?: orderUncheckedUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUncheckedUpdateManyWithoutSenderUserNestedInput
  }

  export type orderUpsertWithoutPersonalInput = {
    update: XOR<orderUpdateWithoutPersonalInput, orderUncheckedUpdateWithoutPersonalInput>
    create: XOR<orderCreateWithoutPersonalInput, orderUncheckedCreateWithoutPersonalInput>
    where?: orderWhereInput
  }

  export type orderUpdateToOneWithWhereWithoutPersonalInput = {
    where?: orderWhereInput
    data: XOR<orderUpdateWithoutPersonalInput, orderUncheckedUpdateWithoutPersonalInput>
  }

  export type orderUpdateWithoutPersonalInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Category?: orderCategoryUpdateOneWithoutOrderNestedInput
    Details?: orderDetailsUpdateOneWithoutOrderNestedInput
    Payment?: orderPaymentUpdateOneWithoutOrderNestedInput
    Branches?: branchesUpdateOneWithoutOrderNestedInput
    CreateBy?: usersUpdateOneWithoutOrderNestedInput
    Tacking?: orderTackingUpdateManyWithoutOrderNestedInput
    Threading?: orderThreadingUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutPersonalInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    CategoryID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    CreateByID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Details?: orderDetailsUncheckedUpdateOneWithoutOrderNestedInput
    Payment?: orderPaymentUncheckedUpdateOneWithoutOrderNestedInput
    Tacking?: orderTackingUncheckedUpdateManyWithoutOrderNestedInput
    Threading?: orderThreadingUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type orderCreateWithoutPaymentInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Category?: orderCategoryCreateNestedOneWithoutOrderInput
    Personal?: orderPersonalCreateNestedOneWithoutOrderInput
    Details?: orderDetailsCreateNestedOneWithoutOrderInput
    Branches?: branchesCreateNestedOneWithoutOrderInput
    CreateBy?: usersCreateNestedOneWithoutOrderInput
    Tacking?: orderTackingCreateNestedManyWithoutOrderInput
    Threading?: orderThreadingCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutPaymentInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    CategoryID?: string | null
    BranchesID?: string | null
    CreateByID?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Personal?: orderPersonalUncheckedCreateNestedOneWithoutOrderInput
    Details?: orderDetailsUncheckedCreateNestedOneWithoutOrderInput
    Tacking?: orderTackingUncheckedCreateNestedManyWithoutOrderInput
    Threading?: orderThreadingUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutPaymentInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutPaymentInput, orderUncheckedCreateWithoutPaymentInput>
  }

  export type usersCreateWithoutRecipientPaymentInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Branches?: branchesCreateNestedOneWithoutUserInput
    Wallet?: walletCreateNestedManyWithoutUserInput
    AdminProfile?: profileCreateNestedManyWithoutAdminInput
    UserProfile?: profileCreateNestedOneWithoutUserInput
    OTP?: otpCreateNestedManyWithoutUsersInput
    Roles?: usersRolesCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordCreateNestedManyWithoutUsersInput
    Notifications?: notificationsCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesCreateNestedManyWithoutUsersInput
    Order?: orderCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalCreateNestedManyWithoutRecipientUserInput
  }

  export type usersUncheckedCreateWithoutRecipientPaymentInput = {
    ID?: string
    UserName: string
    Password: string
    URL?: string | null
    PhoneNumber: string
    Email?: string | null
    Pin?: string | null
    IsRemember?: boolean | null
    IsPin?: boolean | null
    IsBiometric?: boolean | null
    Status?: string | null
    Remask?: string | null
    LastActive?: Date | string | null
    BranchesID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Wallet?: walletUncheckedCreateNestedManyWithoutUserInput
    AdminProfile?: profileUncheckedCreateNestedManyWithoutAdminInput
    UserProfile?: profileUncheckedCreateNestedOneWithoutUserInput
    OTP?: otpUncheckedCreateNestedManyWithoutUsersInput
    Roles?: usersRolesUncheckedCreateNestedManyWithoutUsersInput
    Forgot?: forgotPasswordUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    Activities?: usersActivitiesUncheckedCreateNestedManyWithoutUsersInput
    Order?: orderUncheckedCreateNestedManyWithoutCreateByInput
    SenderOrder?: orderPersonalUncheckedCreateNestedManyWithoutSenderUserInput
    RecipientOrder?: orderPersonalUncheckedCreateNestedManyWithoutRecipientUserInput
  }

  export type usersCreateOrConnectWithoutRecipientPaymentInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRecipientPaymentInput, usersUncheckedCreateWithoutRecipientPaymentInput>
  }

  export type transactionCreateWithoutOrderPaymentInput = {
    ID?: string
    Type?: string | null
    Info?: string | null
    Status?: string | null
    Result?: number | null
    Balance?: number | null
    IsPayment?: boolean | null
    IsReceived?: boolean | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    PaidBy?: walletCreateNestedOneWithoutPaymentInput
    PaidTo?: walletCreateNestedOneWithoutReceiveInput
  }

  export type transactionUncheckedCreateWithoutOrderPaymentInput = {
    ID?: string
    Type?: string | null
    Info?: string | null
    Status?: string | null
    Result?: number | null
    Balance?: number | null
    IsPayment?: boolean | null
    IsReceived?: boolean | null
    PaidByID?: string | null
    PaidToID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type transactionCreateOrConnectWithoutOrderPaymentInput = {
    where: transactionWhereUniqueInput
    create: XOR<transactionCreateWithoutOrderPaymentInput, transactionUncheckedCreateWithoutOrderPaymentInput>
  }

  export type orderUpsertWithoutPaymentInput = {
    update: XOR<orderUpdateWithoutPaymentInput, orderUncheckedUpdateWithoutPaymentInput>
    create: XOR<orderCreateWithoutPaymentInput, orderUncheckedCreateWithoutPaymentInput>
    where?: orderWhereInput
  }

  export type orderUpdateToOneWithWhereWithoutPaymentInput = {
    where?: orderWhereInput
    data: XOR<orderUpdateWithoutPaymentInput, orderUncheckedUpdateWithoutPaymentInput>
  }

  export type orderUpdateWithoutPaymentInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Category?: orderCategoryUpdateOneWithoutOrderNestedInput
    Personal?: orderPersonalUpdateOneWithoutOrderNestedInput
    Details?: orderDetailsUpdateOneWithoutOrderNestedInput
    Branches?: branchesUpdateOneWithoutOrderNestedInput
    CreateBy?: usersUpdateOneWithoutOrderNestedInput
    Tacking?: orderTackingUpdateManyWithoutOrderNestedInput
    Threading?: orderThreadingUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutPaymentInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    CategoryID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    CreateByID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Personal?: orderPersonalUncheckedUpdateOneWithoutOrderNestedInput
    Details?: orderDetailsUncheckedUpdateOneWithoutOrderNestedInput
    Tacking?: orderTackingUncheckedUpdateManyWithoutOrderNestedInput
    Threading?: orderThreadingUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type usersUpsertWithoutRecipientPaymentInput = {
    update: XOR<usersUpdateWithoutRecipientPaymentInput, usersUncheckedUpdateWithoutRecipientPaymentInput>
    create: XOR<usersCreateWithoutRecipientPaymentInput, usersUncheckedCreateWithoutRecipientPaymentInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutRecipientPaymentInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutRecipientPaymentInput, usersUncheckedUpdateWithoutRecipientPaymentInput>
  }

  export type usersUpdateWithoutRecipientPaymentInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutUserNestedInput
    Wallet?: walletUpdateManyWithoutUserNestedInput
    AdminProfile?: profileUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUpdateOneWithoutUserNestedInput
    OTP?: otpUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUpdateManyWithoutUsersNestedInput
    Order?: orderUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUpdateManyWithoutRecipientUserNestedInput
  }

  export type usersUncheckedUpdateWithoutRecipientPaymentInput = {
    ID?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Pin?: NullableStringFieldUpdateOperationsInput | string | null
    IsRemember?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsPin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsBiometric?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    LastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Wallet?: walletUncheckedUpdateManyWithoutUserNestedInput
    AdminProfile?: profileUncheckedUpdateManyWithoutAdminNestedInput
    UserProfile?: profileUncheckedUpdateOneWithoutUserNestedInput
    OTP?: otpUncheckedUpdateManyWithoutUsersNestedInput
    Roles?: usersRolesUncheckedUpdateManyWithoutUsersNestedInput
    Forgot?: forgotPasswordUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    Activities?: usersActivitiesUncheckedUpdateManyWithoutUsersNestedInput
    Order?: orderUncheckedUpdateManyWithoutCreateByNestedInput
    SenderOrder?: orderPersonalUncheckedUpdateManyWithoutSenderUserNestedInput
    RecipientOrder?: orderPersonalUncheckedUpdateManyWithoutRecipientUserNestedInput
  }

  export type transactionUpsertWithoutOrderPaymentInput = {
    update: XOR<transactionUpdateWithoutOrderPaymentInput, transactionUncheckedUpdateWithoutOrderPaymentInput>
    create: XOR<transactionCreateWithoutOrderPaymentInput, transactionUncheckedCreateWithoutOrderPaymentInput>
    where?: transactionWhereInput
  }

  export type transactionUpdateToOneWithWhereWithoutOrderPaymentInput = {
    where?: transactionWhereInput
    data: XOR<transactionUpdateWithoutOrderPaymentInput, transactionUncheckedUpdateWithoutOrderPaymentInput>
  }

  export type transactionUpdateWithoutOrderPaymentInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Info?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Result?: NullableFloatFieldUpdateOperationsInput | number | null
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsReceived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PaidBy?: walletUpdateOneWithoutPaymentNestedInput
    PaidTo?: walletUpdateOneWithoutReceiveNestedInput
  }

  export type transactionUncheckedUpdateWithoutOrderPaymentInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Info?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Result?: NullableFloatFieldUpdateOperationsInput | number | null
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsReceived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaidByID?: NullableStringFieldUpdateOperationsInput | string | null
    PaidToID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderCreateWithoutDetailsInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Category?: orderCategoryCreateNestedOneWithoutOrderInput
    Personal?: orderPersonalCreateNestedOneWithoutOrderInput
    Payment?: orderPaymentCreateNestedOneWithoutOrderInput
    Branches?: branchesCreateNestedOneWithoutOrderInput
    CreateBy?: usersCreateNestedOneWithoutOrderInput
    Tacking?: orderTackingCreateNestedManyWithoutOrderInput
    Threading?: orderThreadingCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutDetailsInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    CategoryID?: string | null
    BranchesID?: string | null
    CreateByID?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Personal?: orderPersonalUncheckedCreateNestedOneWithoutOrderInput
    Payment?: orderPaymentUncheckedCreateNestedOneWithoutOrderInput
    Tacking?: orderTackingUncheckedCreateNestedManyWithoutOrderInput
    Threading?: orderThreadingUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutDetailsInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutDetailsInput, orderUncheckedCreateWithoutDetailsInput>
  }

  export type orderUpsertWithoutDetailsInput = {
    update: XOR<orderUpdateWithoutDetailsInput, orderUncheckedUpdateWithoutDetailsInput>
    create: XOR<orderCreateWithoutDetailsInput, orderUncheckedCreateWithoutDetailsInput>
    where?: orderWhereInput
  }

  export type orderUpdateToOneWithWhereWithoutDetailsInput = {
    where?: orderWhereInput
    data: XOR<orderUpdateWithoutDetailsInput, orderUncheckedUpdateWithoutDetailsInput>
  }

  export type orderUpdateWithoutDetailsInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Category?: orderCategoryUpdateOneWithoutOrderNestedInput
    Personal?: orderPersonalUpdateOneWithoutOrderNestedInput
    Payment?: orderPaymentUpdateOneWithoutOrderNestedInput
    Branches?: branchesUpdateOneWithoutOrderNestedInput
    CreateBy?: usersUpdateOneWithoutOrderNestedInput
    Tacking?: orderTackingUpdateManyWithoutOrderNestedInput
    Threading?: orderThreadingUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutDetailsInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    CategoryID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    CreateByID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Personal?: orderPersonalUncheckedUpdateOneWithoutOrderNestedInput
    Payment?: orderPaymentUncheckedUpdateOneWithoutOrderNestedInput
    Tacking?: orderTackingUncheckedUpdateManyWithoutOrderNestedInput
    Threading?: orderThreadingUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type orderTackingCreateWithoutTrackingStatusInput = {
    ID?: string
    Number?: string | null
    PrimaryPhoneNumber?: string | null
    SecondaryName?: string | null
    SecondaryPhoneNumber?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Order?: orderCreateNestedOneWithoutTackingInput
    Branches?: branchesCreateNestedOneWithoutTrackingInput
  }

  export type orderTackingUncheckedCreateWithoutTrackingStatusInput = {
    ID?: string
    Number?: string | null
    PrimaryPhoneNumber?: string | null
    SecondaryName?: string | null
    SecondaryPhoneNumber?: string | null
    OrderID?: string | null
    BranchesID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderTackingCreateOrConnectWithoutTrackingStatusInput = {
    where: orderTackingWhereUniqueInput
    create: XOR<orderTackingCreateWithoutTrackingStatusInput, orderTackingUncheckedCreateWithoutTrackingStatusInput>
  }

  export type orderTackingCreateManyTrackingStatusInputEnvelope = {
    data: orderTackingCreateManyTrackingStatusInput | orderTackingCreateManyTrackingStatusInput[]
    skipDuplicates?: boolean
  }

  export type orderTackingUpsertWithWhereUniqueWithoutTrackingStatusInput = {
    where: orderTackingWhereUniqueInput
    update: XOR<orderTackingUpdateWithoutTrackingStatusInput, orderTackingUncheckedUpdateWithoutTrackingStatusInput>
    create: XOR<orderTackingCreateWithoutTrackingStatusInput, orderTackingUncheckedCreateWithoutTrackingStatusInput>
  }

  export type orderTackingUpdateWithWhereUniqueWithoutTrackingStatusInput = {
    where: orderTackingWhereUniqueInput
    data: XOR<orderTackingUpdateWithoutTrackingStatusInput, orderTackingUncheckedUpdateWithoutTrackingStatusInput>
  }

  export type orderTackingUpdateManyWithWhereWithoutTrackingStatusInput = {
    where: orderTackingScalarWhereInput
    data: XOR<orderTackingUpdateManyMutationInput, orderTackingUncheckedUpdateManyWithoutTrackingStatusInput>
  }

  export type orderCreateWithoutTackingInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Category?: orderCategoryCreateNestedOneWithoutOrderInput
    Personal?: orderPersonalCreateNestedOneWithoutOrderInput
    Details?: orderDetailsCreateNestedOneWithoutOrderInput
    Payment?: orderPaymentCreateNestedOneWithoutOrderInput
    Branches?: branchesCreateNestedOneWithoutOrderInput
    CreateBy?: usersCreateNestedOneWithoutOrderInput
    Threading?: orderThreadingCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutTackingInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    CategoryID?: string | null
    BranchesID?: string | null
    CreateByID?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Personal?: orderPersonalUncheckedCreateNestedOneWithoutOrderInput
    Details?: orderDetailsUncheckedCreateNestedOneWithoutOrderInput
    Payment?: orderPaymentUncheckedCreateNestedOneWithoutOrderInput
    Threading?: orderThreadingUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutTackingInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutTackingInput, orderUncheckedCreateWithoutTackingInput>
  }

  export type branchesCreateWithoutTrackingInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressCreateNestedOneWithoutBranchesInput
    User?: usersCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyCreateNestedManyWithoutBranchesInput
    BranchesSettings?: branchesSettingsCreateNestedManyWithoutBranchesInput
    Otp?: otpCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryCreateNestedManyWithoutBranchesInput
    Order?: orderCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutTrackingInput = {
    ID?: string
    CompanyId?: string
    Name: string
    Address1?: string | null
    Address2?: string | null
    Address3?: string | null
    Status?: string | null
    Lat?: number | null
    Long?: number | null
    Zone?: string | null
    IsMain?: boolean | null
    UploadURL?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
    Address?: addressUncheckedCreateNestedOneWithoutBranchesInput
    User?: usersUncheckedCreateNestedOneWithoutBranchesInput
    BranchesKey?: branchesKeyUncheckedCreateNestedManyWithoutBranchesInput
    BranchesSettings?: branchesSettingsUncheckedCreateNestedManyWithoutBranchesInput
    Otp?: otpUncheckedCreateNestedManyWithoutBranchesInput
    Notifications?: notificationsUncheckedCreateNestedManyWithoutBranchesInput
    OrderCategory?: orderCategoryUncheckedCreateNestedManyWithoutBranchesInput
    Order?: orderUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutTrackingInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutTrackingInput, branchesUncheckedCreateWithoutTrackingInput>
  }

  export type tackingStatusCreateWithoutTrackingInput = {
    ID?: string
    Status?: string | null
    Description?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type tackingStatusUncheckedCreateWithoutTrackingInput = {
    ID?: string
    Status?: string | null
    Description?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type tackingStatusCreateOrConnectWithoutTrackingInput = {
    where: tackingStatusWhereUniqueInput
    create: XOR<tackingStatusCreateWithoutTrackingInput, tackingStatusUncheckedCreateWithoutTrackingInput>
  }

  export type orderUpsertWithoutTackingInput = {
    update: XOR<orderUpdateWithoutTackingInput, orderUncheckedUpdateWithoutTackingInput>
    create: XOR<orderCreateWithoutTackingInput, orderUncheckedCreateWithoutTackingInput>
    where?: orderWhereInput
  }

  export type orderUpdateToOneWithWhereWithoutTackingInput = {
    where?: orderWhereInput
    data: XOR<orderUpdateWithoutTackingInput, orderUncheckedUpdateWithoutTackingInput>
  }

  export type orderUpdateWithoutTackingInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Category?: orderCategoryUpdateOneWithoutOrderNestedInput
    Personal?: orderPersonalUpdateOneWithoutOrderNestedInput
    Details?: orderDetailsUpdateOneWithoutOrderNestedInput
    Payment?: orderPaymentUpdateOneWithoutOrderNestedInput
    Branches?: branchesUpdateOneWithoutOrderNestedInput
    CreateBy?: usersUpdateOneWithoutOrderNestedInput
    Threading?: orderThreadingUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutTackingInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    CategoryID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    CreateByID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Personal?: orderPersonalUncheckedUpdateOneWithoutOrderNestedInput
    Details?: orderDetailsUncheckedUpdateOneWithoutOrderNestedInput
    Payment?: orderPaymentUncheckedUpdateOneWithoutOrderNestedInput
    Threading?: orderThreadingUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type branchesUpsertWithoutTrackingInput = {
    update: XOR<branchesUpdateWithoutTrackingInput, branchesUncheckedUpdateWithoutTrackingInput>
    create: XOR<branchesCreateWithoutTrackingInput, branchesUncheckedCreateWithoutTrackingInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutTrackingInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutTrackingInput, branchesUncheckedUpdateWithoutTrackingInput>
  }

  export type branchesUpdateWithoutTrackingInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUpdateOneWithoutBranchesNestedInput
    User?: usersUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUpdateManyWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUpdateManyWithoutBranchesNestedInput
    Otp?: otpUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUpdateManyWithoutBranchesNestedInput
    Order?: orderUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutTrackingInput = {
    ID?: StringFieldUpdateOperationsInput | string
    CompanyId?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address1?: NullableStringFieldUpdateOperationsInput | string | null
    Address2?: NullableStringFieldUpdateOperationsInput | string | null
    Address3?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Lat?: NullableFloatFieldUpdateOperationsInput | number | null
    Long?: NullableFloatFieldUpdateOperationsInput | number | null
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    IsMain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UploadURL?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUncheckedUpdateOneWithoutBranchesNestedInput
    User?: usersUncheckedUpdateOneWithoutBranchesNestedInput
    BranchesKey?: branchesKeyUncheckedUpdateManyWithoutBranchesNestedInput
    BranchesSettings?: branchesSettingsUncheckedUpdateManyWithoutBranchesNestedInput
    Otp?: otpUncheckedUpdateManyWithoutBranchesNestedInput
    Notifications?: notificationsUncheckedUpdateManyWithoutBranchesNestedInput
    OrderCategory?: orderCategoryUncheckedUpdateManyWithoutBranchesNestedInput
    Order?: orderUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type tackingStatusUpsertWithoutTrackingInput = {
    update: XOR<tackingStatusUpdateWithoutTrackingInput, tackingStatusUncheckedUpdateWithoutTrackingInput>
    create: XOR<tackingStatusCreateWithoutTrackingInput, tackingStatusUncheckedCreateWithoutTrackingInput>
    where?: tackingStatusWhereInput
  }

  export type tackingStatusUpdateToOneWithWhereWithoutTrackingInput = {
    where?: tackingStatusWhereInput
    data: XOR<tackingStatusUpdateWithoutTrackingInput, tackingStatusUncheckedUpdateWithoutTrackingInput>
  }

  export type tackingStatusUpdateWithoutTrackingInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tackingStatusUncheckedUpdateWithoutTrackingInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type districtCreateManyProvinceInput = {
    ID?: string
    Name: string
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type villageCreateManyProvinceInput = {
    ID?: string
    Name: string
    DistrictID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type addressCreateManyProvinceInput = {
    ID?: string
    Address: string
    DistrictID?: string | null
    ProfileID?: string | null
    BranchesID?: string | null
    IsDefault?: boolean | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type districtUpdateWithoutProvinceInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUpdateManyWithoutDistrictNestedInput
    Village?: villageUpdateManyWithoutDistrictNestedInput
  }

  export type districtUncheckedUpdateWithoutProvinceInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUncheckedUpdateManyWithoutDistrictNestedInput
    Village?: villageUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type districtUncheckedUpdateManyWithoutProvinceInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type villageUpdateWithoutProvinceInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    District?: districtUpdateOneWithoutVillageNestedInput
  }

  export type villageUncheckedUpdateWithoutProvinceInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    DistrictID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type villageUncheckedUpdateManyWithoutProvinceInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    DistrictID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type addressUpdateWithoutProvinceInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    IsDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    District?: districtUpdateOneWithoutAddressNestedInput
    Profile?: profileUpdateOneWithoutAddressNestedInput
    Branches?: branchesUpdateOneWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateWithoutProvinceInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    DistrictID?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type addressUncheckedUpdateManyWithoutProvinceInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    DistrictID?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type addressCreateManyDistrictInput = {
    ID?: string
    Address: string
    ProvinceID?: string | null
    ProfileID?: string | null
    BranchesID?: string | null
    IsDefault?: boolean | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type villageCreateManyDistrictInput = {
    ID?: string
    Name: string
    ProvinceID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type addressUpdateWithoutDistrictInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    IsDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Province?: provinceUpdateOneWithoutAddressNestedInput
    Profile?: profileUpdateOneWithoutAddressNestedInput
    Branches?: branchesUpdateOneWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateWithoutDistrictInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    ProvinceID?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type addressUncheckedUpdateManyWithoutDistrictInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    ProvinceID?: NullableStringFieldUpdateOperationsInput | string | null
    ProfileID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type villageUpdateWithoutDistrictInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Province?: provinceUpdateOneWithoutVillageNestedInput
  }

  export type villageUncheckedUpdateWithoutDistrictInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    ProvinceID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type villageUncheckedUpdateManyWithoutDistrictInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    ProvinceID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type branchesKeyCreateManyBranchesInput = {
    ID?: string
    Key: string
    Secret: string
    Remask?: string | null
    Status: string
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type branchesSettingsCreateManyBranchesInput = {
    ID?: string
    Titel: string
    Setting: string
    Remask?: string | null
    Status: string
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type otpCreateManyBranchesInput = {
    ID?: string
    OTP?: string | null
    IsVerify?: boolean
    UserName: string
    Type?: string | null
    Remask?: string | null
    UsersID?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type notificationsCreateManyBranchesInput = {
    ID?: string
    Titel?: string | null
    Details?: string | null
    Type?: string | null
    Provider?: string | null
    Remask?: string | null
    UsersID?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderCategoryCreateManyBranchesInput = {
    ID?: string
    TypeCode?: string | null
    TypeNmae?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderCreateManyBranchesInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    CategoryID?: string | null
    CreateByID?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderTackingCreateManyBranchesInput = {
    ID?: string
    Number?: string | null
    PrimaryPhoneNumber?: string | null
    SecondaryName?: string | null
    SecondaryPhoneNumber?: string | null
    OrderID?: string | null
    TrackingStatusID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type branchesKeyUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Key?: StringFieldUpdateOperationsInput | string
    Secret?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type branchesKeyUncheckedUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Key?: StringFieldUpdateOperationsInput | string
    Secret?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type branchesKeyUncheckedUpdateManyWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Key?: StringFieldUpdateOperationsInput | string
    Secret?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type branchesSettingsUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: StringFieldUpdateOperationsInput | string
    Setting?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type branchesSettingsUncheckedUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: StringFieldUpdateOperationsInput | string
    Setting?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type branchesSettingsUncheckedUpdateManyWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: StringFieldUpdateOperationsInput | string
    Setting?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type otpUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    OTP?: NullableStringFieldUpdateOperationsInput | string | null
    IsVerify?: BoolFieldUpdateOperationsInput | boolean
    UserName?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: usersUpdateOneWithoutOTPNestedInput
  }

  export type otpUncheckedUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    OTP?: NullableStringFieldUpdateOperationsInput | string | null
    IsVerify?: BoolFieldUpdateOperationsInput | boolean
    UserName?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    UsersID?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type otpUncheckedUpdateManyWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    OTP?: NullableStringFieldUpdateOperationsInput | string | null
    IsVerify?: BoolFieldUpdateOperationsInput | boolean
    UserName?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    UsersID?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationsUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: usersUpdateOneWithoutNotificationsNestedInput
  }

  export type notificationsUncheckedUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    UsersID?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationsUncheckedUpdateManyWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    UsersID?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderCategoryUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    TypeCode?: NullableStringFieldUpdateOperationsInput | string | null
    TypeNmae?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Order?: orderUpdateManyWithoutCategoryNestedInput
  }

  export type orderCategoryUncheckedUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    TypeCode?: NullableStringFieldUpdateOperationsInput | string | null
    TypeNmae?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Order?: orderUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type orderCategoryUncheckedUpdateManyWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    TypeCode?: NullableStringFieldUpdateOperationsInput | string | null
    TypeNmae?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Category?: orderCategoryUpdateOneWithoutOrderNestedInput
    Personal?: orderPersonalUpdateOneWithoutOrderNestedInput
    Details?: orderDetailsUpdateOneWithoutOrderNestedInput
    Payment?: orderPaymentUpdateOneWithoutOrderNestedInput
    CreateBy?: usersUpdateOneWithoutOrderNestedInput
    Tacking?: orderTackingUpdateManyWithoutOrderNestedInput
    Threading?: orderThreadingUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    CategoryID?: NullableStringFieldUpdateOperationsInput | string | null
    CreateByID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Personal?: orderPersonalUncheckedUpdateOneWithoutOrderNestedInput
    Details?: orderDetailsUncheckedUpdateOneWithoutOrderNestedInput
    Payment?: orderPaymentUncheckedUpdateOneWithoutOrderNestedInput
    Tacking?: orderTackingUncheckedUpdateManyWithoutOrderNestedInput
    Threading?: orderThreadingUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateManyWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    CategoryID?: NullableStringFieldUpdateOperationsInput | string | null
    CreateByID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderTackingUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Number?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryName?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Order?: orderUpdateOneWithoutTackingNestedInput
    TrackingStatus?: tackingStatusUpdateOneWithoutTrackingNestedInput
  }

  export type orderTackingUncheckedUpdateWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Number?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryName?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    TrackingStatusID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderTackingUncheckedUpdateManyWithoutBranchesInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Number?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryName?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    TrackingStatusID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionCreateManyPaidToInput = {
    ID?: string
    Type?: string | null
    Info?: string | null
    Status?: string | null
    Result?: number | null
    Balance?: number | null
    IsPayment?: boolean | null
    IsReceived?: boolean | null
    OrderPaymentID?: string | null
    PaidByID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type transactionCreateManyPaidByInput = {
    ID?: string
    Type?: string | null
    Info?: string | null
    Status?: string | null
    Result?: number | null
    Balance?: number | null
    IsPayment?: boolean | null
    IsReceived?: boolean | null
    OrderPaymentID?: string | null
    PaidToID?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type transactionUpdateWithoutPaidToInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Info?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Result?: NullableFloatFieldUpdateOperationsInput | number | null
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsReceived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderPayment?: orderPaymentUpdateOneWithoutTransactionNestedInput
    PaidBy?: walletUpdateOneWithoutPaymentNestedInput
  }

  export type transactionUncheckedUpdateWithoutPaidToInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Info?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Result?: NullableFloatFieldUpdateOperationsInput | number | null
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsReceived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    OrderPaymentID?: NullableStringFieldUpdateOperationsInput | string | null
    PaidByID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionUncheckedUpdateManyWithoutPaidToInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Info?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Result?: NullableFloatFieldUpdateOperationsInput | number | null
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsReceived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    OrderPaymentID?: NullableStringFieldUpdateOperationsInput | string | null
    PaidByID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionUpdateWithoutPaidByInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Info?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Result?: NullableFloatFieldUpdateOperationsInput | number | null
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsReceived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderPayment?: orderPaymentUpdateOneWithoutTransactionNestedInput
    PaidTo?: walletUpdateOneWithoutReceiveNestedInput
  }

  export type transactionUncheckedUpdateWithoutPaidByInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Info?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Result?: NullableFloatFieldUpdateOperationsInput | number | null
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsReceived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    OrderPaymentID?: NullableStringFieldUpdateOperationsInput | string | null
    PaidToID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionUncheckedUpdateManyWithoutPaidByInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Info?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Result?: NullableFloatFieldUpdateOperationsInput | number | null
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    IsReceived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    OrderPaymentID?: NullableStringFieldUpdateOperationsInput | string | null
    PaidToID?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type walletCreateManyUserInput = {
    ID?: string
    Balance?: number | null
    Title?: string | null
    Description?: string | null
    IsReal?: boolean | null
    Status?: string | null
    Remask?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderPaymentCreateManyPaidToInput = {
    ID?: string
    PaymentStatus?: string | null
    AmountDeliver?: number | null
    IsPaid?: boolean
    OrderID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type profileCreateManyAdminInput = {
    ID?: string
    Gender?: string | null
    Name: string
    SurName: string
    ProfileURL?: string | null
    UserID?: string | null
    AdminPin?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type otpCreateManyUsersInput = {
    ID?: string
    OTP?: string | null
    IsVerify?: boolean
    UserName: string
    Type?: string | null
    Remask?: string | null
    BranchesID?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type usersRolesCreateManyUsersInput = {
    ID?: string
    Titel?: string | null
    Type?: string | null
    Role: string
    Permission: string
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type forgotPasswordCreateManyUsersInput = {
    ID?: string
    Titel?: string | null
    Token?: string | null
    OldPassword?: string | null
    OtpID?: string | null
    Provider?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type notificationsCreateManyUsersInput = {
    ID?: string
    Titel?: string | null
    Details?: string | null
    Type?: string | null
    Provider?: string | null
    Remask?: string | null
    BranchesID?: string | null
    SmsGatewayUUID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type usersActivitiesCreateManyUsersInput = {
    ID?: string
    Activity?: string | null
    IP?: string | null
    MacAddress?: string | null
    UDID?: string | null
    Remask?: string | null
    Log?: string | null
    Error?: string | null
    Messages?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderCreateManyCreateByInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    CategoryID?: string | null
    BranchesID?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderPersonalCreateManySenderUserInput = {
    ID?: string
    SenderName?: string | null
    SenderPhoneNumber?: string | null
    RecipientName?: string | null
    RecipientPhoneNumber?: string | null
    RecipientID?: string | null
    OrderID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderPersonalCreateManyRecipientUserInput = {
    ID?: string
    SenderName?: string | null
    SenderPhoneNumber?: string | null
    SenderUserID?: string | null
    RecipientName?: string | null
    RecipientPhoneNumber?: string | null
    OrderID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type walletUpdateWithoutUserInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsReal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Receive?: transactionUpdateManyWithoutPaidToNestedInput
    Payment?: transactionUpdateManyWithoutPaidByNestedInput
  }

  export type walletUncheckedUpdateWithoutUserInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsReal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Receive?: transactionUncheckedUpdateManyWithoutPaidToNestedInput
    Payment?: transactionUncheckedUpdateManyWithoutPaidByNestedInput
  }

  export type walletUncheckedUpdateManyWithoutUserInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Balance?: NullableFloatFieldUpdateOperationsInput | number | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    IsReal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderPaymentUpdateWithoutPaidToInput = {
    ID?: StringFieldUpdateOperationsInput | string
    PaymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AmountDeliver?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPaid?: BoolFieldUpdateOperationsInput | boolean
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Order?: orderUpdateOneWithoutPaymentNestedInput
    Transaction?: transactionUpdateOneWithoutOrderPaymentNestedInput
  }

  export type orderPaymentUncheckedUpdateWithoutPaidToInput = {
    ID?: StringFieldUpdateOperationsInput | string
    PaymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AmountDeliver?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPaid?: BoolFieldUpdateOperationsInput | boolean
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Transaction?: transactionUncheckedUpdateOneWithoutOrderPaymentNestedInput
  }

  export type orderPaymentUncheckedUpdateManyWithoutPaidToInput = {
    ID?: StringFieldUpdateOperationsInput | string
    PaymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    AmountDeliver?: NullableFloatFieldUpdateOperationsInput | number | null
    IsPaid?: BoolFieldUpdateOperationsInput | boolean
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type profileUpdateWithoutAdminInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    SurName?: StringFieldUpdateOperationsInput | string
    ProfileURL?: NullableStringFieldUpdateOperationsInput | string | null
    AdminPin?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: usersUpdateOneWithoutUserProfileNestedInput
    Address?: addressUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutAdminInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    SurName?: StringFieldUpdateOperationsInput | string
    ProfileURL?: NullableStringFieldUpdateOperationsInput | string | null
    UserID?: NullableStringFieldUpdateOperationsInput | string | null
    AdminPin?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: addressUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateManyWithoutAdminInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    SurName?: StringFieldUpdateOperationsInput | string
    ProfileURL?: NullableStringFieldUpdateOperationsInput | string | null
    UserID?: NullableStringFieldUpdateOperationsInput | string | null
    AdminPin?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type otpUpdateWithoutUsersInput = {
    ID?: StringFieldUpdateOperationsInput | string
    OTP?: NullableStringFieldUpdateOperationsInput | string | null
    IsVerify?: BoolFieldUpdateOperationsInput | boolean
    UserName?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutOtpNestedInput
  }

  export type otpUncheckedUpdateWithoutUsersInput = {
    ID?: StringFieldUpdateOperationsInput | string
    OTP?: NullableStringFieldUpdateOperationsInput | string | null
    IsVerify?: BoolFieldUpdateOperationsInput | boolean
    UserName?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type otpUncheckedUpdateManyWithoutUsersInput = {
    ID?: StringFieldUpdateOperationsInput | string
    OTP?: NullableStringFieldUpdateOperationsInput | string | null
    IsVerify?: BoolFieldUpdateOperationsInput | boolean
    UserName?: StringFieldUpdateOperationsInput | string
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersRolesUpdateWithoutUsersInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: StringFieldUpdateOperationsInput | string
    Permission?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersRolesUncheckedUpdateWithoutUsersInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: StringFieldUpdateOperationsInput | string
    Permission?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersRolesUncheckedUpdateManyWithoutUsersInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Role?: StringFieldUpdateOperationsInput | string
    Permission?: StringFieldUpdateOperationsInput | string
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forgotPasswordUpdateWithoutUsersInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Token?: NullableStringFieldUpdateOperationsInput | string | null
    OldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    OtpID?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forgotPasswordUncheckedUpdateWithoutUsersInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Token?: NullableStringFieldUpdateOperationsInput | string | null
    OldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    OtpID?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type forgotPasswordUncheckedUpdateManyWithoutUsersInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Token?: NullableStringFieldUpdateOperationsInput | string | null
    OldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    OtpID?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationsUpdateWithoutUsersInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutNotificationsNestedInput
  }

  export type notificationsUncheckedUpdateWithoutUsersInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationsUncheckedUpdateManyWithoutUsersInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Titel?: NullableStringFieldUpdateOperationsInput | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    SmsGatewayUUID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersActivitiesUpdateWithoutUsersInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Activity?: NullableStringFieldUpdateOperationsInput | string | null
    IP?: NullableStringFieldUpdateOperationsInput | string | null
    MacAddress?: NullableStringFieldUpdateOperationsInput | string | null
    UDID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Log?: NullableStringFieldUpdateOperationsInput | string | null
    Error?: NullableStringFieldUpdateOperationsInput | string | null
    Messages?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ThreadingOrder?: orderThreadingUpdateOneWithoutActivitieNestedInput
  }

  export type usersActivitiesUncheckedUpdateWithoutUsersInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Activity?: NullableStringFieldUpdateOperationsInput | string | null
    IP?: NullableStringFieldUpdateOperationsInput | string | null
    MacAddress?: NullableStringFieldUpdateOperationsInput | string | null
    UDID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Log?: NullableStringFieldUpdateOperationsInput | string | null
    Error?: NullableStringFieldUpdateOperationsInput | string | null
    Messages?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ThreadingOrder?: orderThreadingUncheckedUpdateOneWithoutActivitieNestedInput
  }

  export type usersActivitiesUncheckedUpdateManyWithoutUsersInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Activity?: NullableStringFieldUpdateOperationsInput | string | null
    IP?: NullableStringFieldUpdateOperationsInput | string | null
    MacAddress?: NullableStringFieldUpdateOperationsInput | string | null
    UDID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Log?: NullableStringFieldUpdateOperationsInput | string | null
    Error?: NullableStringFieldUpdateOperationsInput | string | null
    Messages?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderUpdateWithoutCreateByInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Category?: orderCategoryUpdateOneWithoutOrderNestedInput
    Personal?: orderPersonalUpdateOneWithoutOrderNestedInput
    Details?: orderDetailsUpdateOneWithoutOrderNestedInput
    Payment?: orderPaymentUpdateOneWithoutOrderNestedInput
    Branches?: branchesUpdateOneWithoutOrderNestedInput
    Tacking?: orderTackingUpdateManyWithoutOrderNestedInput
    Threading?: orderThreadingUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutCreateByInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    CategoryID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Personal?: orderPersonalUncheckedUpdateOneWithoutOrderNestedInput
    Details?: orderDetailsUncheckedUpdateOneWithoutOrderNestedInput
    Payment?: orderPaymentUncheckedUpdateOneWithoutOrderNestedInput
    Tacking?: orderTackingUncheckedUpdateManyWithoutOrderNestedInput
    Threading?: orderThreadingUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateManyWithoutCreateByInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    CategoryID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderPersonalUpdateWithoutSenderUserInput = {
    ID?: StringFieldUpdateOperationsInput | string
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    SenderPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientName?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RecipientUser?: usersUpdateOneWithoutRecipientOrderNestedInput
    Order?: orderUpdateOneWithoutPersonalNestedInput
  }

  export type orderPersonalUncheckedUpdateWithoutSenderUserInput = {
    ID?: StringFieldUpdateOperationsInput | string
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    SenderPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientName?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientID?: NullableStringFieldUpdateOperationsInput | string | null
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderPersonalUncheckedUpdateManyWithoutSenderUserInput = {
    ID?: StringFieldUpdateOperationsInput | string
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    SenderPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientName?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientID?: NullableStringFieldUpdateOperationsInput | string | null
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderPersonalUpdateWithoutRecipientUserInput = {
    ID?: StringFieldUpdateOperationsInput | string
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    SenderPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientName?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SenderUser?: usersUpdateOneWithoutSenderOrderNestedInput
    Order?: orderUpdateOneWithoutPersonalNestedInput
  }

  export type orderPersonalUncheckedUpdateWithoutRecipientUserInput = {
    ID?: StringFieldUpdateOperationsInput | string
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    SenderPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SenderUserID?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientName?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderPersonalUncheckedUpdateManyWithoutRecipientUserInput = {
    ID?: StringFieldUpdateOperationsInput | string
    SenderName?: NullableStringFieldUpdateOperationsInput | string | null
    SenderPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SenderUserID?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientName?: NullableStringFieldUpdateOperationsInput | string | null
    RecipientPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type addressCreateManyProfileInput = {
    ID?: string
    Address: string
    ProvinceID?: string | null
    DistrictID?: string | null
    BranchesID?: string | null
    IsDefault?: boolean | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type addressUpdateWithoutProfileInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    IsDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Province?: provinceUpdateOneWithoutAddressNestedInput
    District?: districtUpdateOneWithoutAddressNestedInput
    Branches?: branchesUpdateOneWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateWithoutProfileInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    ProvinceID?: NullableStringFieldUpdateOperationsInput | string | null
    DistrictID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type addressUncheckedUpdateManyWithoutProfileInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    ProvinceID?: NullableStringFieldUpdateOperationsInput | string | null
    DistrictID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    IsDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderCreateManyCategoryInput = {
    ID?: string
    Code?: string | null
    PrimaryCode?: string | null
    SecondaryCode?: string | null
    OrderDate?: Date | string | null
    Name?: string | null
    UplaodURL?: string | null
    BranchesID?: string | null
    CreateByID?: string | null
    Remask?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderUpdateWithoutCategoryInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Personal?: orderPersonalUpdateOneWithoutOrderNestedInput
    Details?: orderDetailsUpdateOneWithoutOrderNestedInput
    Payment?: orderPaymentUpdateOneWithoutOrderNestedInput
    Branches?: branchesUpdateOneWithoutOrderNestedInput
    CreateBy?: usersUpdateOneWithoutOrderNestedInput
    Tacking?: orderTackingUpdateManyWithoutOrderNestedInput
    Threading?: orderThreadingUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutCategoryInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    CreateByID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Personal?: orderPersonalUncheckedUpdateOneWithoutOrderNestedInput
    Details?: orderDetailsUncheckedUpdateOneWithoutOrderNestedInput
    Payment?: orderPaymentUncheckedUpdateOneWithoutOrderNestedInput
    Tacking?: orderTackingUncheckedUpdateManyWithoutOrderNestedInput
    Threading?: orderThreadingUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateManyWithoutCategoryInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Code?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryCode?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    UplaodURL?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    CreateByID?: NullableStringFieldUpdateOperationsInput | string | null
    Remask?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderTackingCreateManyOrderInput = {
    ID?: string
    Number?: string | null
    PrimaryPhoneNumber?: string | null
    SecondaryName?: string | null
    SecondaryPhoneNumber?: string | null
    BranchesID?: string | null
    TrackingStatusID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderThreadingCreateManyOrderInput = {
    ID?: string
    Tasks?: string | null
    ActivitieID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderTackingUpdateWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Number?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryName?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Branches?: branchesUpdateOneWithoutTrackingNestedInput
    TrackingStatus?: tackingStatusUpdateOneWithoutTrackingNestedInput
  }

  export type orderTackingUncheckedUpdateWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Number?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryName?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    TrackingStatusID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderTackingUncheckedUpdateManyWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Number?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryName?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    TrackingStatusID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderThreadingUpdateWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Tasks?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Activitie?: usersActivitiesUpdateOneWithoutThreadingOrderNestedInput
  }

  export type orderThreadingUncheckedUpdateWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Tasks?: NullableStringFieldUpdateOperationsInput | string | null
    ActivitieID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderThreadingUncheckedUpdateManyWithoutOrderInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Tasks?: NullableStringFieldUpdateOperationsInput | string | null
    ActivitieID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderTackingCreateManyTrackingStatusInput = {
    ID?: string
    Number?: string | null
    PrimaryPhoneNumber?: string | null
    SecondaryName?: string | null
    SecondaryPhoneNumber?: string | null
    OrderID?: string | null
    BranchesID?: string | null
    Status?: string | null
    IsActive?: boolean
    CreatedAt?: Date | string
    UpdatedAt?: Date | string | null
  }

  export type orderTackingUpdateWithoutTrackingStatusInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Number?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryName?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Order?: orderUpdateOneWithoutTackingNestedInput
    Branches?: branchesUpdateOneWithoutTrackingNestedInput
  }

  export type orderTackingUncheckedUpdateWithoutTrackingStatusInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Number?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryName?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type orderTackingUncheckedUpdateManyWithoutTrackingStatusInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Number?: NullableStringFieldUpdateOperationsInput | string | null
    PrimaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryName?: NullableStringFieldUpdateOperationsInput | string | null
    SecondaryPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    OrderID?: NullableStringFieldUpdateOperationsInput | string | null
    BranchesID?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ProvinceCountOutputTypeDefaultArgs instead
     */
    export type ProvinceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProvinceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistrictCountOutputTypeDefaultArgs instead
     */
    export type DistrictCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistrictCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchesCountOutputTypeDefaultArgs instead
     */
    export type BranchesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WalletCountOutputTypeDefaultArgs instead
     */
    export type WalletCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WalletCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileCountOutputTypeDefaultArgs instead
     */
    export type ProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderCategoryCountOutputTypeDefaultArgs instead
     */
    export type OrderCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderCountOutputTypeDefaultArgs instead
     */
    export type OrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TackingStatusCountOutputTypeDefaultArgs instead
     */
    export type TackingStatusCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TackingStatusCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use provinceDefaultArgs instead
     */
    export type provinceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = provinceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use districtDefaultArgs instead
     */
    export type districtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = districtDefaultArgs<ExtArgs>
    /**
     * @deprecated Use villageDefaultArgs instead
     */
    export type villageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = villageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use addressDefaultArgs instead
     */
    export type addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = addressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use branchesDefaultArgs instead
     */
    export type branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = branchesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use branchesKeyDefaultArgs instead
     */
    export type branchesKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = branchesKeyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use branchesSettingsDefaultArgs instead
     */
    export type branchesSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = branchesSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use walletDefaultArgs instead
     */
    export type walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = walletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use transactionDefaultArgs instead
     */
    export type transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = transactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use profileDefaultArgs instead
     */
    export type profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = profileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use otpDefaultArgs instead
     */
    export type otpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = otpDefaultArgs<ExtArgs>
    /**
     * @deprecated Use notificationsDefaultArgs instead
     */
    export type notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = notificationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use forgotPasswordDefaultArgs instead
     */
    export type forgotPasswordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = forgotPasswordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersRolesDefaultArgs instead
     */
    export type usersRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersRolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersActivitiesDefaultArgs instead
     */
    export type usersActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersActivitiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use orderTypeDefaultArgs instead
     */
    export type orderTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = orderTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use orderCategoryDefaultArgs instead
     */
    export type orderCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = orderCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use orderDefaultArgs instead
     */
    export type orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = orderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use orderThreadingDefaultArgs instead
     */
    export type orderThreadingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = orderThreadingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use orderPersonalDefaultArgs instead
     */
    export type orderPersonalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = orderPersonalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use orderPaymentDefaultArgs instead
     */
    export type orderPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = orderPaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use orderDetailsDefaultArgs instead
     */
    export type orderDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = orderDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tackingStatusDefaultArgs instead
     */
    export type tackingStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tackingStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use orderTackingDefaultArgs instead
     */
    export type orderTackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = orderTackingDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}